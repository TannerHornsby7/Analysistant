/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them\n\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/prettier/standalone.js":
/*!*********************************************!*\
  !*** ./node_modules/prettier/standalone.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (e) {\n  if (true) module.exports = e();else { var f; }\n})(function () {\n  \"use strict\";\n\n  var we = (e, n) => () => (n || e((n = {\n    exports: {}\n  }).exports, n), n.exports);\n  var Ye = we((Ig, ru) => {\n    var rr = function (e) {\n      return e && e.Math == Math && e;\n    };\n    ru.exports = rr(typeof globalThis == \"object\" && globalThis) || rr(typeof window == \"object\" && window) || rr(typeof self == \"object\" && self) || rr(typeof __webpack_require__.g == \"object\" && __webpack_require__.g) || function () {\n      return this;\n    }() || Function(\"return this\")();\n  });\n  var Dt = we((Lg, nu) => {\n    nu.exports = function (e) {\n      try {\n        return !!e();\n      } catch {\n        return !0;\n      }\n    };\n  });\n  var Ct = we((jg, uu) => {\n    var So = Dt();\n    uu.exports = !So(function () {\n      return Object.defineProperty({}, 1, {\n        get: function () {\n          return 7;\n        }\n      })[1] != 7;\n    });\n  });\n  var nr = we((Og, su) => {\n    var xo = Dt();\n    su.exports = !xo(function () {\n      var e = function () {}.bind();\n      return typeof e != \"function\" || e.hasOwnProperty(\"prototype\");\n    });\n  });\n  var Et = we((qg, iu) => {\n    var bo = nr(),\n      ur = Function.prototype.call;\n    iu.exports = bo ? ur.bind(ur) : function () {\n      return ur.apply(ur, arguments);\n    };\n  });\n  var cu = we(lu => {\n    \"use strict\";\n\n    var au = {}.propertyIsEnumerable,\n      ou = Object.getOwnPropertyDescriptor,\n      To = ou && !au.call({\n        1: 2\n      }, 1);\n    lu.f = To ? function (n) {\n      var t = ou(this, n);\n      return !!t && t.enumerable;\n    } : au;\n  });\n  var sr = we((Rg, pu) => {\n    pu.exports = function (e, n) {\n      return {\n        enumerable: !(e & 1),\n        configurable: !(e & 2),\n        writable: !(e & 4),\n        value: n\n      };\n    };\n  });\n  var at = we((Vg, mu) => {\n    var fu = nr(),\n      Du = Function.prototype,\n      Bo = Du.bind,\n      Or = Du.call,\n      No = fu && Bo.bind(Or, Or);\n    mu.exports = fu ? function (e) {\n      return e && No(e);\n    } : function (e) {\n      return e && function () {\n        return Or.apply(e, arguments);\n      };\n    };\n  });\n  var ir = we((Wg, gu) => {\n    var du = at(),\n      wo = du({}.toString),\n      _o = du(\"\".slice);\n    gu.exports = function (e) {\n      return _o(wo(e), 8, -1);\n    };\n  });\n  var hu = we(($g, yu) => {\n    var Po = Ye(),\n      ko = at(),\n      Io = Dt(),\n      Lo = ir(),\n      qr = Po.Object,\n      jo = ko(\"\".split);\n    yu.exports = Io(function () {\n      return !qr(\"z\").propertyIsEnumerable(0);\n    }) ? function (e) {\n      return Lo(e) == \"String\" ? jo(e, \"\") : qr(e);\n    } : qr;\n  });\n  var Mr = we((Hg, vu) => {\n    var Oo = Ye(),\n      qo = Oo.TypeError;\n    vu.exports = function (e) {\n      if (e == null) throw qo(\"Can't call method on \" + e);\n      return e;\n    };\n  });\n  var ar = we((Gg, Cu) => {\n    var Mo = hu(),\n      Ro = Mr();\n    Cu.exports = function (e) {\n      return Mo(Ro(e));\n    };\n  });\n  var ot = we((Jg, Eu) => {\n    Eu.exports = function (e) {\n      return typeof e == \"function\";\n    };\n  });\n  var Ft = we((Ug, Fu) => {\n    var Vo = ot();\n    Fu.exports = function (e) {\n      return typeof e == \"object\" ? e !== null : Vo(e);\n    };\n  });\n  var Rt = we((zg, Au) => {\n    var Rr = Ye(),\n      Wo = ot(),\n      $o = function (e) {\n        return Wo(e) ? e : void 0;\n      };\n    Au.exports = function (e, n) {\n      return arguments.length < 2 ? $o(Rr[e]) : Rr[e] && Rr[e][n];\n    };\n  });\n  var Vr = we((Xg, Su) => {\n    var Ho = at();\n    Su.exports = Ho({}.isPrototypeOf);\n  });\n  var bu = we((Kg, xu) => {\n    var Go = Rt();\n    xu.exports = Go(\"navigator\", \"userAgent\") || \"\";\n  });\n  var ku = we((Yg, Pu) => {\n    var _u = Ye(),\n      Wr = bu(),\n      Tu = _u.process,\n      Bu = _u.Deno,\n      Nu = Tu && Tu.versions || Bu && Bu.version,\n      wu = Nu && Nu.v8,\n      ft,\n      or;\n    wu && (ft = wu.split(\".\"), or = ft[0] > 0 && ft[0] < 4 ? 1 : +(ft[0] + ft[1]));\n    !or && Wr && (ft = Wr.match(/Edge\\/(\\d+)/), (!ft || ft[1] >= 74) && (ft = Wr.match(/Chrome\\/(\\d+)/), ft && (or = +ft[1])));\n    Pu.exports = or;\n  });\n  var $r = we((Qg, Lu) => {\n    var Iu = ku(),\n      Jo = Dt();\n    Lu.exports = !!Object.getOwnPropertySymbols && !Jo(function () {\n      var e = Symbol();\n      return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Iu && Iu < 41;\n    });\n  });\n  var Hr = we((Zg, ju) => {\n    var Uo = $r();\n    ju.exports = Uo && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n  });\n  var Gr = we((e0, Ou) => {\n    var zo = Ye(),\n      Xo = Rt(),\n      Ko = ot(),\n      Yo = Vr(),\n      Qo = Hr(),\n      Zo = zo.Object;\n    Ou.exports = Qo ? function (e) {\n      return typeof e == \"symbol\";\n    } : function (e) {\n      var n = Xo(\"Symbol\");\n      return Ko(n) && Yo(n.prototype, Zo(e));\n    };\n  });\n  var lr = we((t0, qu) => {\n    var el = Ye(),\n      tl = el.String;\n    qu.exports = function (e) {\n      try {\n        return tl(e);\n      } catch {\n        return \"Object\";\n      }\n    };\n  });\n  var Vt = we((r0, Mu) => {\n    var rl = Ye(),\n      nl = ot(),\n      ul = lr(),\n      sl = rl.TypeError;\n    Mu.exports = function (e) {\n      if (nl(e)) return e;\n      throw sl(ul(e) + \" is not a function\");\n    };\n  });\n  var cr = we((n0, Ru) => {\n    var il = Vt();\n    Ru.exports = function (e, n) {\n      var t = e[n];\n      return t == null ? void 0 : il(t);\n    };\n  });\n  var Wu = we((u0, Vu) => {\n    var al = Ye(),\n      Jr = Et(),\n      Ur = ot(),\n      zr = Ft(),\n      ol = al.TypeError;\n    Vu.exports = function (e, n) {\n      var t, s;\n      if (n === \"string\" && Ur(t = e.toString) && !zr(s = Jr(t, e)) || Ur(t = e.valueOf) && !zr(s = Jr(t, e)) || n !== \"string\" && Ur(t = e.toString) && !zr(s = Jr(t, e))) return s;\n      throw ol(\"Can't convert object to primitive value\");\n    };\n  });\n  var Hu = we((s0, $u) => {\n    $u.exports = !1;\n  });\n  var pr = we((i0, Ju) => {\n    var Gu = Ye(),\n      ll = Object.defineProperty;\n    Ju.exports = function (e, n) {\n      try {\n        ll(Gu, e, {\n          value: n,\n          configurable: !0,\n          writable: !0\n        });\n      } catch {\n        Gu[e] = n;\n      }\n      return n;\n    };\n  });\n  var fr = we((a0, zu) => {\n    var cl = Ye(),\n      pl = pr(),\n      Uu = \"__core-js_shared__\",\n      fl = cl[Uu] || pl(Uu, {});\n    zu.exports = fl;\n  });\n  var Xr = we((o0, Ku) => {\n    var Dl = Hu(),\n      Xu = fr();\n    (Ku.exports = function (e, n) {\n      return Xu[e] || (Xu[e] = n !== void 0 ? n : {});\n    })(\"versions\", []).push({\n      version: \"3.22.2\",\n      mode: Dl ? \"pure\" : \"global\",\n      copyright: \"\\xA9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n      license: \"https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE\",\n      source: \"https://github.com/zloirock/core-js\"\n    });\n  });\n  var Dr = we((l0, Yu) => {\n    var ml = Ye(),\n      dl = Mr(),\n      gl = ml.Object;\n    Yu.exports = function (e) {\n      return gl(dl(e));\n    };\n  });\n  var gt = we((c0, Qu) => {\n    var yl = at(),\n      hl = Dr(),\n      vl = yl({}.hasOwnProperty);\n    Qu.exports = Object.hasOwn || function (n, t) {\n      return vl(hl(n), t);\n    };\n  });\n  var Kr = we((p0, Zu) => {\n    var Cl = at(),\n      El = 0,\n      Fl = Math.random(),\n      Al = Cl(1 .toString);\n    Zu.exports = function (e) {\n      return \"Symbol(\" + (e === void 0 ? \"\" : e) + \")_\" + Al(++El + Fl, 36);\n    };\n  });\n  var St = we((f0, us) => {\n    var Sl = Ye(),\n      xl = Xr(),\n      es = gt(),\n      bl = Kr(),\n      ts = $r(),\n      ns = Hr(),\n      Nt = xl(\"wks\"),\n      At = Sl.Symbol,\n      rs = At && At.for,\n      Tl = ns ? At : At && At.withoutSetter || bl;\n    us.exports = function (e) {\n      if (!es(Nt, e) || !(ts || typeof Nt[e] == \"string\")) {\n        var n = \"Symbol.\" + e;\n        ts && es(At, e) ? Nt[e] = At[e] : ns && rs ? Nt[e] = rs(n) : Nt[e] = Tl(n);\n      }\n      return Nt[e];\n    };\n  });\n  var os = we((D0, as) => {\n    var Bl = Ye(),\n      Nl = Et(),\n      ss = Ft(),\n      is = Gr(),\n      wl = cr(),\n      _l = Wu(),\n      Pl = St(),\n      kl = Bl.TypeError,\n      Il = Pl(\"toPrimitive\");\n    as.exports = function (e, n) {\n      if (!ss(e) || is(e)) return e;\n      var t = wl(e, Il),\n        s;\n      if (t) {\n        if (n === void 0 && (n = \"default\"), s = Nl(t, e, n), !ss(s) || is(s)) return s;\n        throw kl(\"Can't convert object to primitive value\");\n      }\n      return n === void 0 && (n = \"number\"), _l(e, n);\n    };\n  });\n  var mr = we((m0, ls) => {\n    var Ll = os(),\n      jl = Gr();\n    ls.exports = function (e) {\n      var n = Ll(e, \"string\");\n      return jl(n) ? n : n + \"\";\n    };\n  });\n  var fs = we((d0, ps) => {\n    var Ol = Ye(),\n      cs = Ft(),\n      Yr = Ol.document,\n      ql = cs(Yr) && cs(Yr.createElement);\n    ps.exports = function (e) {\n      return ql ? Yr.createElement(e) : {};\n    };\n  });\n  var Qr = we((g0, Ds) => {\n    var Ml = Ct(),\n      Rl = Dt(),\n      Vl = fs();\n    Ds.exports = !Ml && !Rl(function () {\n      return Object.defineProperty(Vl(\"div\"), \"a\", {\n        get: function () {\n          return 7;\n        }\n      }).a != 7;\n    });\n  });\n  var Zr = we(ds => {\n    var Wl = Ct(),\n      $l = Et(),\n      Hl = cu(),\n      Gl = sr(),\n      Jl = ar(),\n      Ul = mr(),\n      zl = gt(),\n      Xl = Qr(),\n      ms = Object.getOwnPropertyDescriptor;\n    ds.f = Wl ? ms : function (n, t) {\n      if (n = Jl(n), t = Ul(t), Xl) try {\n        return ms(n, t);\n      } catch {}\n      if (zl(n, t)) return Gl(!$l(Hl.f, n, t), n[t]);\n    };\n  });\n  var ys = we((h0, gs) => {\n    var Kl = Ct(),\n      Yl = Dt();\n    gs.exports = Kl && Yl(function () {\n      return Object.defineProperty(function () {}, \"prototype\", {\n        value: 42,\n        writable: !1\n      }).prototype != 42;\n    });\n  });\n  var wt = we((v0, vs) => {\n    var hs = Ye(),\n      Ql = Ft(),\n      Zl = hs.String,\n      ec = hs.TypeError;\n    vs.exports = function (e) {\n      if (Ql(e)) return e;\n      throw ec(Zl(e) + \" is not an object\");\n    };\n  });\n  var gr = we(Es => {\n    var tc = Ye(),\n      rc = Ct(),\n      nc = Qr(),\n      uc = ys(),\n      dr = wt(),\n      Cs = mr(),\n      sc = tc.TypeError,\n      en = Object.defineProperty,\n      ic = Object.getOwnPropertyDescriptor,\n      tn = \"enumerable\",\n      rn = \"configurable\",\n      nn = \"writable\";\n    Es.f = rc ? uc ? function (n, t, s) {\n      if (dr(n), t = Cs(t), dr(s), typeof n == \"function\" && t === \"prototype\" && \"value\" in s && nn in s && !s[nn]) {\n        var a = ic(n, t);\n        a && a[nn] && (n[t] = s.value, s = {\n          configurable: rn in s ? s[rn] : a[rn],\n          enumerable: tn in s ? s[tn] : a[tn],\n          writable: !1\n        });\n      }\n      return en(n, t, s);\n    } : en : function (n, t, s) {\n      if (dr(n), t = Cs(t), dr(s), nc) try {\n        return en(n, t, s);\n      } catch {}\n      if (\"get\" in s || \"set\" in s) throw sc(\"Accessors not supported\");\n      return \"value\" in s && (n[t] = s.value), n;\n    };\n  });\n  var yr = we((E0, Fs) => {\n    var ac = Ct(),\n      oc = gr(),\n      lc = sr();\n    Fs.exports = ac ? function (e, n, t) {\n      return oc.f(e, n, lc(1, t));\n    } : function (e, n, t) {\n      return e[n] = t, e;\n    };\n  });\n  var hr = we((F0, As) => {\n    var cc = at(),\n      pc = ot(),\n      un = fr(),\n      fc = cc(Function.toString);\n    pc(un.inspectSource) || (un.inspectSource = function (e) {\n      return fc(e);\n    });\n    As.exports = un.inspectSource;\n  });\n  var bs = we((A0, xs) => {\n    var Dc = Ye(),\n      mc = ot(),\n      dc = hr(),\n      Ss = Dc.WeakMap;\n    xs.exports = mc(Ss) && /native code/.test(dc(Ss));\n  });\n  var Ns = we((S0, Bs) => {\n    var gc = Xr(),\n      yc = Kr(),\n      Ts = gc(\"keys\");\n    Bs.exports = function (e) {\n      return Ts[e] || (Ts[e] = yc(e));\n    };\n  });\n  var sn = we((x0, ws) => {\n    ws.exports = {};\n  });\n  var js = we((b0, Ls) => {\n    var hc = bs(),\n      Is = Ye(),\n      an = at(),\n      vc = Ft(),\n      Cc = yr(),\n      on = gt(),\n      ln = fr(),\n      Ec = Ns(),\n      Fc = sn(),\n      _s = \"Object already initialized\",\n      pn = Is.TypeError,\n      Ac = Is.WeakMap,\n      vr,\n      Wt,\n      Cr,\n      Sc = function (e) {\n        return Cr(e) ? Wt(e) : vr(e, {});\n      },\n      xc = function (e) {\n        return function (n) {\n          var t;\n          if (!vc(n) || (t = Wt(n)).type !== e) throw pn(\"Incompatible receiver, \" + e + \" required\");\n          return t;\n        };\n      };\n    hc || ln.state ? (yt = ln.state || (ln.state = new Ac()), Ps = an(yt.get), cn = an(yt.has), ks = an(yt.set), vr = function (e, n) {\n      if (cn(yt, e)) throw new pn(_s);\n      return n.facade = e, ks(yt, e, n), n;\n    }, Wt = function (e) {\n      return Ps(yt, e) || {};\n    }, Cr = function (e) {\n      return cn(yt, e);\n    }) : (xt = Ec(\"state\"), Fc[xt] = !0, vr = function (e, n) {\n      if (on(e, xt)) throw new pn(_s);\n      return n.facade = e, Cc(e, xt, n), n;\n    }, Wt = function (e) {\n      return on(e, xt) ? e[xt] : {};\n    }, Cr = function (e) {\n      return on(e, xt);\n    });\n    var yt, Ps, cn, ks, xt;\n    Ls.exports = {\n      set: vr,\n      get: Wt,\n      has: Cr,\n      enforce: Sc,\n      getterFor: xc\n    };\n  });\n  var Ms = we((T0, qs) => {\n    var fn = Ct(),\n      bc = gt(),\n      Os = Function.prototype,\n      Tc = fn && Object.getOwnPropertyDescriptor,\n      Dn = bc(Os, \"name\"),\n      Bc = Dn && function () {}.name === \"something\",\n      Nc = Dn && (!fn || fn && Tc(Os, \"name\").configurable);\n    qs.exports = {\n      EXISTS: Dn,\n      PROPER: Bc,\n      CONFIGURABLE: Nc\n    };\n  });\n  var Hs = we((B0, $s) => {\n    var wc = Ye(),\n      Rs = ot(),\n      _c = gt(),\n      Vs = yr(),\n      Pc = pr(),\n      kc = hr(),\n      Ws = js(),\n      Ic = Ms().CONFIGURABLE,\n      Lc = Ws.get,\n      jc = Ws.enforce,\n      Oc = String(String).split(\"String\");\n    ($s.exports = function (e, n, t, s) {\n      var a = s ? !!s.unsafe : !1,\n        r = s ? !!s.enumerable : !1,\n        u = s ? !!s.noTargetGet : !1,\n        i = s && s.name !== void 0 ? s.name : n,\n        o;\n      if (Rs(t) && (String(i).slice(0, 7) === \"Symbol(\" && (i = \"[\" + String(i).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\"), (!_c(t, \"name\") || Ic && t.name !== i) && Vs(t, \"name\", i), o = jc(t), o.source || (o.source = Oc.join(typeof i == \"string\" ? i : \"\"))), e === wc) {\n        r ? e[n] = t : Pc(n, t);\n        return;\n      } else a ? !u && e[n] && (r = !0) : delete e[n];\n      r ? e[n] = t : Vs(e, n, t);\n    })(Function.prototype, \"toString\", function () {\n      return Rs(this) && Lc(this).source || kc(this);\n    });\n  });\n  var Er = we((N0, Gs) => {\n    var qc = Math.ceil,\n      Mc = Math.floor;\n    Gs.exports = function (e) {\n      var n = +e;\n      return n !== n || n === 0 ? 0 : (n > 0 ? Mc : qc)(n);\n    };\n  });\n  var Us = we((w0, Js) => {\n    var Rc = Er(),\n      Vc = Math.max,\n      Wc = Math.min;\n    Js.exports = function (e, n) {\n      var t = Rc(e);\n      return t < 0 ? Vc(t + n, 0) : Wc(t, n);\n    };\n  });\n  var Xs = we((_0, zs) => {\n    var $c = Er(),\n      Hc = Math.min;\n    zs.exports = function (e) {\n      return e > 0 ? Hc($c(e), 9007199254740991) : 0;\n    };\n  });\n  var _t = we((P0, Ks) => {\n    var Gc = Xs();\n    Ks.exports = function (e) {\n      return Gc(e.length);\n    };\n  });\n  var Zs = we((k0, Qs) => {\n    var Jc = ar(),\n      Uc = Us(),\n      zc = _t(),\n      Ys = function (e) {\n        return function (n, t, s) {\n          var a = Jc(n),\n            r = zc(a),\n            u = Uc(s, r),\n            i;\n          if (e && t != t) {\n            for (; r > u;) if (i = a[u++], i != i) return !0;\n          } else for (; r > u; u++) if ((e || u in a) && a[u] === t) return e || u || 0;\n          return !e && -1;\n        };\n      };\n    Qs.exports = {\n      includes: Ys(!0),\n      indexOf: Ys(!1)\n    };\n  });\n  var ri = we((I0, ti) => {\n    var Xc = at(),\n      mn = gt(),\n      Kc = ar(),\n      Yc = Zs().indexOf,\n      Qc = sn(),\n      ei = Xc([].push);\n    ti.exports = function (e, n) {\n      var t = Kc(e),\n        s = 0,\n        a = [],\n        r;\n      for (r in t) !mn(Qc, r) && mn(t, r) && ei(a, r);\n      for (; n.length > s;) mn(t, r = n[s++]) && (~Yc(a, r) || ei(a, r));\n      return a;\n    };\n  });\n  var ui = we((L0, ni) => {\n    ni.exports = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"];\n  });\n  var ii = we(si => {\n    var Zc = ri(),\n      ep = ui(),\n      tp = ep.concat(\"length\", \"prototype\");\n    si.f = Object.getOwnPropertyNames || function (n) {\n      return Zc(n, tp);\n    };\n  });\n  var oi = we(ai => {\n    ai.f = Object.getOwnPropertySymbols;\n  });\n  var ci = we((q0, li) => {\n    var rp = Rt(),\n      np = at(),\n      up = ii(),\n      sp = oi(),\n      ip = wt(),\n      ap = np([].concat);\n    li.exports = rp(\"Reflect\", \"ownKeys\") || function (n) {\n      var t = up.f(ip(n)),\n        s = sp.f;\n      return s ? ap(t, s(n)) : t;\n    };\n  });\n  var Di = we((M0, fi) => {\n    var pi = gt(),\n      op = ci(),\n      lp = Zr(),\n      cp = gr();\n    fi.exports = function (e, n, t) {\n      for (var s = op(n), a = cp.f, r = lp.f, u = 0; u < s.length; u++) {\n        var i = s[u];\n        !pi(e, i) && !(t && pi(t, i)) && a(e, i, r(n, i));\n      }\n    };\n  });\n  var di = we((R0, mi) => {\n    var pp = Dt(),\n      fp = ot(),\n      Dp = /#|\\.prototype\\./,\n      $t = function (e, n) {\n        var t = dp[mp(e)];\n        return t == yp ? !0 : t == gp ? !1 : fp(n) ? pp(n) : !!n;\n      },\n      mp = $t.normalize = function (e) {\n        return String(e).replace(Dp, \".\").toLowerCase();\n      },\n      dp = $t.data = {},\n      gp = $t.NATIVE = \"N\",\n      yp = $t.POLYFILL = \"P\";\n    mi.exports = $t;\n  });\n  var Ht = we((V0, gi) => {\n    var dn = Ye(),\n      hp = Zr().f,\n      vp = yr(),\n      Cp = Hs(),\n      Ep = pr(),\n      Fp = Di(),\n      Ap = di();\n    gi.exports = function (e, n) {\n      var t = e.target,\n        s = e.global,\n        a = e.stat,\n        r,\n        u,\n        i,\n        o,\n        c,\n        v;\n      if (s ? u = dn : a ? u = dn[t] || Ep(t, {}) : u = (dn[t] || {}).prototype, u) for (i in n) {\n        if (c = n[i], e.noTargetGet ? (v = hp(u, i), o = v && v.value) : o = u[i], r = Ap(s ? i : t + (a ? \".\" : \"#\") + i, e.forced), !r && o !== void 0) {\n          if (typeof c == typeof o) continue;\n          Fp(c, o);\n        }\n        (e.sham || o && o.sham) && vp(c, \"sham\", !0), Cp(u, i, c, e);\n      }\n    };\n  });\n  var gn = we((W0, yi) => {\n    var Sp = ir();\n    yi.exports = Array.isArray || function (n) {\n      return Sp(n) == \"Array\";\n    };\n  });\n  var yn = we(($0, vi) => {\n    var hi = at(),\n      xp = Vt(),\n      bp = nr(),\n      Tp = hi(hi.bind);\n    vi.exports = function (e, n) {\n      return xp(e), n === void 0 ? e : bp ? Tp(e, n) : function () {\n        return e.apply(n, arguments);\n      };\n    };\n  });\n  var hn = we((H0, Ei) => {\n    \"use strict\";\n\n    var Bp = Ye(),\n      Np = gn(),\n      wp = _t(),\n      _p = yn(),\n      Pp = Bp.TypeError,\n      Ci = function (e, n, t, s, a, r, u, i) {\n        for (var o = a, c = 0, v = u ? _p(u, i) : !1, m, d; c < s;) {\n          if (c in t) {\n            if (m = v ? v(t[c], c, n) : t[c], r > 0 && Np(m)) d = wp(m), o = Ci(e, n, m, d, o, r - 1) - 1;else {\n              if (o >= 9007199254740991) throw Pp(\"Exceed the acceptable array length\");\n              e[o] = m;\n            }\n            o++;\n          }\n          c++;\n        }\n        return o;\n      };\n    Ei.exports = Ci;\n  });\n  var Si = we((G0, Ai) => {\n    var kp = St(),\n      Ip = kp(\"toStringTag\"),\n      Fi = {};\n    Fi[Ip] = \"z\";\n    Ai.exports = String(Fi) === \"[object z]\";\n  });\n  var vn = we((J0, xi) => {\n    var Lp = Ye(),\n      jp = Si(),\n      Op = ot(),\n      Fr = ir(),\n      qp = St(),\n      Mp = qp(\"toStringTag\"),\n      Rp = Lp.Object,\n      Vp = Fr(function () {\n        return arguments;\n      }()) == \"Arguments\",\n      Wp = function (e, n) {\n        try {\n          return e[n];\n        } catch {}\n      };\n    xi.exports = jp ? Fr : function (e) {\n      var n, t, s;\n      return e === void 0 ? \"Undefined\" : e === null ? \"Null\" : typeof (t = Wp(n = Rp(e), Mp)) == \"string\" ? t : Vp ? Fr(n) : (s = Fr(n)) == \"Object\" && Op(n.callee) ? \"Arguments\" : s;\n    };\n  });\n  var _i = we((U0, wi) => {\n    var $p = at(),\n      Hp = Dt(),\n      bi = ot(),\n      Gp = vn(),\n      Jp = Rt(),\n      Up = hr(),\n      Ti = function () {},\n      zp = [],\n      Bi = Jp(\"Reflect\", \"construct\"),\n      Cn = /^\\s*(?:class|function)\\b/,\n      Xp = $p(Cn.exec),\n      Kp = !Cn.exec(Ti),\n      Gt = function (n) {\n        if (!bi(n)) return !1;\n        try {\n          return Bi(Ti, zp, n), !0;\n        } catch {\n          return !1;\n        }\n      },\n      Ni = function (n) {\n        if (!bi(n)) return !1;\n        switch (Gp(n)) {\n          case \"AsyncFunction\":\n          case \"GeneratorFunction\":\n          case \"AsyncGeneratorFunction\":\n            return !1;\n        }\n        try {\n          return Kp || !!Xp(Cn, Up(n));\n        } catch {\n          return !0;\n        }\n      };\n    Ni.sham = !0;\n    wi.exports = !Bi || Hp(function () {\n      var e;\n      return Gt(Gt.call) || !Gt(Object) || !Gt(function () {\n        e = !0;\n      }) || e;\n    }) ? Ni : Gt;\n  });\n  var Li = we((z0, Ii) => {\n    var Yp = Ye(),\n      Pi = gn(),\n      Qp = _i(),\n      Zp = Ft(),\n      ef = St(),\n      tf = ef(\"species\"),\n      ki = Yp.Array;\n    Ii.exports = function (e) {\n      var n;\n      return Pi(e) && (n = e.constructor, Qp(n) && (n === ki || Pi(n.prototype)) ? n = void 0 : Zp(n) && (n = n[tf], n === null && (n = void 0))), n === void 0 ? ki : n;\n    };\n  });\n  var En = we((X0, ji) => {\n    var rf = Li();\n    ji.exports = function (e, n) {\n      return new (rf(e))(n === 0 ? 0 : n);\n    };\n  });\n  var Oi = we(() => {\n    \"use strict\";\n\n    var nf = Ht(),\n      uf = hn(),\n      sf = Vt(),\n      af = Dr(),\n      of = _t(),\n      lf = En();\n    nf({\n      target: \"Array\",\n      proto: !0\n    }, {\n      flatMap: function (n) {\n        var t = af(this),\n          s = of(t),\n          a;\n        return sf(n), a = lf(t, 0), a.length = uf(a, t, t, s, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), a;\n      }\n    });\n  });\n  var Fn = we((Q0, qi) => {\n    qi.exports = {};\n  });\n  var Ri = we((Z0, Mi) => {\n    var cf = St(),\n      pf = Fn(),\n      ff = cf(\"iterator\"),\n      Df = Array.prototype;\n    Mi.exports = function (e) {\n      return e !== void 0 && (pf.Array === e || Df[ff] === e);\n    };\n  });\n  var An = we((ey, Wi) => {\n    var mf = vn(),\n      Vi = cr(),\n      df = Fn(),\n      gf = St(),\n      yf = gf(\"iterator\");\n    Wi.exports = function (e) {\n      if (e != null) return Vi(e, yf) || Vi(e, \"@@iterator\") || df[mf(e)];\n    };\n  });\n  var Hi = we((ty, $i) => {\n    var hf = Ye(),\n      vf = Et(),\n      Cf = Vt(),\n      Ef = wt(),\n      Ff = lr(),\n      Af = An(),\n      Sf = hf.TypeError;\n    $i.exports = function (e, n) {\n      var t = arguments.length < 2 ? Af(e) : n;\n      if (Cf(t)) return Ef(vf(t, e));\n      throw Sf(Ff(e) + \" is not iterable\");\n    };\n  });\n  var Ui = we((ry, Ji) => {\n    var xf = Et(),\n      Gi = wt(),\n      bf = cr();\n    Ji.exports = function (e, n, t) {\n      var s, a;\n      Gi(e);\n      try {\n        if (s = bf(e, \"return\"), !s) {\n          if (n === \"throw\") throw t;\n          return t;\n        }\n        s = xf(s, e);\n      } catch (r) {\n        a = !0, s = r;\n      }\n      if (n === \"throw\") throw t;\n      if (a) throw s;\n      return Gi(s), t;\n    };\n  });\n  var Qi = we((ny, Yi) => {\n    var Tf = Ye(),\n      Bf = yn(),\n      Nf = Et(),\n      wf = wt(),\n      _f = lr(),\n      Pf = Ri(),\n      kf = _t(),\n      zi = Vr(),\n      If = Hi(),\n      Lf = An(),\n      Xi = Ui(),\n      jf = Tf.TypeError,\n      Ar = function (e, n) {\n        this.stopped = e, this.result = n;\n      },\n      Ki = Ar.prototype;\n    Yi.exports = function (e, n, t) {\n      var s = t && t.that,\n        a = !!(t && t.AS_ENTRIES),\n        r = !!(t && t.IS_ITERATOR),\n        u = !!(t && t.INTERRUPTED),\n        i = Bf(n, s),\n        o,\n        c,\n        v,\n        m,\n        d,\n        p,\n        f,\n        h = function (T) {\n          return o && Xi(o, \"normal\", T), new Ar(!0, T);\n        },\n        w = function (T) {\n          return a ? (wf(T), u ? i(T[0], T[1], h) : i(T[0], T[1])) : u ? i(T, h) : i(T);\n        };\n      if (r) o = e;else {\n        if (c = Lf(e), !c) throw jf(_f(e) + \" is not iterable\");\n        if (Pf(c)) {\n          for (v = 0, m = kf(e); m > v; v++) if (d = w(e[v]), d && zi(Ki, d)) return d;\n          return new Ar(!1);\n        }\n        o = If(e, c);\n      }\n      for (p = o.next; !(f = Nf(p, o)).done;) {\n        try {\n          d = w(f.value);\n        } catch (T) {\n          Xi(o, \"throw\", T);\n        }\n        if (typeof d == \"object\" && d && zi(Ki, d)) return d;\n      }\n      return new Ar(!1);\n    };\n  });\n  var ea = we((uy, Zi) => {\n    \"use strict\";\n\n    var Of = mr(),\n      qf = gr(),\n      Mf = sr();\n    Zi.exports = function (e, n, t) {\n      var s = Of(n);\n      s in e ? qf.f(e, s, Mf(0, t)) : e[s] = t;\n    };\n  });\n  var ta = we(() => {\n    var Rf = Ht(),\n      Vf = Qi(),\n      Wf = ea();\n    Rf({\n      target: \"Object\",\n      stat: !0\n    }, {\n      fromEntries: function (n) {\n        var t = {};\n        return Vf(n, function (s, a) {\n          Wf(t, s, a);\n        }, {\n          AS_ENTRIES: !0\n        }), t;\n      }\n    });\n  });\n  var ra = we(() => {\n    var $f = Ht(),\n      Hf = Ye();\n    $f({\n      global: !0\n    }, {\n      globalThis: Hf\n    });\n  });\n  var na = we(() => {\n    ra();\n  });\n  var ua = we(() => {\n    \"use strict\";\n\n    var Gf = Ht(),\n      Jf = hn(),\n      Uf = Dr(),\n      zf = _t(),\n      Xf = Er(),\n      Kf = En();\n    Gf({\n      target: \"Array\",\n      proto: !0\n    }, {\n      flat: function () {\n        var n = arguments.length ? arguments[0] : void 0,\n          t = Uf(this),\n          s = zf(t),\n          a = Kf(t, 0);\n        return a.length = Jf(a, t, t, s, 0, n === void 0 ? 1 : Xf(n)), a;\n      }\n    });\n  });\n  var Pg = we((my, Co) => {\n    var Yf = [\"cliName\", \"cliCategory\", \"cliDescription\"],\n      Qf = [\"_\"],\n      Zf = [\"languageId\"],\n      sa,\n      ia,\n      aa,\n      oa,\n      la,\n      ca;\n    function kn(e, n) {\n      if (e == null) return {};\n      var t = eD(e, n),\n        s,\n        a;\n      if (Object.getOwnPropertySymbols) {\n        var r = Object.getOwnPropertySymbols(e);\n        for (a = 0; a < r.length; a++) s = r[a], !(n.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));\n      }\n      return t;\n    }\n    function eD(e, n) {\n      if (e == null) return {};\n      var t = {},\n        s = Object.keys(e),\n        a,\n        r;\n      for (r = 0; r < s.length; r++) a = s[r], !(n.indexOf(a) >= 0) && (t[a] = e[a]);\n      return t;\n    }\n    Oi();\n    ta();\n    na();\n    ua();\n    function Pt(e, n) {\n      return n || (n = e.slice(0)), Object.freeze(Object.defineProperties(e, {\n        raw: {\n          value: Object.freeze(n)\n        }\n      }));\n    }\n    var tD = Object.create,\n      Br = Object.defineProperty,\n      rD = Object.getOwnPropertyDescriptor,\n      In = Object.getOwnPropertyNames,\n      nD = Object.getPrototypeOf,\n      uD = Object.prototype.hasOwnProperty,\n      mt = (e, n) => function () {\n        return e && (n = (0, e[In(e)[0]])(e = 0)), n;\n      },\n      Z = (e, n) => function () {\n        return n || (0, e[In(e)[0]])((n = {\n          exports: {}\n        }).exports, n), n.exports;\n      },\n      Ut = (e, n) => {\n        for (var t in n) Br(e, t, {\n          get: n[t],\n          enumerable: !0\n        });\n      },\n      ga = (e, n, t, s) => {\n        if (n && typeof n == \"object\" || typeof n == \"function\") for (let a of In(n)) !uD.call(e, a) && a !== t && Br(e, a, {\n          get: () => n[a],\n          enumerable: !(s = rD(n, a)) || s.enumerable\n        });\n        return e;\n      },\n      sD = (e, n, t) => (t = e != null ? tD(nD(e)) : {}, ga(n || !e || !e.__esModule ? Br(t, \"default\", {\n        value: e,\n        enumerable: !0\n      }) : t, e)),\n      lt = e => ga(Br({}, \"__esModule\", {\n        value: !0\n      }), e),\n      pa,\n      fa,\n      Tt,\n      re = mt({\n        \"<define:process>\"() {\n          pa = {}, fa = [], Tt = {\n            env: pa,\n            argv: fa\n          };\n        }\n      }),\n      ya = Z({\n        \"package.json\"(e, n) {\n          n.exports = {\n            version: \"2.7.1\"\n          };\n        }\n      }),\n      iD = Z({\n        \"node_modules/diff/lib/diff/base.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.default = n;\n          function n() {}\n          n.prototype = {\n            diff: function (r, u) {\n              var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n                o = i.callback;\n              typeof i == \"function\" && (o = i, i = {}), this.options = i;\n              var c = this;\n              function v(S) {\n                return o ? (setTimeout(function () {\n                  o(void 0, S);\n                }, 0), !0) : S;\n              }\n              r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));\n              var m = u.length,\n                d = r.length,\n                p = 1,\n                f = m + d,\n                h = [{\n                  newPos: -1,\n                  components: []\n                }],\n                w = this.extractCommon(h[0], u, r, 0);\n              if (h[0].newPos + 1 >= m && w + 1 >= d) return v([{\n                value: this.join(u),\n                count: u.length\n              }]);\n              function T() {\n                for (var S = -1 * p; S <= p; S += 2) {\n                  var B = void 0,\n                    I = h[S - 1],\n                    k = h[S + 1],\n                    P = (k ? k.newPos : 0) - S;\n                  I && (h[S - 1] = void 0);\n                  var C = I && I.newPos + 1 < m,\n                    D = k && 0 <= P && P < d;\n                  if (!C && !D) {\n                    h[S] = void 0;\n                    continue;\n                  }\n                  if (!C || D && I.newPos < k.newPos ? (B = s(k), c.pushComponent(B.components, void 0, !0)) : (B = I, B.newPos++, c.pushComponent(B.components, !0, void 0)), P = c.extractCommon(B, u, r, S), B.newPos + 1 >= m && P + 1 >= d) return v(t(c, B.components, u, r, c.useLongestToken));\n                  h[S] = B;\n                }\n                p++;\n              }\n              if (o) (function S() {\n                setTimeout(function () {\n                  if (p > f) return o();\n                  T() || S();\n                }, 0);\n              })();else for (; p <= f;) {\n                var A = T();\n                if (A) return A;\n              }\n            },\n            pushComponent: function (r, u, i) {\n              var o = r[r.length - 1];\n              o && o.added === u && o.removed === i ? r[r.length - 1] = {\n                count: o.count + 1,\n                added: u,\n                removed: i\n              } : r.push({\n                count: 1,\n                added: u,\n                removed: i\n              });\n            },\n            extractCommon: function (r, u, i, o) {\n              for (var c = u.length, v = i.length, m = r.newPos, d = m - o, p = 0; m + 1 < c && d + 1 < v && this.equals(u[m + 1], i[d + 1]);) m++, d++, p++;\n              return p && r.components.push({\n                count: p\n              }), r.newPos = m, d;\n            },\n            equals: function (r, u) {\n              return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();\n            },\n            removeEmpty: function (r) {\n              for (var u = [], i = 0; i < r.length; i++) r[i] && u.push(r[i]);\n              return u;\n            },\n            castInput: function (r) {\n              return r;\n            },\n            tokenize: function (r) {\n              return r.split(\"\");\n            },\n            join: function (r) {\n              return r.join(\"\");\n            }\n          };\n          function t(a, r, u, i, o) {\n            for (var c = 0, v = r.length, m = 0, d = 0; c < v; c++) {\n              var p = r[c];\n              if (p.removed) {\n                if (p.value = a.join(i.slice(d, d + p.count)), d += p.count, c && r[c - 1].added) {\n                  var h = r[c - 1];\n                  r[c - 1] = r[c], r[c] = h;\n                }\n              } else {\n                if (!p.added && o) {\n                  var f = u.slice(m, m + p.count);\n                  f = f.map(function (T, A) {\n                    var S = i[d + A];\n                    return S.length > T.length ? S : T;\n                  }), p.value = a.join(f);\n                } else p.value = a.join(u.slice(m, m + p.count));\n                m += p.count, p.added || (d += p.count);\n              }\n            }\n            var w = r[v - 1];\n            return v > 1 && typeof w.value == \"string\" && (w.added || w.removed) && a.equals(\"\", w.value) && (r[v - 2].value += w.value, r.pop()), r;\n          }\n          function s(a) {\n            return {\n              newPos: a.newPos,\n              components: a.components.slice(0)\n            };\n          }\n        }\n      }),\n      aD = Z({\n        \"node_modules/diff/lib/diff/array.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.diffArrays = a, e.arrayDiff = void 0;\n          var n = t(iD());\n          function t(r) {\n            return r && r.__esModule ? r : {\n              default: r\n            };\n          }\n          var s = new n.default();\n          e.arrayDiff = s, s.tokenize = function (r) {\n            return r.slice();\n          }, s.join = s.removeEmpty = function (r) {\n            return r;\n          };\n          function a(r, u, i) {\n            return s.diff(r, u, i);\n          }\n        }\n      }),\n      Ln = Z({\n        \"src/document/doc-builders.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(F) {\n            return {\n              type: \"concat\",\n              parts: F\n            };\n          }\n          function s(F) {\n            return {\n              type: \"indent\",\n              contents: F\n            };\n          }\n          function a(F, l) {\n            return {\n              type: \"align\",\n              contents: l,\n              n: F\n            };\n          }\n          function r(F) {\n            let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            return {\n              type: \"group\",\n              id: l.id,\n              contents: F,\n              break: Boolean(l.shouldBreak),\n              expandedStates: l.expandedStates\n            };\n          }\n          function u(F) {\n            return a(Number.NEGATIVE_INFINITY, F);\n          }\n          function i(F) {\n            return a({\n              type: \"root\"\n            }, F);\n          }\n          function o(F) {\n            return a(-1, F);\n          }\n          function c(F, l) {\n            return r(F[0], Object.assign(Object.assign({}, l), {}, {\n              expandedStates: F\n            }));\n          }\n          function v(F) {\n            return {\n              type: \"fill\",\n              parts: F\n            };\n          }\n          function m(F, l) {\n            let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            return {\n              type: \"if-break\",\n              breakContents: F,\n              flatContents: l,\n              groupId: E.groupId\n            };\n          }\n          function d(F, l) {\n            return {\n              type: \"indent-if-break\",\n              contents: F,\n              groupId: l.groupId,\n              negate: l.negate\n            };\n          }\n          function p(F) {\n            return {\n              type: \"line-suffix\",\n              contents: F\n            };\n          }\n          var f = {\n              type: \"line-suffix-boundary\"\n            },\n            h = {\n              type: \"break-parent\"\n            },\n            w = {\n              type: \"trim\"\n            },\n            T = {\n              type: \"line\",\n              hard: !0\n            },\n            A = {\n              type: \"line\",\n              hard: !0,\n              literal: !0\n            },\n            S = {\n              type: \"line\"\n            },\n            B = {\n              type: \"line\",\n              soft: !0\n            },\n            I = t([T, h]),\n            k = t([A, h]),\n            P = {\n              type: \"cursor\",\n              placeholder: Symbol(\"cursor\")\n            };\n          function C(F, l) {\n            let E = [];\n            for (let y = 0; y < l.length; y++) y !== 0 && E.push(F), E.push(l[y]);\n            return t(E);\n          }\n          function D(F, l, E) {\n            let y = F;\n            if (l > 0) {\n              for (let N = 0; N < Math.floor(l / E); ++N) y = s(y);\n              y = a(l % E, y), y = a(Number.NEGATIVE_INFINITY, y);\n            }\n            return y;\n          }\n          function g(F, l) {\n            return {\n              type: \"label\",\n              label: F,\n              contents: l\n            };\n          }\n          n.exports = {\n            concat: t,\n            join: C,\n            line: S,\n            softline: B,\n            hardline: I,\n            literalline: k,\n            group: r,\n            conditionalGroup: c,\n            fill: v,\n            lineSuffix: p,\n            lineSuffixBoundary: f,\n            cursor: P,\n            breakParent: h,\n            ifBreak: m,\n            trim: w,\n            indent: s,\n            indentIfBreak: d,\n            align: a,\n            addAlignmentToDoc: D,\n            markAsRoot: i,\n            dedentToRoot: u,\n            dedent: o,\n            hardlineWithoutBreakParent: T,\n            literallineWithoutBreakParent: A,\n            label: g\n          };\n        }\n      }),\n      jn = Z({\n        \"src/common/end-of-line.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(u) {\n            let i = u.indexOf(\"\\r\");\n            return i >= 0 ? u.charAt(i + 1) === `\n` ? \"crlf\" : \"cr\" : \"lf\";\n          }\n          function s(u) {\n            switch (u) {\n              case \"cr\":\n                return \"\\r\";\n              case \"crlf\":\n                return `\\r\n`;\n              default:\n                return `\n`;\n            }\n          }\n          function a(u, i) {\n            let o;\n            switch (i) {\n              case `\n`:\n                o = /\\n/g;\n                break;\n              case \"\\r\":\n                o = /\\r/g;\n                break;\n              case `\\r\n`:\n                o = /\\r\\n/g;\n                break;\n              default:\n                throw new Error('Unexpected \"eol\" '.concat(JSON.stringify(i), \".\"));\n            }\n            let c = u.match(o);\n            return c ? c.length : 0;\n          }\n          function r(u) {\n            return u.replace(/\\r\\n?/g, `\n`);\n          }\n          n.exports = {\n            guessEndOfLine: t,\n            convertEndOfLineToChars: s,\n            countEndOfLineChars: a,\n            normalizeEndOfLine: r\n          };\n        }\n      }),\n      it = Z({\n        \"src/utils/get-last.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = s => s[s.length - 1];\n          n.exports = t;\n        }\n      });\n    function oD() {\n      let {\n          onlyFirst: e = !1\n        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n        n = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n      return new RegExp(n, e ? void 0 : \"g\");\n    }\n    var lD = mt({\n      \"node_modules/strip-ansi/node_modules/ansi-regex/index.js\"() {\n        re();\n      }\n    });\n    function cD(e) {\n      if (typeof e != \"string\") throw new TypeError(\"Expected a `string`, got `\".concat(typeof e, \"`\"));\n      return e.replace(oD(), \"\");\n    }\n    var pD = mt({\n      \"node_modules/strip-ansi/index.js\"() {\n        re(), lD();\n      }\n    });\n    function fD(e) {\n      return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : !1;\n    }\n    var DD = mt({\n        \"node_modules/is-fullwidth-code-point/index.js\"() {\n          re();\n        }\n      }),\n      mD = Z({\n        \"node_modules/emoji-regex/index.js\"(e, n) {\n          \"use strict\";\n\n          re(), n.exports = function () {\n            return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n          };\n        }\n      }),\n      ha = {};\n    Ut(ha, {\n      default: () => dD\n    });\n    function dD(e) {\n      if (typeof e != \"string\" || e.length === 0 || (e = cD(e), e.length === 0)) return 0;\n      e = e.replace((0, va.default)(), \"  \");\n      let n = 0;\n      for (let t = 0; t < e.length; t++) {\n        let s = e.codePointAt(t);\n        s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, n += fD(s) ? 2 : 1);\n      }\n      return n;\n    }\n    var va,\n      gD = mt({\n        \"node_modules/string-width/index.js\"() {\n          re(), pD(), DD(), va = sD(mD());\n        }\n      }),\n      Ca = Z({\n        \"src/utils/get-string-width.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = (gD(), lt(ha)).default,\n            s = /[^\\x20-\\x7F]/;\n          function a(r) {\n            return r ? s.test(r) ? t(r) : r.length : 0;\n          }\n          n.exports = a;\n        }\n      }),\n      On = Z({\n        \"src/document/doc-utils.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = it(),\n            {\n              literalline: s,\n              join: a\n            } = Ln(),\n            r = l => Array.isArray(l) || l && l.type === \"concat\",\n            u = l => {\n              if (Array.isArray(l)) return l;\n              if (l.type !== \"concat\" && l.type !== \"fill\") throw new Error(\"Expect doc type to be `concat` or `fill`.\");\n              return l.parts;\n            },\n            i = {};\n          function o(l, E, y, N) {\n            let x = [l];\n            for (; x.length > 0;) {\n              let b = x.pop();\n              if (b === i) {\n                y(x.pop());\n                continue;\n              }\n              if (y && x.push(b, i), !E || E(b) !== !1) if (r(b) || b.type === \"fill\") {\n                let L = u(b);\n                for (let M = L.length, j = M - 1; j >= 0; --j) x.push(L[j]);\n              } else if (b.type === \"if-break\") b.flatContents && x.push(b.flatContents), b.breakContents && x.push(b.breakContents);else if (b.type === \"group\" && b.expandedStates) {\n                if (N) for (let L = b.expandedStates.length, M = L - 1; M >= 0; --M) x.push(b.expandedStates[M]);else x.push(b.contents);\n              } else b.contents && x.push(b.contents);\n            }\n          }\n          function c(l, E) {\n            let y = new Map();\n            return N(l);\n            function N(b) {\n              if (y.has(b)) return y.get(b);\n              let L = x(b);\n              return y.set(b, L), L;\n            }\n            function x(b) {\n              if (Array.isArray(b)) return E(b.map(N));\n              if (b.type === \"concat\" || b.type === \"fill\") {\n                let L = b.parts.map(N);\n                return E(Object.assign(Object.assign({}, b), {}, {\n                  parts: L\n                }));\n              }\n              if (b.type === \"if-break\") {\n                let L = b.breakContents && N(b.breakContents),\n                  M = b.flatContents && N(b.flatContents);\n                return E(Object.assign(Object.assign({}, b), {}, {\n                  breakContents: L,\n                  flatContents: M\n                }));\n              }\n              if (b.type === \"group\" && b.expandedStates) {\n                let L = b.expandedStates.map(N),\n                  M = L[0];\n                return E(Object.assign(Object.assign({}, b), {}, {\n                  contents: M,\n                  expandedStates: L\n                }));\n              }\n              if (b.contents) {\n                let L = N(b.contents);\n                return E(Object.assign(Object.assign({}, b), {}, {\n                  contents: L\n                }));\n              }\n              return E(b);\n            }\n          }\n          function v(l, E, y) {\n            let N = y,\n              x = !1;\n            function b(L) {\n              let M = E(L);\n              if (M !== void 0 && (x = !0, N = M), x) return !1;\n            }\n            return o(l, b), N;\n          }\n          function m(l) {\n            if (l.type === \"group\" && l.break || l.type === \"line\" && l.hard || l.type === \"break-parent\") return !0;\n          }\n          function d(l) {\n            return v(l, m, !1);\n          }\n          function p(l) {\n            if (l.length > 0) {\n              let E = t(l);\n              !E.expandedStates && !E.break && (E.break = \"propagated\");\n            }\n            return null;\n          }\n          function f(l) {\n            let E = new Set(),\n              y = [];\n            function N(b) {\n              if (b.type === \"break-parent\" && p(y), b.type === \"group\") {\n                if (y.push(b), E.has(b)) return !1;\n                E.add(b);\n              }\n            }\n            function x(b) {\n              b.type === \"group\" && y.pop().break && p(y);\n            }\n            o(l, N, x, !0);\n          }\n          function h(l) {\n            return l.type === \"line\" && !l.hard ? l.soft ? \"\" : \" \" : l.type === \"if-break\" ? l.flatContents || \"\" : l;\n          }\n          function w(l) {\n            return c(l, h);\n          }\n          var T = (l, E) => l && l.type === \"line\" && l.hard && E && E.type === \"break-parent\";\n          function A(l) {\n            if (!l) return l;\n            if (r(l) || l.type === \"fill\") {\n              let E = u(l);\n              for (; E.length > 1 && T(...E.slice(-2));) E.length -= 2;\n              if (E.length > 0) {\n                let y = A(t(E));\n                E[E.length - 1] = y;\n              }\n              return Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, {\n                parts: E\n              });\n            }\n            switch (l.type) {\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"group\":\n              case \"line-suffix\":\n              case \"label\":\n                {\n                  let E = A(l.contents);\n                  return Object.assign(Object.assign({}, l), {}, {\n                    contents: E\n                  });\n                }\n              case \"if-break\":\n                {\n                  let E = A(l.breakContents),\n                    y = A(l.flatContents);\n                  return Object.assign(Object.assign({}, l), {}, {\n                    breakContents: E,\n                    flatContents: y\n                  });\n                }\n            }\n            return l;\n          }\n          function S(l) {\n            return A(I(l));\n          }\n          function B(l) {\n            switch (l.type) {\n              case \"fill\":\n                if (l.parts.every(y => y === \"\")) return \"\";\n                break;\n              case \"group\":\n                if (!l.contents && !l.id && !l.break && !l.expandedStates) return \"\";\n                if (l.contents.type === \"group\" && l.contents.id === l.id && l.contents.break === l.break && l.contents.expandedStates === l.expandedStates) return l.contents;\n                break;\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"line-suffix\":\n                if (!l.contents) return \"\";\n                break;\n              case \"if-break\":\n                if (!l.flatContents && !l.breakContents) return \"\";\n                break;\n            }\n            if (!r(l)) return l;\n            let E = [];\n            for (let y of u(l)) {\n              if (!y) continue;\n              let [N, ...x] = r(y) ? u(y) : [y];\n              typeof N == \"string\" && typeof t(E) == \"string\" ? E[E.length - 1] += N : E.push(N), E.push(...x);\n            }\n            return E.length === 0 ? \"\" : E.length === 1 ? E[0] : Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, {\n              parts: E\n            });\n          }\n          function I(l) {\n            return c(l, E => B(E));\n          }\n          function k(l) {\n            let E = [],\n              y = l.filter(Boolean);\n            for (; y.length > 0;) {\n              let N = y.shift();\n              if (!!N) {\n                if (r(N)) {\n                  y.unshift(...u(N));\n                  continue;\n                }\n                if (E.length > 0 && typeof t(E) == \"string\" && typeof N == \"string\") {\n                  E[E.length - 1] += N;\n                  continue;\n                }\n                E.push(N);\n              }\n            }\n            return E;\n          }\n          function P(l) {\n            return c(l, E => Array.isArray(E) ? k(E) : E.parts ? Object.assign(Object.assign({}, E), {}, {\n              parts: k(E.parts)\n            }) : E);\n          }\n          function C(l) {\n            return c(l, E => typeof E == \"string\" && E.includes(`\n`) ? D(E) : E);\n          }\n          function D(l) {\n            let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;\n            return a(E, l.split(`\n`)).parts;\n          }\n          function g(l) {\n            if (l.type === \"line\") return !0;\n          }\n          function F(l) {\n            return v(l, g, !1);\n          }\n          n.exports = {\n            isConcat: r,\n            getDocParts: u,\n            willBreak: d,\n            traverseDoc: o,\n            findInDoc: v,\n            mapDoc: c,\n            propagateBreaks: f,\n            removeLines: w,\n            stripTrailingHardline: S,\n            normalizeParts: k,\n            normalizeDoc: P,\n            cleanDoc: I,\n            replaceTextEndOfLine: D,\n            replaceEndOfLine: C,\n            canBreak: F\n          };\n        }\n      }),\n      yD = Z({\n        \"src/document/doc-printer.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              convertEndOfLineToChars: t\n            } = jn(),\n            s = it(),\n            a = Ca(),\n            {\n              fill: r,\n              cursor: u,\n              indent: i\n            } = Ln(),\n            {\n              isConcat: o,\n              getDocParts: c\n            } = On(),\n            v,\n            m = 1,\n            d = 2;\n          function p() {\n            return {\n              value: \"\",\n              length: 0,\n              queue: []\n            };\n          }\n          function f(B, I) {\n            return w(B, {\n              type: \"indent\"\n            }, I);\n          }\n          function h(B, I, k) {\n            return I === Number.NEGATIVE_INFINITY ? B.root || p() : I < 0 ? w(B, {\n              type: \"dedent\"\n            }, k) : I ? I.type === \"root\" ? Object.assign(Object.assign({}, B), {}, {\n              root: B\n            }) : w(B, {\n              type: typeof I == \"string\" ? \"stringAlign\" : \"numberAlign\",\n              n: I\n            }, k) : B;\n          }\n          function w(B, I, k) {\n            let P = I.type === \"dedent\" ? B.queue.slice(0, -1) : [...B.queue, I],\n              C = \"\",\n              D = 0,\n              g = 0,\n              F = 0;\n            for (let L of P) switch (L.type) {\n              case \"indent\":\n                y(), k.useTabs ? l(1) : E(k.tabWidth);\n                break;\n              case \"stringAlign\":\n                y(), C += L.n, D += L.n.length;\n                break;\n              case \"numberAlign\":\n                g += 1, F += L.n;\n                break;\n              default:\n                throw new Error(\"Unexpected type '\".concat(L.type, \"'\"));\n            }\n            return x(), Object.assign(Object.assign({}, B), {}, {\n              value: C,\n              length: D,\n              queue: P\n            });\n            function l(L) {\n              C += \"\t\".repeat(L), D += k.tabWidth * L;\n            }\n            function E(L) {\n              C += \" \".repeat(L), D += L;\n            }\n            function y() {\n              k.useTabs ? N() : x();\n            }\n            function N() {\n              g > 0 && l(g), b();\n            }\n            function x() {\n              F > 0 && E(F), b();\n            }\n            function b() {\n              g = 0, F = 0;\n            }\n          }\n          function T(B) {\n            if (B.length === 0) return 0;\n            let I = 0;\n            for (; B.length > 0 && typeof s(B) == \"string\" && /^[\\t ]*$/.test(s(B));) I += B.pop().length;\n            if (B.length > 0 && typeof s(B) == \"string\") {\n              let k = s(B).replace(/[\\t ]*$/, \"\");\n              I += s(B).length - k.length, B[B.length - 1] = k;\n            }\n            return I;\n          }\n          function A(B, I, k, P, C, D) {\n            let g = I.length,\n              F = [B],\n              l = [];\n            for (; k >= 0;) {\n              if (F.length === 0) {\n                if (g === 0) return !0;\n                F.push(I[g - 1]), g--;\n                continue;\n              }\n              let [E, y, N] = F.pop();\n              if (typeof N == \"string\") l.push(N), k -= a(N);else if (o(N)) {\n                let x = c(N);\n                for (let b = x.length - 1; b >= 0; b--) F.push([E, y, x[b]]);\n              } else switch (N.type) {\n                case \"indent\":\n                  F.push([f(E, P), y, N.contents]);\n                  break;\n                case \"align\":\n                  F.push([h(E, N.n, P), y, N.contents]);\n                  break;\n                case \"trim\":\n                  k += T(l);\n                  break;\n                case \"group\":\n                  {\n                    if (D && N.break) return !1;\n                    let x = N.break ? m : y;\n                    F.push([E, x, N.expandedStates && x === m ? s(N.expandedStates) : N.contents]), N.id && (v[N.id] = x);\n                    break;\n                  }\n                case \"fill\":\n                  for (let x = N.parts.length - 1; x >= 0; x--) F.push([E, y, N.parts[x]]);\n                  break;\n                case \"if-break\":\n                case \"indent-if-break\":\n                  {\n                    let x = N.groupId ? v[N.groupId] : y;\n                    if (x === m) {\n                      let b = N.type === \"if-break\" ? N.breakContents : N.negate ? N.contents : i(N.contents);\n                      b && F.push([E, y, b]);\n                    }\n                    if (x === d) {\n                      let b = N.type === \"if-break\" ? N.flatContents : N.negate ? i(N.contents) : N.contents;\n                      b && F.push([E, y, b]);\n                    }\n                    break;\n                  }\n                case \"line\":\n                  switch (y) {\n                    case d:\n                      if (!N.hard) {\n                        N.soft || (l.push(\" \"), k -= 1);\n                        break;\n                      }\n                      return !0;\n                    case m:\n                      return !0;\n                  }\n                  break;\n                case \"line-suffix\":\n                  C = !0;\n                  break;\n                case \"line-suffix-boundary\":\n                  if (C) return !1;\n                  break;\n                case \"label\":\n                  F.push([E, y, N.contents]);\n                  break;\n              }\n            }\n            return !1;\n          }\n          function S(B, I) {\n            v = {};\n            let k = I.printWidth,\n              P = t(I.endOfLine),\n              C = 0,\n              D = [[p(), m, B]],\n              g = [],\n              F = !1,\n              l = [];\n            for (; D.length > 0;) {\n              let [y, N, x] = D.pop();\n              if (typeof x == \"string\") {\n                let b = P !== `\n` ? x.replace(/\\n/g, P) : x;\n                g.push(b), C += a(b);\n              } else if (o(x)) {\n                let b = c(x);\n                for (let L = b.length - 1; L >= 0; L--) D.push([y, N, b[L]]);\n              } else switch (x.type) {\n                case \"cursor\":\n                  g.push(u.placeholder);\n                  break;\n                case \"indent\":\n                  D.push([f(y, I), N, x.contents]);\n                  break;\n                case \"align\":\n                  D.push([h(y, x.n, I), N, x.contents]);\n                  break;\n                case \"trim\":\n                  C -= T(g);\n                  break;\n                case \"group\":\n                  switch (N) {\n                    case d:\n                      if (!F) {\n                        D.push([y, x.break ? m : d, x.contents]);\n                        break;\n                      }\n                    case m:\n                      {\n                        F = !1;\n                        let b = [y, d, x.contents],\n                          L = k - C,\n                          M = l.length > 0;\n                        if (!x.break && A(b, D, L, I, M)) D.push(b);else if (x.expandedStates) {\n                          let j = s(x.expandedStates);\n                          if (x.break) {\n                            D.push([y, m, j]);\n                            break;\n                          } else for (let $ = 1; $ < x.expandedStates.length + 1; $++) if ($ >= x.expandedStates.length) {\n                            D.push([y, m, j]);\n                            break;\n                          } else {\n                            let V = x.expandedStates[$],\n                              q = [y, d, V];\n                            if (A(q, D, L, I, M)) {\n                              D.push(q);\n                              break;\n                            }\n                          }\n                        } else D.push([y, m, x.contents]);\n                        break;\n                      }\n                  }\n                  x.id && (v[x.id] = s(D)[1]);\n                  break;\n                case \"fill\":\n                  {\n                    let b = k - C,\n                      {\n                        parts: L\n                      } = x;\n                    if (L.length === 0) break;\n                    let [M, j] = L,\n                      $ = [y, d, M],\n                      V = [y, m, M],\n                      q = A($, [], b, I, l.length > 0, !0);\n                    if (L.length === 1) {\n                      q ? D.push($) : D.push(V);\n                      break;\n                    }\n                    let Y = [y, d, j],\n                      H = [y, m, j];\n                    if (L.length === 2) {\n                      q ? D.push(Y, $) : D.push(H, V);\n                      break;\n                    }\n                    L.splice(0, 2);\n                    let R = [y, N, r(L)],\n                      Q = L[0];\n                    A([y, d, [M, j, Q]], [], b, I, l.length > 0, !0) ? D.push(R, Y, $) : q ? D.push(R, H, $) : D.push(R, H, V);\n                    break;\n                  }\n                case \"if-break\":\n                case \"indent-if-break\":\n                  {\n                    let b = x.groupId ? v[x.groupId] : N;\n                    if (b === m) {\n                      let L = x.type === \"if-break\" ? x.breakContents : x.negate ? x.contents : i(x.contents);\n                      L && D.push([y, N, L]);\n                    }\n                    if (b === d) {\n                      let L = x.type === \"if-break\" ? x.flatContents : x.negate ? i(x.contents) : x.contents;\n                      L && D.push([y, N, L]);\n                    }\n                    break;\n                  }\n                case \"line-suffix\":\n                  l.push([y, N, x.contents]);\n                  break;\n                case \"line-suffix-boundary\":\n                  l.length > 0 && D.push([y, N, {\n                    type: \"line\",\n                    hard: !0\n                  }]);\n                  break;\n                case \"line\":\n                  switch (N) {\n                    case d:\n                      if (x.hard) F = !0;else {\n                        x.soft || (g.push(\" \"), C += 1);\n                        break;\n                      }\n                    case m:\n                      if (l.length > 0) {\n                        D.push([y, N, x], ...l.reverse()), l = [];\n                        break;\n                      }\n                      x.literal ? y.root ? (g.push(P, y.root.value), C = y.root.length) : (g.push(P), C = 0) : (C -= T(g), g.push(P + y.value), C = y.length);\n                      break;\n                  }\n                  break;\n                case \"label\":\n                  D.push([y, N, x.contents]);\n                  break;\n                default:\n              }\n              D.length === 0 && l.length > 0 && (D.push(...l.reverse()), l = []);\n            }\n            let E = g.indexOf(u.placeholder);\n            if (E !== -1) {\n              let y = g.indexOf(u.placeholder, E + 1),\n                N = g.slice(0, E).join(\"\"),\n                x = g.slice(E + 1, y).join(\"\"),\n                b = g.slice(y + 1).join(\"\");\n              return {\n                formatted: N + x + b,\n                cursorNodeStart: N.length,\n                cursorNodeText: x\n              };\n            }\n            return {\n              formatted: g.join(\"\")\n            };\n          }\n          n.exports = {\n            printDocToString: S\n          };\n        }\n      }),\n      hD = Z({\n        \"src/document/doc-debug.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            isConcat: t,\n            getDocParts: s\n          } = On();\n          function a(u) {\n            if (!u) return \"\";\n            if (t(u)) {\n              let i = [];\n              for (let o of s(u)) if (t(o)) i.push(...a(o).parts);else {\n                let c = a(o);\n                c !== \"\" && i.push(c);\n              }\n              return {\n                type: \"concat\",\n                parts: i\n              };\n            }\n            return u.type === \"if-break\" ? Object.assign(Object.assign({}, u), {}, {\n              breakContents: a(u.breakContents),\n              flatContents: a(u.flatContents)\n            }) : u.type === \"group\" ? Object.assign(Object.assign({}, u), {}, {\n              contents: a(u.contents),\n              expandedStates: u.expandedStates && u.expandedStates.map(a)\n            }) : u.type === \"fill\" ? {\n              type: \"fill\",\n              parts: u.parts.map(a)\n            } : u.contents ? Object.assign(Object.assign({}, u), {}, {\n              contents: a(u.contents)\n            }) : u;\n          }\n          function r(u) {\n            let i = Object.create(null),\n              o = new Set();\n            return c(a(u));\n            function c(m, d, p) {\n              if (typeof m == \"string\") return JSON.stringify(m);\n              if (t(m)) {\n                let f = s(m).map(c).filter(Boolean);\n                return f.length === 1 ? f[0] : \"[\".concat(f.join(\", \"), \"]\");\n              }\n              if (m.type === \"line\") {\n                let f = Array.isArray(p) && p[d + 1] && p[d + 1].type === \"break-parent\";\n                return m.literal ? f ? \"literalline\" : \"literallineWithoutBreakParent\" : m.hard ? f ? \"hardline\" : \"hardlineWithoutBreakParent\" : m.soft ? \"softline\" : \"line\";\n              }\n              if (m.type === \"break-parent\") return Array.isArray(p) && p[d - 1] && p[d - 1].type === \"line\" && p[d - 1].hard ? void 0 : \"breakParent\";\n              if (m.type === \"trim\") return \"trim\";\n              if (m.type === \"indent\") return \"indent(\" + c(m.contents) + \")\";\n              if (m.type === \"align\") return m.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + c(m.contents) + \")\" : m.n < 0 ? \"dedent(\" + c(m.contents) + \")\" : m.n.type === \"root\" ? \"markAsRoot(\" + c(m.contents) + \")\" : \"align(\" + JSON.stringify(m.n) + \", \" + c(m.contents) + \")\";\n              if (m.type === \"if-break\") return \"ifBreak(\" + c(m.breakContents) + (m.flatContents ? \", \" + c(m.flatContents) : \"\") + (m.groupId ? (m.flatContents ? \"\" : ', \"\"') + \", { groupId: \".concat(v(m.groupId), \" }\") : \"\") + \")\";\n              if (m.type === \"indent-if-break\") {\n                let f = [];\n                m.negate && f.push(\"negate: true\"), m.groupId && f.push(\"groupId: \".concat(v(m.groupId)));\n                let h = f.length > 0 ? \", { \".concat(f.join(\", \"), \" }\") : \"\";\n                return \"indentIfBreak(\".concat(c(m.contents)).concat(h, \")\");\n              }\n              if (m.type === \"group\") {\n                let f = [];\n                m.break && m.break !== \"propagated\" && f.push(\"shouldBreak: true\"), m.id && f.push(\"id: \".concat(v(m.id)));\n                let h = f.length > 0 ? \", { \".concat(f.join(\", \"), \" }\") : \"\";\n                return m.expandedStates ? \"conditionalGroup([\".concat(m.expandedStates.map(w => c(w)).join(\",\"), \"]\").concat(h, \")\") : \"group(\".concat(c(m.contents)).concat(h, \")\");\n              }\n              if (m.type === \"fill\") return \"fill([\".concat(m.parts.map(f => c(f)).join(\", \"), \"])\");\n              if (m.type === \"line-suffix\") return \"lineSuffix(\" + c(m.contents) + \")\";\n              if (m.type === \"line-suffix-boundary\") return \"lineSuffixBoundary\";\n              if (m.type === \"label\") return \"label(\".concat(JSON.stringify(m.label), \", \").concat(c(m.contents), \")\");\n              throw new Error(\"Unknown doc type \" + m.type);\n            }\n            function v(m) {\n              if (typeof m != \"symbol\") return JSON.stringify(String(m));\n              if (m in i) return i[m];\n              let d = String(m).slice(7, -1) || \"symbol\";\n              for (let p = 0;; p++) {\n                let f = d + (p > 0 ? \" #\".concat(p) : \"\");\n                if (!o.has(f)) return o.add(f), i[m] = \"Symbol.for(\".concat(JSON.stringify(f), \")\");\n              }\n            }\n          }\n          n.exports = {\n            printDocToDebug: r\n          };\n        }\n      }),\n      Oe = Z({\n        \"src/document/index.js\"(e, n) {\n          \"use strict\";\n\n          re(), n.exports = {\n            builders: Ln(),\n            printer: yD(),\n            utils: On(),\n            debug: hD()\n          };\n        }\n      }),\n      Ea = {};\n    Ut(Ea, {\n      default: () => vD\n    });\n    function vD(e) {\n      if (typeof e != \"string\") throw new TypeError(\"Expected a string\");\n      return e.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n    }\n    var CD = mt({\n        \"node_modules/escape-string-regexp/index.js\"() {\n          re();\n        }\n      }),\n      Fa = Z({\n        \"node_modules/semver/internal/debug.js\"(e, n) {\n          re();\n          var t = typeof Tt == \"object\" && Tt.env && Tt.env.NODE_DEBUG && /\\bsemver\\b/i.test(Tt.env.NODE_DEBUG) ? function () {\n            for (var s = arguments.length, a = new Array(s), r = 0; r < s; r++) a[r] = arguments[r];\n            return console.error(\"SEMVER\", ...a);\n          } : () => {};\n          n.exports = t;\n        }\n      }),\n      Aa = Z({\n        \"node_modules/semver/internal/constants.js\"(e, n) {\n          re();\n          var t = \"2.0.0\",\n            s = 256,\n            a = Number.MAX_SAFE_INTEGER || 9007199254740991,\n            r = 16;\n          n.exports = {\n            SEMVER_SPEC_VERSION: t,\n            MAX_LENGTH: s,\n            MAX_SAFE_INTEGER: a,\n            MAX_SAFE_COMPONENT_LENGTH: r\n          };\n        }\n      }),\n      ED = Z({\n        \"node_modules/semver/internal/re.js\"(e, n) {\n          re();\n          var {\n              MAX_SAFE_COMPONENT_LENGTH: t\n            } = Aa(),\n            s = Fa();\n          e = n.exports = {};\n          var a = e.re = [],\n            r = e.src = [],\n            u = e.t = {},\n            i = 0,\n            o = (c, v, m) => {\n              let d = i++;\n              s(c, d, v), u[c] = d, r[d] = v, a[d] = new RegExp(v, m ? \"g\" : void 0);\n            };\n          o(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\"), o(\"NUMERICIDENTIFIERLOOSE\", \"[0-9]+\"), o(\"NONNUMERICIDENTIFIER\", \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\"), o(\"MAINVERSION\", \"(\".concat(r[u.NUMERICIDENTIFIER], \")\\\\.(\").concat(r[u.NUMERICIDENTIFIER], \")\\\\.(\").concat(r[u.NUMERICIDENTIFIER], \")\")), o(\"MAINVERSIONLOOSE\", \"(\".concat(r[u.NUMERICIDENTIFIERLOOSE], \")\\\\.(\").concat(r[u.NUMERICIDENTIFIERLOOSE], \")\\\\.(\").concat(r[u.NUMERICIDENTIFIERLOOSE], \")\")), o(\"PRERELEASEIDENTIFIER\", \"(?:\".concat(r[u.NUMERICIDENTIFIER], \"|\").concat(r[u.NONNUMERICIDENTIFIER], \")\")), o(\"PRERELEASEIDENTIFIERLOOSE\", \"(?:\".concat(r[u.NUMERICIDENTIFIERLOOSE], \"|\").concat(r[u.NONNUMERICIDENTIFIER], \")\")), o(\"PRERELEASE\", \"(?:-(\".concat(r[u.PRERELEASEIDENTIFIER], \"(?:\\\\.\").concat(r[u.PRERELEASEIDENTIFIER], \")*))\")), o(\"PRERELEASELOOSE\", \"(?:-?(\".concat(r[u.PRERELEASEIDENTIFIERLOOSE], \"(?:\\\\.\").concat(r[u.PRERELEASEIDENTIFIERLOOSE], \")*))\")), o(\"BUILDIDENTIFIER\", \"[0-9A-Za-z-]+\"), o(\"BUILD\", \"(?:\\\\+(\".concat(r[u.BUILDIDENTIFIER], \"(?:\\\\.\").concat(r[u.BUILDIDENTIFIER], \")*))\")), o(\"FULLPLAIN\", \"v?\".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE], \"?\").concat(r[u.BUILD], \"?\")), o(\"FULL\", \"^\".concat(r[u.FULLPLAIN], \"$\")), o(\"LOOSEPLAIN\", \"[v=\\\\s]*\".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE], \"?\").concat(r[u.BUILD], \"?\")), o(\"LOOSE\", \"^\".concat(r[u.LOOSEPLAIN], \"$\")), o(\"GTLT\", \"((?:<|>)?=?)\"), o(\"XRANGEIDENTIFIERLOOSE\", \"\".concat(r[u.NUMERICIDENTIFIERLOOSE], \"|x|X|\\\\*\")), o(\"XRANGEIDENTIFIER\", \"\".concat(r[u.NUMERICIDENTIFIER], \"|x|X|\\\\*\")), o(\"XRANGEPLAIN\", \"[v=\\\\s]*(\".concat(r[u.XRANGEIDENTIFIER], \")(?:\\\\.(\").concat(r[u.XRANGEIDENTIFIER], \")(?:\\\\.(\").concat(r[u.XRANGEIDENTIFIER], \")(?:\").concat(r[u.PRERELEASE], \")?\").concat(r[u.BUILD], \"?)?)?\")), o(\"XRANGEPLAINLOOSE\", \"[v=\\\\s]*(\".concat(r[u.XRANGEIDENTIFIERLOOSE], \")(?:\\\\.(\").concat(r[u.XRANGEIDENTIFIERLOOSE], \")(?:\\\\.(\").concat(r[u.XRANGEIDENTIFIERLOOSE], \")(?:\").concat(r[u.PRERELEASELOOSE], \")?\").concat(r[u.BUILD], \"?)?)?\")), o(\"XRANGE\", \"^\".concat(r[u.GTLT], \"\\\\s*\").concat(r[u.XRANGEPLAIN], \"$\")), o(\"XRANGELOOSE\", \"^\".concat(r[u.GTLT], \"\\\\s*\").concat(r[u.XRANGEPLAINLOOSE], \"$\")), o(\"COERCE\", \"(^|[^\\\\d])(\\\\d{1,\".concat(t, \"})(?:\\\\.(\\\\d{1,\").concat(t, \"}))?(?:\\\\.(\\\\d{1,\").concat(t, \"}))?(?:$|[^\\\\d])\")), o(\"COERCERTL\", r[u.COERCE], !0), o(\"LONETILDE\", \"(?:~>?)\"), o(\"TILDETRIM\", \"(\\\\s*)\".concat(r[u.LONETILDE], \"\\\\s+\"), !0), e.tildeTrimReplace = \"$1~\", o(\"TILDE\", \"^\".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], \"$\")), o(\"TILDELOOSE\", \"^\".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE], \"$\")), o(\"LONECARET\", \"(?:\\\\^)\"), o(\"CARETTRIM\", \"(\\\\s*)\".concat(r[u.LONECARET], \"\\\\s+\"), !0), e.caretTrimReplace = \"$1^\", o(\"CARET\", \"^\".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], \"$\")), o(\"CARETLOOSE\", \"^\".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE], \"$\")), o(\"COMPARATORLOOSE\", \"^\".concat(r[u.GTLT], \"\\\\s*(\").concat(r[u.LOOSEPLAIN], \")$|^$\")), o(\"COMPARATOR\", \"^\".concat(r[u.GTLT], \"\\\\s*(\").concat(r[u.FULLPLAIN], \")$|^$\")), o(\"COMPARATORTRIM\", \"(\\\\s*)\".concat(r[u.GTLT], \"\\\\s*(\").concat(r[u.LOOSEPLAIN], \"|\").concat(r[u.XRANGEPLAIN], \")\"), !0), e.comparatorTrimReplace = \"$1$2$3\", o(\"HYPHENRANGE\", \"^\\\\s*(\".concat(r[u.XRANGEPLAIN], \")\\\\s+-\\\\s+(\").concat(r[u.XRANGEPLAIN], \")\\\\s*$\")), o(\"HYPHENRANGELOOSE\", \"^\\\\s*(\".concat(r[u.XRANGEPLAINLOOSE], \")\\\\s+-\\\\s+(\").concat(r[u.XRANGEPLAINLOOSE], \")\\\\s*$\")), o(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\"), o(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\"), o(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n        }\n      }),\n      FD = Z({\n        \"node_modules/semver/internal/parse-options.js\"(e, n) {\n          re();\n          var t = [\"includePrerelease\", \"loose\", \"rtl\"],\n            s = a => a ? typeof a != \"object\" ? {\n              loose: !0\n            } : t.filter(r => a[r]).reduce((r, u) => (r[u] = !0, r), {}) : {};\n          n.exports = s;\n        }\n      }),\n      AD = Z({\n        \"node_modules/semver/internal/identifiers.js\"(e, n) {\n          re();\n          var t = /^[0-9]+$/,\n            s = (r, u) => {\n              let i = t.test(r),\n                o = t.test(u);\n              return i && o && (r = +r, u = +u), r === u ? 0 : i && !o ? -1 : o && !i ? 1 : r < u ? -1 : 1;\n            },\n            a = (r, u) => s(u, r);\n          n.exports = {\n            compareIdentifiers: s,\n            rcompareIdentifiers: a\n          };\n        }\n      }),\n      SD = Z({\n        \"node_modules/semver/classes/semver.js\"(e, n) {\n          re();\n          var t = Fa(),\n            {\n              MAX_LENGTH: s,\n              MAX_SAFE_INTEGER: a\n            } = Aa(),\n            {\n              re: r,\n              t: u\n            } = ED(),\n            i = FD(),\n            {\n              compareIdentifiers: o\n            } = AD(),\n            c = class {\n              constructor(v, m) {\n                if (m = i(m), v instanceof c) {\n                  if (v.loose === !!m.loose && v.includePrerelease === !!m.includePrerelease) return v;\n                  v = v.version;\n                } else if (typeof v != \"string\") throw new TypeError(\"Invalid Version: \".concat(v));\n                if (v.length > s) throw new TypeError(\"version is longer than \".concat(s, \" characters\"));\n                t(\"SemVer\", v, m), this.options = m, this.loose = !!m.loose, this.includePrerelease = !!m.includePrerelease;\n                let d = v.trim().match(m.loose ? r[u.LOOSE] : r[u.FULL]);\n                if (!d) throw new TypeError(\"Invalid Version: \".concat(v));\n                if (this.raw = v, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > a || this.major < 0) throw new TypeError(\"Invalid major version\");\n                if (this.minor > a || this.minor < 0) throw new TypeError(\"Invalid minor version\");\n                if (this.patch > a || this.patch < 0) throw new TypeError(\"Invalid patch version\");\n                d[4] ? this.prerelease = d[4].split(\".\").map(p => {\n                  if (/^[0-9]+$/.test(p)) {\n                    let f = +p;\n                    if (f >= 0 && f < a) return f;\n                  }\n                  return p;\n                }) : this.prerelease = [], this.build = d[5] ? d[5].split(\".\") : [], this.format();\n              }\n              format() {\n                return this.version = \"\".concat(this.major, \".\").concat(this.minor, \".\").concat(this.patch), this.prerelease.length && (this.version += \"-\".concat(this.prerelease.join(\".\"))), this.version;\n              }\n              toString() {\n                return this.version;\n              }\n              compare(v) {\n                if (t(\"SemVer.compare\", this.version, this.options, v), !(v instanceof c)) {\n                  if (typeof v == \"string\" && v === this.version) return 0;\n                  v = new c(v, this.options);\n                }\n                return v.version === this.version ? 0 : this.compareMain(v) || this.comparePre(v);\n              }\n              compareMain(v) {\n                return v instanceof c || (v = new c(v, this.options)), o(this.major, v.major) || o(this.minor, v.minor) || o(this.patch, v.patch);\n              }\n              comparePre(v) {\n                if (v instanceof c || (v = new c(v, this.options)), this.prerelease.length && !v.prerelease.length) return -1;\n                if (!this.prerelease.length && v.prerelease.length) return 1;\n                if (!this.prerelease.length && !v.prerelease.length) return 0;\n                let m = 0;\n                do {\n                  let d = this.prerelease[m],\n                    p = v.prerelease[m];\n                  if (t(\"prerelease compare\", m, d, p), d === void 0 && p === void 0) return 0;\n                  if (p === void 0) return 1;\n                  if (d === void 0) return -1;\n                  if (d === p) continue;\n                  return o(d, p);\n                } while (++m);\n              }\n              compareBuild(v) {\n                v instanceof c || (v = new c(v, this.options));\n                let m = 0;\n                do {\n                  let d = this.build[m],\n                    p = v.build[m];\n                  if (t(\"prerelease compare\", m, d, p), d === void 0 && p === void 0) return 0;\n                  if (p === void 0) return 1;\n                  if (d === void 0) return -1;\n                  if (d === p) continue;\n                  return o(d, p);\n                } while (++m);\n              }\n              inc(v, m) {\n                switch (v) {\n                  case \"premajor\":\n                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc(\"pre\", m);\n                    break;\n                  case \"preminor\":\n                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc(\"pre\", m);\n                    break;\n                  case \"prepatch\":\n                    this.prerelease.length = 0, this.inc(\"patch\", m), this.inc(\"pre\", m);\n                    break;\n                  case \"prerelease\":\n                    this.prerelease.length === 0 && this.inc(\"patch\", m), this.inc(\"pre\", m);\n                    break;\n                  case \"major\":\n                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];\n                    break;\n                  case \"minor\":\n                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];\n                    break;\n                  case \"patch\":\n                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];\n                    break;\n                  case \"pre\":\n                    if (this.prerelease.length === 0) this.prerelease = [0];else {\n                      let d = this.prerelease.length;\n                      for (; --d >= 0;) typeof this.prerelease[d] == \"number\" && (this.prerelease[d]++, d = -2);\n                      d === -1 && this.prerelease.push(0);\n                    }\n                    m && (o(this.prerelease[0], m) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [m, 0]) : this.prerelease = [m, 0]);\n                    break;\n                  default:\n                    throw new Error(\"invalid increment argument: \".concat(v));\n                }\n                return this.format(), this.raw = this.version, this;\n              }\n            };\n          n.exports = c;\n        }\n      }),\n      qn = Z({\n        \"node_modules/semver/functions/compare.js\"(e, n) {\n          re();\n          var t = SD(),\n            s = (a, r, u) => new t(a, u).compare(new t(r, u));\n          n.exports = s;\n        }\n      }),\n      xD = Z({\n        \"node_modules/semver/functions/lt.js\"(e, n) {\n          re();\n          var t = qn(),\n            s = (a, r, u) => t(a, r, u) < 0;\n          n.exports = s;\n        }\n      }),\n      bD = Z({\n        \"node_modules/semver/functions/gte.js\"(e, n) {\n          re();\n          var t = qn(),\n            s = (a, r, u) => t(a, r, u) >= 0;\n          n.exports = s;\n        }\n      }),\n      TD = Z({\n        \"src/utils/arrayify.js\"(e, n) {\n          \"use strict\";\n\n          re(), n.exports = (t, s) => Object.entries(t).map(a => {\n            let [r, u] = a;\n            return Object.assign({\n              [s]: r\n            }, u);\n          });\n        }\n      }),\n      BD = Z({\n        \"node_modules/outdent/lib/index.js\"(e, n) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.outdent = void 0;\n          function t() {\n            for (var A = [], S = 0; S < arguments.length; S++) A[S] = arguments[S];\n          }\n          function s() {\n            return typeof WeakMap < \"u\" ? new WeakMap() : a();\n          }\n          function a() {\n            return {\n              add: t,\n              delete: t,\n              get: t,\n              set: t,\n              has: function (A) {\n                return !1;\n              }\n            };\n          }\n          var r = Object.prototype.hasOwnProperty,\n            u = function (A, S) {\n              return r.call(A, S);\n            };\n          function i(A, S) {\n            for (var B in S) u(S, B) && (A[B] = S[B]);\n            return A;\n          }\n          var o = /^[ \\t]*(?:\\r\\n|\\r|\\n)/,\n            c = /(?:\\r\\n|\\r|\\n)[ \\t]*$/,\n            v = /^(?:[\\r\\n]|$)/,\n            m = /(?:\\r\\n|\\r|\\n)([ \\t]*)(?:[^ \\t\\r\\n]|$)/,\n            d = /^[ \\t]*[\\r\\n][ \\t\\r\\n]*$/;\n          function p(A, S, B) {\n            var I = 0,\n              k = A[0].match(m);\n            k && (I = k[1].length);\n            var P = \"(\\\\r\\\\n|\\\\r|\\\\n).{0,\" + I + \"}\",\n              C = new RegExp(P, \"g\");\n            S && (A = A.slice(1));\n            var D = B.newline,\n              g = B.trimLeadingNewline,\n              F = B.trimTrailingNewline,\n              l = typeof D == \"string\",\n              E = A.length,\n              y = A.map(function (N, x) {\n                return N = N.replace(C, \"$1\"), x === 0 && g && (N = N.replace(o, \"\")), x === E - 1 && F && (N = N.replace(c, \"\")), l && (N = N.replace(/\\r\\n|\\n|\\r/g, function (b) {\n                  return D;\n                })), N;\n              });\n            return y;\n          }\n          function f(A, S) {\n            for (var B = \"\", I = 0, k = A.length; I < k; I++) B += A[I], I < k - 1 && (B += S[I]);\n            return B;\n          }\n          function h(A) {\n            return u(A, \"raw\") && u(A, \"length\");\n          }\n          function w(A) {\n            var S = s(),\n              B = s();\n            function I(P) {\n              for (var C = [], D = 1; D < arguments.length; D++) C[D - 1] = arguments[D];\n              if (h(P)) {\n                var g = P,\n                  F = (C[0] === I || C[0] === T) && d.test(g[0]) && v.test(g[1]),\n                  l = F ? B : S,\n                  E = l.get(g);\n                if (E || (E = p(g, F, A), l.set(g, E)), C.length === 0) return E[0];\n                var y = f(E, F ? C.slice(1) : C);\n                return y;\n              } else return w(i(i({}, A), P || {}));\n            }\n            var k = i(I, {\n              string: function (P) {\n                return p([P], !1, A)[0];\n              }\n            });\n            return k;\n          }\n          var T = w({\n            trimLeadingNewline: !0,\n            trimTrailingNewline: !0\n          });\n          if (e.outdent = T, e.default = T, typeof n < \"u\") try {\n            n.exports = T, Object.defineProperty(T, \"__esModule\", {\n              value: !0\n            }), T.default = T, T.outdent = T;\n          } catch {}\n        }\n      }),\n      ND = Z({\n        \"src/main/core-options.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              outdent: t\n            } = BD(),\n            s = \"Config\",\n            a = \"Editor\",\n            r = \"Format\",\n            u = \"Other\",\n            i = \"Output\",\n            o = \"Global\",\n            c = \"Special\",\n            v = {\n              cursorOffset: {\n                since: \"1.4.0\",\n                category: c,\n                type: \"int\",\n                default: -1,\n                range: {\n                  start: -1,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                },\n                description: t(sa || (sa = Pt([`\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    `]))),\n                cliCategory: a\n              },\n              endOfLine: {\n                since: \"1.15.0\",\n                category: o,\n                type: \"choice\",\n                default: [{\n                  since: \"1.15.0\",\n                  value: \"auto\"\n                }, {\n                  since: \"2.0.0\",\n                  value: \"lf\"\n                }],\n                description: \"Which end of line characters to apply.\",\n                choices: [{\n                  value: \"lf\",\n                  description: \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\"\n                }, {\n                  value: \"crlf\",\n                  description: \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\"\n                }, {\n                  value: \"cr\",\n                  description: \"Carriage Return character only (\\\\r), used very rarely\"\n                }, {\n                  value: \"auto\",\n                  description: t(ia || (ia = Pt([`\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        `])))\n                }]\n              },\n              filepath: {\n                since: \"1.4.0\",\n                category: c,\n                type: \"path\",\n                description: \"Specify the input filepath. This will be used to do parser inference.\",\n                cliName: \"stdin-filepath\",\n                cliCategory: u,\n                cliDescription: \"Path to the file to pretend that stdin comes from.\"\n              },\n              insertPragma: {\n                since: \"1.8.0\",\n                category: c,\n                type: \"boolean\",\n                default: !1,\n                description: \"Insert @format pragma into file's first docblock comment.\",\n                cliCategory: u\n              },\n              parser: {\n                since: \"0.0.10\",\n                category: o,\n                type: \"choice\",\n                default: [{\n                  since: \"0.0.10\",\n                  value: \"babylon\"\n                }, {\n                  since: \"1.13.0\",\n                  value: void 0\n                }],\n                description: \"Which parser to use.\",\n                exception: m => typeof m == \"string\" || typeof m == \"function\",\n                choices: [{\n                  value: \"flow\",\n                  description: \"Flow\"\n                }, {\n                  value: \"babel\",\n                  since: \"1.16.0\",\n                  description: \"JavaScript\"\n                }, {\n                  value: \"babel-flow\",\n                  since: \"1.16.0\",\n                  description: \"Flow\"\n                }, {\n                  value: \"babel-ts\",\n                  since: \"2.0.0\",\n                  description: \"TypeScript\"\n                }, {\n                  value: \"typescript\",\n                  since: \"1.4.0\",\n                  description: \"TypeScript\"\n                }, {\n                  value: \"acorn\",\n                  since: \"2.6.0\",\n                  description: \"JavaScript\"\n                }, {\n                  value: \"espree\",\n                  since: \"2.2.0\",\n                  description: \"JavaScript\"\n                }, {\n                  value: \"meriyah\",\n                  since: \"2.2.0\",\n                  description: \"JavaScript\"\n                }, {\n                  value: \"css\",\n                  since: \"1.7.1\",\n                  description: \"CSS\"\n                }, {\n                  value: \"less\",\n                  since: \"1.7.1\",\n                  description: \"Less\"\n                }, {\n                  value: \"scss\",\n                  since: \"1.7.1\",\n                  description: \"SCSS\"\n                }, {\n                  value: \"json\",\n                  since: \"1.5.0\",\n                  description: \"JSON\"\n                }, {\n                  value: \"json5\",\n                  since: \"1.13.0\",\n                  description: \"JSON5\"\n                }, {\n                  value: \"json-stringify\",\n                  since: \"1.13.0\",\n                  description: \"JSON.stringify\"\n                }, {\n                  value: \"graphql\",\n                  since: \"1.5.0\",\n                  description: \"GraphQL\"\n                }, {\n                  value: \"markdown\",\n                  since: \"1.8.0\",\n                  description: \"Markdown\"\n                }, {\n                  value: \"mdx\",\n                  since: \"1.15.0\",\n                  description: \"MDX\"\n                }, {\n                  value: \"vue\",\n                  since: \"1.10.0\",\n                  description: \"Vue\"\n                }, {\n                  value: \"yaml\",\n                  since: \"1.14.0\",\n                  description: \"YAML\"\n                }, {\n                  value: \"glimmer\",\n                  since: \"2.3.0\",\n                  description: \"Ember / Handlebars\"\n                }, {\n                  value: \"html\",\n                  since: \"1.15.0\",\n                  description: \"HTML\"\n                }, {\n                  value: \"angular\",\n                  since: \"1.15.0\",\n                  description: \"Angular\"\n                }, {\n                  value: \"lwc\",\n                  since: \"1.17.0\",\n                  description: \"Lightning Web Components\"\n                }]\n              },\n              plugins: {\n                since: \"1.10.0\",\n                type: \"path\",\n                array: !0,\n                default: [{\n                  value: []\n                }],\n                category: o,\n                description: \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",\n                exception: m => typeof m == \"string\" || typeof m == \"object\",\n                cliName: \"plugin\",\n                cliCategory: s\n              },\n              pluginSearchDirs: {\n                since: \"1.13.0\",\n                type: \"path\",\n                array: !0,\n                default: [{\n                  value: []\n                }],\n                category: o,\n                description: t(aa || (aa = Pt([`\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    `]))),\n                exception: m => typeof m == \"string\" || typeof m == \"object\",\n                cliName: \"plugin-search-dir\",\n                cliCategory: s\n              },\n              printWidth: {\n                since: \"0.0.0\",\n                category: o,\n                type: \"int\",\n                default: 80,\n                description: \"The line length where Prettier will try wrap.\",\n                range: {\n                  start: 0,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                }\n              },\n              rangeEnd: {\n                since: \"1.4.0\",\n                category: c,\n                type: \"int\",\n                default: Number.POSITIVE_INFINITY,\n                range: {\n                  start: 0,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                },\n                description: t(oa || (oa = Pt([`\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    `]))),\n                cliCategory: a\n              },\n              rangeStart: {\n                since: \"1.4.0\",\n                category: c,\n                type: \"int\",\n                default: 0,\n                range: {\n                  start: 0,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                },\n                description: t(la || (la = Pt([`\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    `]))),\n                cliCategory: a\n              },\n              requirePragma: {\n                since: \"1.7.0\",\n                category: c,\n                type: \"boolean\",\n                default: !1,\n                description: t(ca || (ca = Pt([`\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    `]))),\n                cliCategory: u\n              },\n              tabWidth: {\n                type: \"int\",\n                category: o,\n                default: 2,\n                description: \"Number of spaces per indentation level.\",\n                range: {\n                  start: 0,\n                  end: Number.POSITIVE_INFINITY,\n                  step: 1\n                }\n              },\n              useTabs: {\n                since: \"1.0.0\",\n                category: o,\n                type: \"boolean\",\n                default: !1,\n                description: \"Indent with tabs instead of spaces.\"\n              },\n              embeddedLanguageFormatting: {\n                since: \"2.1.0\",\n                category: o,\n                type: \"choice\",\n                default: [{\n                  since: \"2.1.0\",\n                  value: \"auto\"\n                }],\n                description: \"Control how Prettier formats quoted code embedded in the file.\",\n                choices: [{\n                  value: \"auto\",\n                  description: \"Format embedded code if Prettier can automatically identify it.\"\n                }, {\n                  value: \"off\",\n                  description: \"Never automatically format embedded code.\"\n                }]\n              }\n            };\n          n.exports = {\n            CATEGORY_CONFIG: s,\n            CATEGORY_EDITOR: a,\n            CATEGORY_FORMAT: r,\n            CATEGORY_OTHER: u,\n            CATEGORY_OUTPUT: i,\n            CATEGORY_GLOBAL: o,\n            CATEGORY_SPECIAL: c,\n            options: v\n          };\n        }\n      }),\n      Mn = Z({\n        \"src/main/support.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = {\n              compare: qn(),\n              lt: xD(),\n              gte: bD()\n            },\n            s = TD(),\n            a = ya().version,\n            r = ND().options;\n          function u() {\n            let {\n                plugins: o = [],\n                showUnreleased: c = !1,\n                showDeprecated: v = !1,\n                showInternal: m = !1\n              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n              d = a.split(\"-\", 1)[0],\n              p = o.flatMap(A => A.languages || []).filter(h),\n              f = s(Object.assign({}, ...o.map(A => {\n                let {\n                  options: S\n                } = A;\n                return S;\n              }), r), \"name\").filter(A => h(A) && w(A)).sort((A, S) => A.name === S.name ? 0 : A.name < S.name ? -1 : 1).map(T).map(A => {\n                A = Object.assign({}, A), Array.isArray(A.default) && (A.default = A.default.length === 1 ? A.default[0].value : A.default.filter(h).sort((B, I) => t.compare(I.since, B.since))[0].value), Array.isArray(A.choices) && (A.choices = A.choices.filter(B => h(B) && w(B)), A.name === \"parser\" && i(A, p, o));\n                let S = Object.fromEntries(o.filter(B => B.defaultOptions && B.defaultOptions[A.name] !== void 0).map(B => [B.name, B.defaultOptions[A.name]]));\n                return Object.assign(Object.assign({}, A), {}, {\n                  pluginDefaults: S\n                });\n              });\n            return {\n              languages: p,\n              options: f\n            };\n            function h(A) {\n              return c || !(\"since\" in A) || A.since && t.gte(d, A.since);\n            }\n            function w(A) {\n              return v || !(\"deprecated\" in A) || A.deprecated && t.lt(d, A.deprecated);\n            }\n            function T(A) {\n              if (m) return A;\n              let {\n                cliName: S,\n                cliCategory: B,\n                cliDescription: I\n              } = A;\n              return kn(A, Yf);\n            }\n          }\n          function i(o, c, v) {\n            let m = new Set(o.choices.map(d => d.value));\n            for (let d of c) if (d.parsers) {\n              for (let p of d.parsers) if (!m.has(p)) {\n                m.add(p);\n                let f = v.find(w => w.parsers && w.parsers[p]),\n                  h = d.name;\n                f && f.name && (h += \" (plugin: \".concat(f.name, \")\")), o.choices.push({\n                  value: p,\n                  description: h\n                });\n              }\n            }\n          }\n          n.exports = {\n            getSupportInfo: u\n          };\n        }\n      }),\n      Rn = Z({\n        \"src/utils/is-non-empty-array.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s) {\n            return Array.isArray(s) && s.length > 0;\n          }\n          n.exports = t;\n        }\n      }),\n      Nr = Z({\n        \"src/utils/text/skip.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(i) {\n            return (o, c, v) => {\n              let m = v && v.backwards;\n              if (c === !1) return !1;\n              let {\n                  length: d\n                } = o,\n                p = c;\n              for (; p >= 0 && p < d;) {\n                let f = o.charAt(p);\n                if (i instanceof RegExp) {\n                  if (!i.test(f)) return p;\n                } else if (!i.includes(f)) return p;\n                m ? p-- : p++;\n              }\n              return p === -1 || p === d ? p : !1;\n            };\n          }\n          var s = t(/\\s/),\n            a = t(\" \t\"),\n            r = t(\",; \t\"),\n            u = t(/[^\\n\\r]/);\n          n.exports = {\n            skipWhitespace: s,\n            skipSpaces: a,\n            skipToLineEnd: r,\n            skipEverythingButNewLine: u\n          };\n        }\n      }),\n      Sa = Z({\n        \"src/utils/text/skip-inline-comment.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s, a) {\n            if (a === !1) return !1;\n            if (s.charAt(a) === \"/\" && s.charAt(a + 1) === \"*\") {\n              for (let r = a + 2; r < s.length; ++r) if (s.charAt(r) === \"*\" && s.charAt(r + 1) === \"/\") return r + 2;\n            }\n            return a;\n          }\n          n.exports = t;\n        }\n      }),\n      xa = Z({\n        \"src/utils/text/skip-trailing-comment.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            skipEverythingButNewLine: t\n          } = Nr();\n          function s(a, r) {\n            return r === !1 ? !1 : a.charAt(r) === \"/\" && a.charAt(r + 1) === \"/\" ? t(a, r) : r;\n          }\n          n.exports = s;\n        }\n      }),\n      ba = Z({\n        \"src/utils/text/skip-newline.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s, a, r) {\n            let u = r && r.backwards;\n            if (a === !1) return !1;\n            let i = s.charAt(a);\n            if (u) {\n              if (s.charAt(a - 1) === \"\\r\" && i === `\n`) return a - 2;\n              if (i === `\n` || i === \"\\r\" || i === \"\\u2028\" || i === \"\\u2029\") return a - 1;\n            } else {\n              if (i === \"\\r\" && s.charAt(a + 1) === `\n`) return a + 2;\n              if (i === `\n` || i === \"\\r\" || i === \"\\u2028\" || i === \"\\u2029\") return a + 1;\n            }\n            return a;\n          }\n          n.exports = t;\n        }\n      }),\n      wD = Z({\n        \"src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Sa(),\n            s = ba(),\n            a = xa(),\n            {\n              skipSpaces: r\n            } = Nr();\n          function u(i, o) {\n            let c = null,\n              v = o;\n            for (; v !== c;) c = v, v = r(i, v), v = t(i, v), v = a(i, v), v = s(i, v);\n            return v;\n          }\n          n.exports = u;\n        }\n      }),\n      Ue = Z({\n        \"src/common/util.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              default: t\n            } = (CD(), lt(Ea)),\n            s = it(),\n            {\n              getSupportInfo: a\n            } = Mn(),\n            r = Rn(),\n            u = Ca(),\n            {\n              skipWhitespace: i,\n              skipSpaces: o,\n              skipToLineEnd: c,\n              skipEverythingButNewLine: v\n            } = Nr(),\n            m = Sa(),\n            d = xa(),\n            p = ba(),\n            f = wD(),\n            h = H => H[H.length - 2];\n          function w(H) {\n            return (R, Q, ee) => {\n              let te = ee && ee.backwards;\n              if (Q === !1) return !1;\n              let {\n                  length: oe\n                } = R,\n                W = Q;\n              for (; W >= 0 && W < oe;) {\n                let X = R.charAt(W);\n                if (H instanceof RegExp) {\n                  if (!H.test(X)) return W;\n                } else if (!H.includes(X)) return W;\n                te ? W-- : W++;\n              }\n              return W === -1 || W === oe ? W : !1;\n            };\n          }\n          function T(H, R) {\n            let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n              ee = o(H, Q.backwards ? R - 1 : R, Q),\n              te = p(H, ee, Q);\n            return ee !== te;\n          }\n          function A(H, R, Q) {\n            for (let ee = R; ee < Q; ++ee) if (H.charAt(ee) === `\n`) return !0;\n            return !1;\n          }\n          function S(H, R, Q) {\n            let ee = Q(R) - 1;\n            ee = o(H, ee, {\n              backwards: !0\n            }), ee = p(H, ee, {\n              backwards: !0\n            }), ee = o(H, ee, {\n              backwards: !0\n            });\n            let te = p(H, ee, {\n              backwards: !0\n            });\n            return ee !== te;\n          }\n          function B(H, R) {\n            let Q = null,\n              ee = R;\n            for (; ee !== Q;) Q = ee, ee = c(H, ee), ee = m(H, ee), ee = o(H, ee);\n            return ee = d(H, ee), ee = p(H, ee), ee !== !1 && T(H, ee);\n          }\n          function I(H, R, Q) {\n            return B(H, Q(R));\n          }\n          function k(H, R, Q) {\n            return f(H, Q(R));\n          }\n          function P(H, R, Q) {\n            return H.charAt(k(H, R, Q));\n          }\n          function C(H, R) {\n            let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            return o(H, Q.backwards ? R - 1 : R, Q) !== R;\n          }\n          function D(H, R) {\n            let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n              ee = 0;\n            for (let te = Q; te < H.length; ++te) H[te] === \"\t\" ? ee = ee + R - ee % R : ee++;\n            return ee;\n          }\n          function g(H, R) {\n            let Q = H.lastIndexOf(`\n`);\n            return Q === -1 ? 0 : D(H.slice(Q + 1).match(/^[\\t ]*/)[0], R);\n          }\n          function F(H, R) {\n            let Q = {\n                quote: '\"',\n                regex: /\"/g,\n                escaped: \"&quot;\"\n              },\n              ee = {\n                quote: \"'\",\n                regex: /'/g,\n                escaped: \"&apos;\"\n              },\n              te = R === \"'\" ? ee : Q,\n              oe = te === ee ? Q : ee,\n              W = te;\n            if (H.includes(te.quote) || H.includes(oe.quote)) {\n              let X = (H.match(te.regex) || []).length,\n                ue = (H.match(oe.regex) || []).length;\n              W = X > ue ? oe : te;\n            }\n            return W;\n          }\n          function l(H, R) {\n            let Q = H.slice(1, -1),\n              ee = R.parser === \"json\" || R.parser === \"json5\" && R.quoteProps === \"preserve\" && !R.singleQuote ? '\"' : R.__isInHtmlAttribute ? \"'\" : F(Q, R.singleQuote ? \"'\" : '\"').quote;\n            return E(Q, ee, !(R.parser === \"css\" || R.parser === \"less\" || R.parser === \"scss\" || R.__embeddedInHtml));\n          }\n          function E(H, R, Q) {\n            let ee = R === '\"' ? \"'\" : '\"',\n              te = /\\\\(.)|([\"'])/gs,\n              oe = H.replace(te, (W, X, ue) => X === ee ? X : ue === R ? \"\\\\\" + ue : ue || (Q && /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(X) ? X : \"\\\\\" + X));\n            return R + oe + R;\n          }\n          function y(H) {\n            return H.toLowerCase().replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\").replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\").replace(/^([+-])?\\./, \"$10.\").replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\").replace(/\\.(?=e|$)/, \"\");\n          }\n          function N(H, R) {\n            let Q = H.match(new RegExp(\"(\".concat(t(R), \")+\"), \"g\"));\n            return Q === null ? 0 : Q.reduce((ee, te) => Math.max(ee, te.length / R.length), 0);\n          }\n          function x(H, R) {\n            let Q = H.match(new RegExp(\"(\".concat(t(R), \")+\"), \"g\"));\n            if (Q === null) return 0;\n            let ee = new Map(),\n              te = 0;\n            for (let oe of Q) {\n              let W = oe.length / R.length;\n              ee.set(W, !0), W > te && (te = W);\n            }\n            for (let oe = 1; oe < te; oe++) if (!ee.get(oe)) return oe;\n            return te + 1;\n          }\n          function b(H, R) {\n            (H.comments || (H.comments = [])).push(R), R.printed = !1, R.nodeDescription = Y(H);\n          }\n          function L(H, R) {\n            R.leading = !0, R.trailing = !1, b(H, R);\n          }\n          function M(H, R, Q) {\n            R.leading = !1, R.trailing = !1, Q && (R.marker = Q), b(H, R);\n          }\n          function j(H, R) {\n            R.leading = !1, R.trailing = !0, b(H, R);\n          }\n          function $(H, R) {\n            let {\n                languages: Q\n              } = a({\n                plugins: R.plugins\n              }),\n              ee = Q.find(te => {\n                let {\n                  name: oe\n                } = te;\n                return oe.toLowerCase() === H;\n              }) || Q.find(te => {\n                let {\n                  aliases: oe\n                } = te;\n                return Array.isArray(oe) && oe.includes(H);\n              }) || Q.find(te => {\n                let {\n                  extensions: oe\n                } = te;\n                return Array.isArray(oe) && oe.includes(\".\".concat(H));\n              });\n            return ee && ee.parsers[0];\n          }\n          function V(H) {\n            return H && H.type === \"front-matter\";\n          }\n          function q(H) {\n            let R = new WeakMap();\n            return function (Q) {\n              return R.has(Q) || R.set(Q, Symbol(H)), R.get(Q);\n            };\n          }\n          function Y(H) {\n            let R = H.type || H.kind || \"(unknown type)\",\n              Q = String(H.name || H.id && (typeof H.id == \"object\" ? H.id.name : H.id) || H.key && (typeof H.key == \"object\" ? H.key.name : H.key) || H.value && (typeof H.value == \"object\" ? \"\" : String(H.value)) || H.operator || \"\");\n            return Q.length > 20 && (Q = Q.slice(0, 19) + \"\\u2026\"), R + (Q ? \" \" + Q : \"\");\n          }\n          n.exports = {\n            inferParserByLanguage: $,\n            getStringWidth: u,\n            getMaxContinuousCount: N,\n            getMinNotPresentContinuousCount: x,\n            getPenultimate: h,\n            getLast: s,\n            getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f,\n            getNextNonSpaceNonCommentCharacterIndex: k,\n            getNextNonSpaceNonCommentCharacter: P,\n            skip: w,\n            skipWhitespace: i,\n            skipSpaces: o,\n            skipToLineEnd: c,\n            skipEverythingButNewLine: v,\n            skipInlineComment: m,\n            skipTrailingComment: d,\n            skipNewline: p,\n            isNextLineEmptyAfterIndex: B,\n            isNextLineEmpty: I,\n            isPreviousLineEmpty: S,\n            hasNewline: T,\n            hasNewlineInRange: A,\n            hasSpaces: C,\n            getAlignmentSize: D,\n            getIndentSize: g,\n            getPreferredQuote: F,\n            printString: l,\n            printNumber: y,\n            makeString: E,\n            addLeadingComment: L,\n            addDanglingComment: M,\n            addTrailingComment: j,\n            isFrontMatterNode: V,\n            isNonEmptyArray: r,\n            createGroupIdMapper: q\n          };\n        }\n      }),\n      Ta = {};\n    Ut(Ta, {\n      basename: () => Pa,\n      default: () => Ia,\n      delimiter: () => Bn,\n      dirname: () => _a,\n      extname: () => ka,\n      isAbsolute: () => Wn,\n      join: () => Na,\n      normalize: () => Vn,\n      relative: () => wa,\n      resolve: () => Tr,\n      sep: () => Tn\n    });\n    function Ba(e, n) {\n      for (var t = 0, s = e.length - 1; s >= 0; s--) {\n        var a = e[s];\n        a === \".\" ? e.splice(s, 1) : a === \"..\" ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);\n      }\n      if (n) for (; t--; t) e.unshift(\"..\");\n      return e;\n    }\n    function Tr() {\n      for (var e = \"\", n = !1, t = arguments.length - 1; t >= -1 && !n; t--) {\n        var s = t >= 0 ? arguments[t] : \"/\";\n        if (typeof s != \"string\") throw new TypeError(\"Arguments to path.resolve must be strings\");\n        if (!s) continue;\n        e = s + \"/\" + e, n = s.charAt(0) === \"/\";\n      }\n      return e = Ba($n(e.split(\"/\"), function (a) {\n        return !!a;\n      }), !n).join(\"/\"), (n ? \"/\" : \"\") + e || \".\";\n    }\n    function Vn(e) {\n      var n = Wn(e),\n        t = La(e, -1) === \"/\";\n      return e = Ba($n(e.split(\"/\"), function (s) {\n        return !!s;\n      }), !n).join(\"/\"), !e && !n && (e = \".\"), e && t && (e += \"/\"), (n ? \"/\" : \"\") + e;\n    }\n    function Wn(e) {\n      return e.charAt(0) === \"/\";\n    }\n    function Na() {\n      var e = Array.prototype.slice.call(arguments, 0);\n      return Vn($n(e, function (n, t) {\n        if (typeof n != \"string\") throw new TypeError(\"Arguments to path.join must be strings\");\n        return n;\n      }).join(\"/\"));\n    }\n    function wa(e, n) {\n      e = Tr(e).substr(1), n = Tr(n).substr(1);\n      function t(c) {\n        for (var v = 0; v < c.length && c[v] === \"\"; v++);\n        for (var m = c.length - 1; m >= 0 && c[m] === \"\"; m--);\n        return v > m ? [] : c.slice(v, m - v + 1);\n      }\n      for (var s = t(e.split(\"/\")), a = t(n.split(\"/\")), r = Math.min(s.length, a.length), u = r, i = 0; i < r; i++) if (s[i] !== a[i]) {\n        u = i;\n        break;\n      }\n      for (var o = [], i = u; i < s.length; i++) o.push(\"..\");\n      return o = o.concat(a.slice(u)), o.join(\"/\");\n    }\n    function _a(e) {\n      var n = wr(e),\n        t = n[0],\n        s = n[1];\n      return !t && !s ? \".\" : (s && (s = s.substr(0, s.length - 1)), t + s);\n    }\n    function Pa(e, n) {\n      var t = wr(e)[2];\n      return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;\n    }\n    function ka(e) {\n      return wr(e)[3];\n    }\n    function $n(e, n) {\n      if (e.filter) return e.filter(n);\n      for (var t = [], s = 0; s < e.length; s++) n(e[s], s, e) && t.push(e[s]);\n      return t;\n    }\n    var Da,\n      wr,\n      Tn,\n      Bn,\n      Ia,\n      La,\n      _D = mt({\n        \"node-modules-polyfills:path\"() {\n          re(), Da = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/, wr = function (e) {\n            return Da.exec(e).slice(1);\n          }, Tn = \"/\", Bn = \":\", Ia = {\n            extname: ka,\n            basename: Pa,\n            dirname: _a,\n            sep: Tn,\n            delimiter: Bn,\n            relative: wa,\n            join: Na,\n            isAbsolute: Wn,\n            normalize: Vn,\n            resolve: Tr\n          }, La =  true ? function (e, n, t) {\n            return e.substr(n, t);\n          } : 0;\n        }\n      }),\n      PD = Z({\n        \"node-modules-polyfills-commonjs:path\"(e, n) {\n          re();\n          var t = (_D(), lt(Ta));\n          if (t && t.default) {\n            n.exports = t.default;\n            for (let s in t) n.exports[s] = t[s];\n          } else t && (n.exports = t);\n        }\n      }),\n      zt = Z({\n        \"src/common/errors.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = class extends Error {},\n            s = class extends Error {},\n            a = class extends Error {},\n            r = class extends Error {};\n          n.exports = {\n            ConfigError: t,\n            DebugError: s,\n            UndefinedParserError: a,\n            ArgExpansionBailout: r\n          };\n        }\n      }),\n      dt = {};\n    Ut(dt, {\n      __assign: () => br,\n      __asyncDelegator: () => GD,\n      __asyncGenerator: () => HD,\n      __asyncValues: () => JD,\n      __await: () => Jt,\n      __awaiter: () => qD,\n      __classPrivateFieldGet: () => KD,\n      __classPrivateFieldSet: () => YD,\n      __createBinding: () => RD,\n      __decorate: () => LD,\n      __exportStar: () => VD,\n      __extends: () => kD,\n      __generator: () => MD,\n      __importDefault: () => XD,\n      __importStar: () => zD,\n      __makeTemplateObject: () => UD,\n      __metadata: () => OD,\n      __param: () => jD,\n      __read: () => ja,\n      __rest: () => ID,\n      __spread: () => WD,\n      __spreadArrays: () => $D,\n      __values: () => Nn\n    });\n    function kD(e, n) {\n      xr(e, n);\n      function t() {\n        this.constructor = e;\n      }\n      e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());\n    }\n    function ID(e, n) {\n      var t = {};\n      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && n.indexOf(s) < 0 && (t[s] = e[s]);\n      if (e != null && typeof Object.getOwnPropertySymbols == \"function\") for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++) n.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);\n      return t;\n    }\n    function LD(e, n, t, s) {\n      var a = arguments.length,\n        r = a < 3 ? n : s === null ? s = Object.getOwnPropertyDescriptor(n, t) : s,\n        u;\n      if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\") r = Reflect.decorate(e, n, t, s);else for (var i = e.length - 1; i >= 0; i--) (u = e[i]) && (r = (a < 3 ? u(r) : a > 3 ? u(n, t, r) : u(n, t)) || r);\n      return a > 3 && r && Object.defineProperty(n, t, r), r;\n    }\n    function jD(e, n) {\n      return function (t, s) {\n        n(t, s, e);\n      };\n    }\n    function OD(e, n) {\n      if (typeof Reflect == \"object\" && typeof Reflect.metadata == \"function\") return Reflect.metadata(e, n);\n    }\n    function qD(e, n, t, s) {\n      function a(r) {\n        return r instanceof t ? r : new t(function (u) {\n          u(r);\n        });\n      }\n      return new (t || (t = Promise))(function (r, u) {\n        function i(v) {\n          try {\n            c(s.next(v));\n          } catch (m) {\n            u(m);\n          }\n        }\n        function o(v) {\n          try {\n            c(s.throw(v));\n          } catch (m) {\n            u(m);\n          }\n        }\n        function c(v) {\n          v.done ? r(v.value) : a(v.value).then(i, o);\n        }\n        c((s = s.apply(e, n || [])).next());\n      });\n    }\n    function MD(e, n) {\n      var t = {\n          label: 0,\n          sent: function () {\n            if (r[0] & 1) throw r[1];\n            return r[1];\n          },\n          trys: [],\n          ops: []\n        },\n        s,\n        a,\n        r,\n        u;\n      return u = {\n        next: i(0),\n        throw: i(1),\n        return: i(2)\n      }, typeof Symbol == \"function\" && (u[Symbol.iterator] = function () {\n        return this;\n      }), u;\n      function i(c) {\n        return function (v) {\n          return o([c, v]);\n        };\n      }\n      function o(c) {\n        if (s) throw new TypeError(\"Generator is already executing.\");\n        for (; t;) try {\n          if (s = 1, a && (r = c[0] & 2 ? a.return : c[0] ? a.throw || ((r = a.return) && r.call(a), 0) : a.next) && !(r = r.call(a, c[1])).done) return r;\n          switch (a = 0, r && (c = [c[0] & 2, r.value]), c[0]) {\n            case 0:\n            case 1:\n              r = c;\n              break;\n            case 4:\n              return t.label++, {\n                value: c[1],\n                done: !1\n              };\n            case 5:\n              t.label++, a = c[1], c = [0];\n              continue;\n            case 7:\n              c = t.ops.pop(), t.trys.pop();\n              continue;\n            default:\n              if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {\n                t = 0;\n                continue;\n              }\n              if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {\n                t.label = c[1];\n                break;\n              }\n              if (c[0] === 6 && t.label < r[1]) {\n                t.label = r[1], r = c;\n                break;\n              }\n              if (r && t.label < r[2]) {\n                t.label = r[2], t.ops.push(c);\n                break;\n              }\n              r[2] && t.ops.pop(), t.trys.pop();\n              continue;\n          }\n          c = n.call(e, t);\n        } catch (v) {\n          c = [6, v], a = 0;\n        } finally {\n          s = r = 0;\n        }\n        if (c[0] & 5) throw c[1];\n        return {\n          value: c[0] ? c[1] : void 0,\n          done: !0\n        };\n      }\n    }\n    function RD(e, n, t, s) {\n      s === void 0 && (s = t), e[s] = n[t];\n    }\n    function VD(e, n) {\n      for (var t in e) t !== \"default\" && !n.hasOwnProperty(t) && (n[t] = e[t]);\n    }\n    function Nn(e) {\n      var n = typeof Symbol == \"function\" && Symbol.iterator,\n        t = n && e[n],\n        s = 0;\n      if (t) return t.call(e);\n      if (e && typeof e.length == \"number\") return {\n        next: function () {\n          return e && s >= e.length && (e = void 0), {\n            value: e && e[s++],\n            done: !e\n          };\n        }\n      };\n      throw new TypeError(n ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    }\n    function ja(e, n) {\n      var t = typeof Symbol == \"function\" && e[Symbol.iterator];\n      if (!t) return e;\n      var s = t.call(e),\n        a,\n        r = [],\n        u;\n      try {\n        for (; (n === void 0 || n-- > 0) && !(a = s.next()).done;) r.push(a.value);\n      } catch (i) {\n        u = {\n          error: i\n        };\n      } finally {\n        try {\n          a && !a.done && (t = s.return) && t.call(s);\n        } finally {\n          if (u) throw u.error;\n        }\n      }\n      return r;\n    }\n    function WD() {\n      for (var e = [], n = 0; n < arguments.length; n++) e = e.concat(ja(arguments[n]));\n      return e;\n    }\n    function $D() {\n      for (var e = 0, n = 0, t = arguments.length; n < t; n++) e += arguments[n].length;\n      for (var s = Array(e), a = 0, n = 0; n < t; n++) for (var r = arguments[n], u = 0, i = r.length; u < i; u++, a++) s[a] = r[u];\n      return s;\n    }\n    function Jt(e) {\n      return this instanceof Jt ? (this.v = e, this) : new Jt(e);\n    }\n    function HD(e, n, t) {\n      if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var s = t.apply(e, n || []),\n        a,\n        r = [];\n      return a = {}, u(\"next\"), u(\"throw\"), u(\"return\"), a[Symbol.asyncIterator] = function () {\n        return this;\n      }, a;\n      function u(d) {\n        s[d] && (a[d] = function (p) {\n          return new Promise(function (f, h) {\n            r.push([d, p, f, h]) > 1 || i(d, p);\n          });\n        });\n      }\n      function i(d, p) {\n        try {\n          o(s[d](p));\n        } catch (f) {\n          m(r[0][3], f);\n        }\n      }\n      function o(d) {\n        d.value instanceof Jt ? Promise.resolve(d.value.v).then(c, v) : m(r[0][2], d);\n      }\n      function c(d) {\n        i(\"next\", d);\n      }\n      function v(d) {\n        i(\"throw\", d);\n      }\n      function m(d, p) {\n        d(p), r.shift(), r.length && i(r[0][0], r[0][1]);\n      }\n    }\n    function GD(e) {\n      var n, t;\n      return n = {}, s(\"next\"), s(\"throw\", function (a) {\n        throw a;\n      }), s(\"return\"), n[Symbol.iterator] = function () {\n        return this;\n      }, n;\n      function s(a, r) {\n        n[a] = e[a] ? function (u) {\n          return (t = !t) ? {\n            value: Jt(e[a](u)),\n            done: a === \"return\"\n          } : r ? r(u) : u;\n        } : r;\n      }\n    }\n    function JD(e) {\n      if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var n = e[Symbol.asyncIterator],\n        t;\n      return n ? n.call(e) : (e = typeof Nn == \"function\" ? Nn(e) : e[Symbol.iterator](), t = {}, s(\"next\"), s(\"throw\"), s(\"return\"), t[Symbol.asyncIterator] = function () {\n        return this;\n      }, t);\n      function s(r) {\n        t[r] = e[r] && function (u) {\n          return new Promise(function (i, o) {\n            u = e[r](u), a(i, o, u.done, u.value);\n          });\n        };\n      }\n      function a(r, u, i, o) {\n        Promise.resolve(o).then(function (c) {\n          r({\n            value: c,\n            done: i\n          });\n        }, u);\n      }\n    }\n    function UD(e, n) {\n      return Object.defineProperty ? Object.defineProperty(e, \"raw\", {\n        value: n\n      }) : e.raw = n, e;\n    }\n    function zD(e) {\n      if (e && e.__esModule) return e;\n      var n = {};\n      if (e != null) for (var t in e) Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);\n      return n.default = e, n;\n    }\n    function XD(e) {\n      return e && e.__esModule ? e : {\n        default: e\n      };\n    }\n    function KD(e, n) {\n      if (!n.has(e)) throw new TypeError(\"attempted to get private field on non-instance\");\n      return n.get(e);\n    }\n    function YD(e, n, t) {\n      if (!n.has(e)) throw new TypeError(\"attempted to set private field on non-instance\");\n      return n.set(e, t), t;\n    }\n    var xr,\n      br,\n      ht = mt({\n        \"node_modules/tslib/tslib.es6.js\"() {\n          re(), xr = function (e, n) {\n            return xr = Object.setPrototypeOf || {\n              __proto__: []\n            } instanceof Array && function (t, s) {\n              t.__proto__ = s;\n            } || function (t, s) {\n              for (var a in s) s.hasOwnProperty(a) && (t[a] = s[a]);\n            }, xr(e, n);\n          }, br = function () {\n            return br = Object.assign || function (n) {\n              for (var t, s = 1, a = arguments.length; s < a; s++) {\n                t = arguments[s];\n                for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);\n              }\n              return n;\n            }, br.apply(this, arguments);\n          };\n        }\n      }),\n      Oa = Z({\n        \"node_modules/vnopts/lib/descriptors/api.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.apiDescriptor = {\n            key: n => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n),\n            value(n) {\n              if (n === null || typeof n != \"object\") return JSON.stringify(n);\n              if (Array.isArray(n)) return \"[\".concat(n.map(s => e.apiDescriptor.value(s)).join(\", \"), \"]\");\n              let t = Object.keys(n);\n              return t.length === 0 ? \"{}\" : \"{ \".concat(t.map(s => \"\".concat(e.apiDescriptor.key(s), \": \").concat(e.apiDescriptor.value(n[s]))).join(\", \"), \" }\");\n            },\n            pair: n => {\n              let {\n                key: t,\n                value: s\n              } = n;\n              return e.apiDescriptor.value({\n                [t]: s\n              });\n            }\n          };\n        }\n      }),\n      QD = Z({\n        \"node_modules/vnopts/lib/descriptors/index.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = (ht(), lt(dt));\n          n.__exportStar(Oa(), e);\n        }\n      }),\n      _r = Z({\n        \"scripts/build/shims/chalk.cjs\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = s => s;\n          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;\n        }\n      }),\n      qa = Z({\n        \"node_modules/vnopts/lib/handlers/deprecated/common.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = _r();\n          e.commonDeprecatedHandler = (t, s, a) => {\n            let {\n                descriptor: r\n              } = a,\n              u = [\"\".concat(n.default.yellow(typeof t == \"string\" ? r.key(t) : r.pair(t)), \" is deprecated\")];\n            return s && u.push(\"we now treat it as \".concat(n.default.blue(typeof s == \"string\" ? r.key(s) : r.pair(s)))), u.join(\"; \") + \".\";\n          };\n        }\n      }),\n      ZD = Z({\n        \"node_modules/vnopts/lib/handlers/deprecated/index.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = (ht(), lt(dt));\n          n.__exportStar(qa(), e);\n        }\n      }),\n      em = Z({\n        \"node_modules/vnopts/lib/handlers/invalid/common.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = _r();\n          e.commonInvalidHandler = (t, s, a) => [\"Invalid \".concat(n.default.red(a.descriptor.key(t)), \" value.\"), \"Expected \".concat(n.default.blue(a.schemas[t].expected(a)), \",\"), \"but received \".concat(n.default.red(a.descriptor.value(s)), \".\")].join(\" \");\n        }\n      }),\n      Ma = Z({\n        \"node_modules/vnopts/lib/handlers/invalid/index.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = (ht(), lt(dt));\n          n.__exportStar(em(), e);\n        }\n      }),\n      tm = Z({\n        \"node_modules/vnopts/node_modules/leven/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = [],\n            s = [];\n          n.exports = function (a, r) {\n            if (a === r) return 0;\n            var u = a;\n            a.length > r.length && (a = r, r = u);\n            var i = a.length,\n              o = r.length;\n            if (i === 0) return o;\n            if (o === 0) return i;\n            for (; i > 0 && a.charCodeAt(~-i) === r.charCodeAt(~-o);) i--, o--;\n            if (i === 0) return o;\n            for (var c = 0; c < i && a.charCodeAt(c) === r.charCodeAt(c);) c++;\n            if (i -= c, o -= c, i === 0) return o;\n            for (var v, m, d, p, f = 0, h = 0; f < i;) s[c + f] = a.charCodeAt(c + f), t[f] = ++f;\n            for (; h < o;) for (v = r.charCodeAt(c + h), d = h++, m = h, f = 0; f < i; f++) p = v === s[c + f] ? d : d + 1, d = t[f], m = t[f] = d > m ? p > m ? m + 1 : p : p > d ? d + 1 : p;\n            return m;\n          };\n        }\n      }),\n      Ra = Z({\n        \"node_modules/vnopts/lib/handlers/unknown/leven.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = _r(),\n            t = tm();\n          e.levenUnknownHandler = (s, a, r) => {\n            let {\n                descriptor: u,\n                logger: i,\n                schemas: o\n              } = r,\n              c = [\"Ignored unknown option \".concat(n.default.yellow(u.pair({\n                key: s,\n                value: a\n              })), \".\")],\n              v = Object.keys(o).sort().find(m => t(s, m) < 3);\n            v && c.push(\"Did you mean \".concat(n.default.blue(u.key(v)), \"?\")), i.warn(c.join(\" \"));\n          };\n        }\n      }),\n      rm = Z({\n        \"node_modules/vnopts/lib/handlers/unknown/index.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = (ht(), lt(dt));\n          n.__exportStar(Ra(), e);\n        }\n      }),\n      nm = Z({\n        \"node_modules/vnopts/lib/handlers/index.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = (ht(), lt(dt));\n          n.__exportStar(ZD(), e), n.__exportStar(Ma(), e), n.__exportStar(rm(), e);\n        }\n      }),\n      vt = Z({\n        \"node_modules/vnopts/lib/schema.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = [\"default\", \"expected\", \"validate\", \"deprecated\", \"forward\", \"redirect\", \"overlap\", \"preprocess\", \"postprocess\"];\n          function t(r, u) {\n            let i = new r(u),\n              o = Object.create(i);\n            for (let c of n) c in u && (o[c] = a(u[c], i, s.prototype[c].length));\n            return o;\n          }\n          e.createSchema = t;\n          var s = class {\n            constructor(r) {\n              this.name = r.name;\n            }\n            static create(r) {\n              return t(this, r);\n            }\n            default(r) {}\n            expected(r) {\n              return \"nothing\";\n            }\n            validate(r, u) {\n              return !1;\n            }\n            deprecated(r, u) {\n              return !1;\n            }\n            forward(r, u) {}\n            redirect(r, u) {}\n            overlap(r, u, i) {\n              return r;\n            }\n            preprocess(r, u) {\n              return r;\n            }\n            postprocess(r, u) {\n              return r;\n            }\n          };\n          e.Schema = s;\n          function a(r, u, i) {\n            return typeof r == \"function\" ? function () {\n              for (var o = arguments.length, c = new Array(o), v = 0; v < o; v++) c[v] = arguments[v];\n              return r(...c.slice(0, i - 1), u, ...c.slice(i - 1));\n            } : () => r;\n          }\n        }\n      }),\n      um = Z({\n        \"node_modules/vnopts/lib/schemas/alias.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = vt(),\n            t = class extends n.Schema {\n              constructor(s) {\n                super(s), this._sourceName = s.sourceName;\n              }\n              expected(s) {\n                return s.schemas[this._sourceName].expected(s);\n              }\n              validate(s, a) {\n                return a.schemas[this._sourceName].validate(s, a);\n              }\n              redirect(s, a) {\n                return this._sourceName;\n              }\n            };\n          e.AliasSchema = t;\n        }\n      }),\n      sm = Z({\n        \"node_modules/vnopts/lib/schemas/any.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = vt(),\n            t = class extends n.Schema {\n              expected() {\n                return \"anything\";\n              }\n              validate() {\n                return !0;\n              }\n            };\n          e.AnySchema = t;\n        }\n      }),\n      im = Z({\n        \"node_modules/vnopts/lib/schemas/array.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = (ht(), lt(dt)),\n            t = vt(),\n            s = class extends t.Schema {\n              constructor(r) {\n                var {\n                    valueSchema: u,\n                    name: i = u.name\n                  } = r,\n                  o = n.__rest(r, [\"valueSchema\", \"name\"]);\n                super(Object.assign({}, o, {\n                  name: i\n                })), this._valueSchema = u;\n              }\n              expected(r) {\n                return \"an array of \".concat(this._valueSchema.expected(r));\n              }\n              validate(r, u) {\n                if (!Array.isArray(r)) return !1;\n                let i = [];\n                for (let o of r) {\n                  let c = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);\n                  c !== !0 && i.push(c.value);\n                }\n                return i.length === 0 ? !0 : {\n                  value: i\n                };\n              }\n              deprecated(r, u) {\n                let i = [];\n                for (let o of r) {\n                  let c = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);\n                  c !== !1 && i.push(...c.map(v => {\n                    let {\n                      value: m\n                    } = v;\n                    return {\n                      value: [m]\n                    };\n                  }));\n                }\n                return i;\n              }\n              forward(r, u) {\n                let i = [];\n                for (let o of r) {\n                  let c = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);\n                  i.push(...c.map(a));\n                }\n                return i;\n              }\n              redirect(r, u) {\n                let i = [],\n                  o = [];\n                for (let c of r) {\n                  let v = u.normalizeRedirectResult(this._valueSchema.redirect(c, u), c);\n                  \"remain\" in v && i.push(v.remain), o.push(...v.redirect.map(a));\n                }\n                return i.length === 0 ? {\n                  redirect: o\n                } : {\n                  redirect: o,\n                  remain: i\n                };\n              }\n              overlap(r, u) {\n                return r.concat(u);\n              }\n            };\n          e.ArraySchema = s;\n          function a(r) {\n            let {\n              from: u,\n              to: i\n            } = r;\n            return {\n              from: [u],\n              to: i\n            };\n          }\n        }\n      }),\n      am = Z({\n        \"node_modules/vnopts/lib/schemas/boolean.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = vt(),\n            t = class extends n.Schema {\n              expected() {\n                return \"true or false\";\n              }\n              validate(s) {\n                return typeof s == \"boolean\";\n              }\n            };\n          e.BooleanSchema = t;\n        }\n      }),\n      Hn = Z({\n        \"node_modules/vnopts/lib/utils.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          function n(p, f) {\n            let h = Object.create(null);\n            for (let w of p) {\n              let T = w[f];\n              if (h[T]) throw new Error(\"Duplicate \".concat(f, \" \").concat(JSON.stringify(T)));\n              h[T] = w;\n            }\n            return h;\n          }\n          e.recordFromArray = n;\n          function t(p, f) {\n            let h = new Map();\n            for (let w of p) {\n              let T = w[f];\n              if (h.has(T)) throw new Error(\"Duplicate \".concat(f, \" \").concat(JSON.stringify(T)));\n              h.set(T, w);\n            }\n            return h;\n          }\n          e.mapFromArray = t;\n          function s() {\n            let p = Object.create(null);\n            return f => {\n              let h = JSON.stringify(f);\n              return p[h] ? !0 : (p[h] = !0, !1);\n            };\n          }\n          e.createAutoChecklist = s;\n          function a(p, f) {\n            let h = [],\n              w = [];\n            for (let T of p) f(T) ? h.push(T) : w.push(T);\n            return [h, w];\n          }\n          e.partition = a;\n          function r(p) {\n            return p === Math.floor(p);\n          }\n          e.isInt = r;\n          function u(p, f) {\n            if (p === f) return 0;\n            let h = typeof p,\n              w = typeof f,\n              T = [\"undefined\", \"object\", \"boolean\", \"number\", \"string\"];\n            return h !== w ? T.indexOf(h) - T.indexOf(w) : h !== \"string\" ? Number(p) - Number(f) : p.localeCompare(f);\n          }\n          e.comparePrimitive = u;\n          function i(p) {\n            return p === void 0 ? {} : p;\n          }\n          e.normalizeDefaultResult = i;\n          function o(p, f) {\n            return p === !0 ? !0 : p === !1 ? {\n              value: f\n            } : p;\n          }\n          e.normalizeValidateResult = o;\n          function c(p, f) {\n            let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n            return p === !1 ? !1 : p === !0 ? h ? !0 : [{\n              value: f\n            }] : \"value\" in p ? [p] : p.length === 0 ? !1 : p;\n          }\n          e.normalizeDeprecatedResult = c;\n          function v(p, f) {\n            return typeof p == \"string\" || \"key\" in p ? {\n              from: f,\n              to: p\n            } : \"from\" in p ? {\n              from: p.from,\n              to: p.to\n            } : {\n              from: f,\n              to: p.to\n            };\n          }\n          e.normalizeTransferResult = v;\n          function m(p, f) {\n            return p === void 0 ? [] : Array.isArray(p) ? p.map(h => v(h, f)) : [v(p, f)];\n          }\n          e.normalizeForwardResult = m;\n          function d(p, f) {\n            let h = m(typeof p == \"object\" && \"redirect\" in p ? p.redirect : p, f);\n            return h.length === 0 ? {\n              remain: f,\n              redirect: h\n            } : typeof p == \"object\" && \"remain\" in p ? {\n              remain: p.remain,\n              redirect: h\n            } : {\n              redirect: h\n            };\n          }\n          e.normalizeRedirectResult = d;\n        }\n      }),\n      om = Z({\n        \"node_modules/vnopts/lib/schemas/choice.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = vt(),\n            t = Hn(),\n            s = class extends n.Schema {\n              constructor(a) {\n                super(a), this._choices = t.mapFromArray(a.choices.map(r => r && typeof r == \"object\" ? r : {\n                  value: r\n                }), \"value\");\n              }\n              expected(a) {\n                let {\n                    descriptor: r\n                  } = a,\n                  u = Array.from(this._choices.keys()).map(c => this._choices.get(c)).filter(c => !c.deprecated).map(c => c.value).sort(t.comparePrimitive).map(r.value),\n                  i = u.slice(0, -2),\n                  o = u.slice(-2);\n                return i.concat(o.join(\" or \")).join(\", \");\n              }\n              validate(a) {\n                return this._choices.has(a);\n              }\n              deprecated(a) {\n                let r = this._choices.get(a);\n                return r && r.deprecated ? {\n                  value: a\n                } : !1;\n              }\n              forward(a) {\n                let r = this._choices.get(a);\n                return r ? r.forward : void 0;\n              }\n              redirect(a) {\n                let r = this._choices.get(a);\n                return r ? r.redirect : void 0;\n              }\n            };\n          e.ChoiceSchema = s;\n        }\n      }),\n      Va = Z({\n        \"node_modules/vnopts/lib/schemas/number.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = vt(),\n            t = class extends n.Schema {\n              expected() {\n                return \"a number\";\n              }\n              validate(s, a) {\n                return typeof s == \"number\";\n              }\n            };\n          e.NumberSchema = t;\n        }\n      }),\n      lm = Z({\n        \"node_modules/vnopts/lib/schemas/integer.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = Hn(),\n            t = Va(),\n            s = class extends t.NumberSchema {\n              expected() {\n                return \"an integer\";\n              }\n              validate(a, r) {\n                return r.normalizeValidateResult(super.validate(a, r), a) === !0 && n.isInt(a);\n              }\n            };\n          e.IntegerSchema = s;\n        }\n      }),\n      cm = Z({\n        \"node_modules/vnopts/lib/schemas/string.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = vt(),\n            t = class extends n.Schema {\n              expected() {\n                return \"a string\";\n              }\n              validate(s) {\n                return typeof s == \"string\";\n              }\n            };\n          e.StringSchema = t;\n        }\n      }),\n      pm = Z({\n        \"node_modules/vnopts/lib/schemas/index.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = (ht(), lt(dt));\n          n.__exportStar(um(), e), n.__exportStar(sm(), e), n.__exportStar(im(), e), n.__exportStar(am(), e), n.__exportStar(om(), e), n.__exportStar(lm(), e), n.__exportStar(Va(), e), n.__exportStar(cm(), e);\n        }\n      }),\n      fm = Z({\n        \"node_modules/vnopts/lib/defaults.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = Oa(),\n            t = qa(),\n            s = Ma(),\n            a = Ra();\n          e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;\n        }\n      }),\n      Dm = Z({\n        \"node_modules/vnopts/lib/normalize.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = fm(),\n            t = Hn();\n          e.normalize = (a, r, u) => new s(r, u).normalize(a);\n          var s = class {\n            constructor(a, r) {\n              let {\n                logger: u = console,\n                descriptor: i = n.defaultDescriptor,\n                unknown: o = n.defaultUnknownHandler,\n                invalid: c = n.defaultInvalidHandler,\n                deprecated: v = n.defaultDeprecatedHandler\n              } = r || {};\n              this._utils = {\n                descriptor: i,\n                logger: u || {\n                  warn: () => {}\n                },\n                schemas: t.recordFromArray(a, \"name\"),\n                normalizeDefaultResult: t.normalizeDefaultResult,\n                normalizeDeprecatedResult: t.normalizeDeprecatedResult,\n                normalizeForwardResult: t.normalizeForwardResult,\n                normalizeRedirectResult: t.normalizeRedirectResult,\n                normalizeValidateResult: t.normalizeValidateResult\n              }, this._unknownHandler = o, this._invalidHandler = c, this._deprecatedHandler = v, this.cleanHistory();\n            }\n            cleanHistory() {\n              this._hasDeprecationWarned = t.createAutoChecklist();\n            }\n            normalize(a) {\n              let r = {},\n                u = [a],\n                i = () => {\n                  for (; u.length !== 0;) {\n                    let o = u.shift(),\n                      c = this._applyNormalization(o, r);\n                    u.push(...c);\n                  }\n                };\n              i();\n              for (let o of Object.keys(this._utils.schemas)) {\n                let c = this._utils.schemas[o];\n                if (!(o in r)) {\n                  let v = t.normalizeDefaultResult(c.default(this._utils));\n                  \"value\" in v && u.push({\n                    [o]: v.value\n                  });\n                }\n              }\n              i();\n              for (let o of Object.keys(this._utils.schemas)) {\n                let c = this._utils.schemas[o];\n                o in r && (r[o] = c.postprocess(r[o], this._utils));\n              }\n              return r;\n            }\n            _applyNormalization(a, r) {\n              let u = [],\n                [i, o] = t.partition(Object.keys(a), c => c in this._utils.schemas);\n              for (let c of i) {\n                let v = this._utils.schemas[c],\n                  m = v.preprocess(a[c], this._utils),\n                  d = t.normalizeValidateResult(v.validate(m, this._utils), m);\n                if (d !== !0) {\n                  let {\n                      value: T\n                    } = d,\n                    A = this._invalidHandler(c, T, this._utils);\n                  throw typeof A == \"string\" ? new Error(A) : A;\n                }\n                let p = T => {\n                    let {\n                      from: A,\n                      to: S\n                    } = T;\n                    u.push(typeof S == \"string\" ? {\n                      [S]: A\n                    } : {\n                      [S.key]: S.value\n                    });\n                  },\n                  f = T => {\n                    let {\n                        value: A,\n                        redirectTo: S\n                      } = T,\n                      B = t.normalizeDeprecatedResult(v.deprecated(A, this._utils), m, !0);\n                    if (B !== !1) if (B === !0) this._hasDeprecationWarned(c) || this._utils.logger.warn(this._deprecatedHandler(c, S, this._utils));else for (let {\n                      value: I\n                    } of B) {\n                      let k = {\n                        key: c,\n                        value: I\n                      };\n                      if (!this._hasDeprecationWarned(k)) {\n                        let P = typeof S == \"string\" ? {\n                          key: S,\n                          value: I\n                        } : S;\n                        this._utils.logger.warn(this._deprecatedHandler(k, P, this._utils));\n                      }\n                    }\n                  };\n                t.normalizeForwardResult(v.forward(m, this._utils), m).forEach(p);\n                let w = t.normalizeRedirectResult(v.redirect(m, this._utils), m);\n                if (w.redirect.forEach(p), \"remain\" in w) {\n                  let T = w.remain;\n                  r[c] = c in r ? v.overlap(r[c], T, this._utils) : T, f({\n                    value: T\n                  });\n                }\n                for (let {\n                  from: T,\n                  to: A\n                } of w.redirect) f({\n                  value: T,\n                  redirectTo: A\n                });\n              }\n              for (let c of o) {\n                let v = a[c],\n                  m = this._unknownHandler(c, v, this._utils);\n                if (m) for (let d of Object.keys(m)) {\n                  let p = {\n                    [d]: m[d]\n                  };\n                  d in this._utils.schemas ? u.push(p) : Object.assign(r, p);\n                }\n              }\n              return u;\n            }\n          };\n          e.Normalizer = s;\n        }\n      }),\n      mm = Z({\n        \"node_modules/vnopts/lib/index.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = (ht(), lt(dt));\n          n.__exportStar(QD(), e), n.__exportStar(nm(), e), n.__exportStar(pm(), e), n.__exportStar(Dm(), e), n.__exportStar(vt(), e);\n        }\n      }),\n      dm = Z({\n        \"src/main/options-normalizer.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = mm(),\n            s = it(),\n            a = {\n              key: d => d.length === 1 ? \"-\".concat(d) : \"--\".concat(d),\n              value: d => t.apiDescriptor.value(d),\n              pair: d => {\n                let {\n                  key: p,\n                  value: f\n                } = d;\n                return f === !1 ? \"--no-\".concat(p) : f === !0 ? a.key(p) : f === \"\" ? \"\".concat(a.key(p), \" without an argument\") : \"\".concat(a.key(p), \"=\").concat(f);\n              }\n            },\n            r = d => {\n              let {\n                colorsModule: p,\n                levenshteinDistance: f\n              } = d;\n              return class extends t.ChoiceSchema {\n                constructor(w) {\n                  let {\n                    name: T,\n                    flags: A\n                  } = w;\n                  super({\n                    name: T,\n                    choices: A\n                  }), this._flags = [...A].sort();\n                }\n                preprocess(w, T) {\n                  if (typeof w == \"string\" && w.length > 0 && !this._flags.includes(w)) {\n                    let A = this._flags.find(S => f(S, w) < 3);\n                    if (A) return T.logger.warn([\"Unknown flag \".concat(p.yellow(T.descriptor.value(w)), \",\"), \"did you mean \".concat(p.blue(T.descriptor.value(A)), \"?\")].join(\" \")), A;\n                  }\n                  return w;\n                }\n                expected() {\n                  return \"a flag\";\n                }\n              };\n            },\n            u;\n          function i(d, p) {\n            let {\n                logger: f = !1,\n                isCLI: h = !1,\n                passThrough: w = !1,\n                colorsModule: T = null,\n                levenshteinDistance: A = null\n              } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n              S = w ? Array.isArray(w) ? (D, g) => w.includes(D) ? {\n                [D]: g\n              } : void 0 : (D, g) => ({\n                [D]: g\n              }) : (D, g, F) => {\n                let l = F.schemas,\n                  {\n                    _: E\n                  } = l,\n                  y = kn(l, Qf);\n                return t.levenUnknownHandler(D, g, Object.assign(Object.assign({}, F), {}, {\n                  schemas: y\n                }));\n              },\n              B = h ? a : t.apiDescriptor,\n              I = o(p, {\n                isCLI: h,\n                colorsModule: T,\n                levenshteinDistance: A\n              }),\n              k = new t.Normalizer(I, {\n                logger: f,\n                unknown: S,\n                descriptor: B\n              }),\n              P = f !== !1;\n            P && u && (k._hasDeprecationWarned = u);\n            let C = k.normalize(d);\n            return P && (u = k._hasDeprecationWarned), h && C[\"plugin-search\"] === !1 && (C[\"plugin-search-dir\"] = !1), C;\n          }\n          function o(d, p) {\n            let {\n                isCLI: f,\n                colorsModule: h,\n                levenshteinDistance: w\n              } = p,\n              T = [];\n            f && T.push(t.AnySchema.create({\n              name: \"_\"\n            }));\n            for (let A of d) T.push(c(A, {\n              isCLI: f,\n              optionInfos: d,\n              colorsModule: h,\n              levenshteinDistance: w\n            })), A.alias && f && T.push(t.AliasSchema.create({\n              name: A.alias,\n              sourceName: A.name\n            }));\n            return T;\n          }\n          function c(d, p) {\n            let {\n                isCLI: f,\n                optionInfos: h,\n                colorsModule: w,\n                levenshteinDistance: T\n              } = p,\n              {\n                name: A\n              } = d;\n            if (A === \"plugin-search-dir\" || A === \"pluginSearchDirs\") return t.AnySchema.create({\n              name: A,\n              preprocess(k) {\n                return k === !1 || (k = Array.isArray(k) ? k : [k]), k;\n              },\n              validate(k) {\n                return k === !1 ? !0 : k.every(P => typeof P == \"string\");\n              },\n              expected() {\n                return \"false or paths to plugin search dir\";\n              }\n            });\n            let S = {\n                name: A\n              },\n              B,\n              I = {};\n            switch (d.type) {\n              case \"int\":\n                B = t.IntegerSchema, f && (S.preprocess = Number);\n                break;\n              case \"string\":\n                B = t.StringSchema;\n                break;\n              case \"choice\":\n                B = t.ChoiceSchema, S.choices = d.choices.map(k => typeof k == \"object\" && k.redirect ? Object.assign(Object.assign({}, k), {}, {\n                  redirect: {\n                    to: {\n                      key: d.name,\n                      value: k.redirect\n                    }\n                  }\n                }) : k);\n                break;\n              case \"boolean\":\n                B = t.BooleanSchema;\n                break;\n              case \"flag\":\n                B = r({\n                  colorsModule: w,\n                  levenshteinDistance: T\n                }), S.flags = h.flatMap(k => [k.alias, k.description && k.name, k.oppositeDescription && \"no-\".concat(k.name)].filter(Boolean));\n                break;\n              case \"path\":\n                B = t.StringSchema;\n                break;\n              default:\n                throw new Error(\"Unexpected type \".concat(d.type));\n            }\n            if (d.exception ? S.validate = (k, P, C) => d.exception(k) || P.validate(k, C) : S.validate = (k, P, C) => k === void 0 || P.validate(k, C), d.redirect && (I.redirect = k => k ? {\n              to: {\n                key: d.redirect.option,\n                value: d.redirect.value\n              }\n            } : void 0), d.deprecated && (I.deprecated = !0), f && !d.array) {\n              let k = S.preprocess || (P => P);\n              S.preprocess = (P, C, D) => C.preprocess(k(Array.isArray(P) ? s(P) : P), D);\n            }\n            return d.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? {\n              preprocess: k => Array.isArray(k) ? k : [k]\n            } : {}), I), {}, {\n              valueSchema: B.create(S)\n            })) : B.create(Object.assign(Object.assign({}, S), I));\n          }\n          function v(d, p, f) {\n            return i(d, p, f);\n          }\n          function m(d, p, f) {\n            return i(d, p, Object.assign({\n              isCLI: !0\n            }, f));\n          }\n          n.exports = {\n            normalizeApiOptions: v,\n            normalizeCliOptions: m\n          };\n        }\n      }),\n      st = Z({\n        \"src/language-js/loc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Rn();\n          function s(o, c) {\n            let {\n              ignoreDecorators: v\n            } = c || {};\n            if (!v) {\n              let m = o.declaration && o.declaration.decorators || o.decorators;\n              if (t(m)) return s(m[0]);\n            }\n            return o.range ? o.range[0] : o.start;\n          }\n          function a(o) {\n            return o.range ? o.range[1] : o.end;\n          }\n          function r(o, c) {\n            let v = s(o);\n            return Number.isInteger(v) && v === s(c);\n          }\n          function u(o, c) {\n            let v = a(o);\n            return Number.isInteger(v) && v === a(c);\n          }\n          function i(o, c) {\n            return r(o, c) && u(o, c);\n          }\n          n.exports = {\n            locStart: s,\n            locEnd: a,\n            hasSameLocStart: r,\n            hasSameLoc: i\n          };\n        }\n      }),\n      gm = Z({\n        \"src/main/load-parser.js\"(e, n) {\n          re(), n.exports = () => {};\n        }\n      }),\n      ym = Z({\n        \"scripts/build/shims/babel-highlight.cjs\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = _r(),\n            s = {\n              shouldHighlight: () => !1,\n              getChalk: () => t\n            };\n          n.exports = s;\n        }\n      }),\n      hm = Z({\n        \"node_modules/@babel/code-frame/lib/index.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.codeFrameColumns = u, e.default = i;\n          var n = ym(),\n            t = !1;\n          function s(o) {\n            return {\n              gutter: o.grey,\n              marker: o.red.bold,\n              message: o.red.bold\n            };\n          }\n          var a = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n          function r(o, c, v) {\n            let m = Object.assign({\n                column: 0,\n                line: -1\n              }, o.start),\n              d = Object.assign({}, m, o.end),\n              {\n                linesAbove: p = 2,\n                linesBelow: f = 3\n              } = v || {},\n              h = m.line,\n              w = m.column,\n              T = d.line,\n              A = d.column,\n              S = Math.max(h - (p + 1), 0),\n              B = Math.min(c.length, T + f);\n            h === -1 && (S = 0), T === -1 && (B = c.length);\n            let I = T - h,\n              k = {};\n            if (I) for (let P = 0; P <= I; P++) {\n              let C = P + h;\n              if (!w) k[C] = !0;else if (P === 0) {\n                let D = c[C - 1].length;\n                k[C] = [w, D - w + 1];\n              } else if (P === I) k[C] = [0, A];else {\n                let D = c[C - P].length;\n                k[C] = [0, D];\n              }\n            } else w === A ? w ? k[h] = [w, 0] : k[h] = !0 : k[h] = [w, A - w];\n            return {\n              start: S,\n              end: B,\n              markerLines: k\n            };\n          }\n          function u(o, c) {\n            let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n              m = (v.highlightCode || v.forceColor) && (0, n.shouldHighlight)(v),\n              d = (0, n.getChalk)(v),\n              p = s(d),\n              f = (P, C) => m ? P(C) : C,\n              h = o.split(a),\n              {\n                start: w,\n                end: T,\n                markerLines: A\n              } = r(c, h, v),\n              S = c.start && typeof c.start.column == \"number\",\n              B = String(T).length,\n              k = (m ? (0, n.default)(o, v) : o).split(a, T).slice(w, T).map((P, C) => {\n                let D = w + 1 + C,\n                  g = \" \".concat(D).slice(-B),\n                  F = \" \".concat(g, \" |\"),\n                  l = A[D],\n                  E = !A[D + 1];\n                if (l) {\n                  let y = \"\";\n                  if (Array.isArray(l)) {\n                    let N = P.slice(0, Math.max(l[0] - 1, 0)).replace(/[^\\t]/g, \" \"),\n                      x = l[1] || 1;\n                    y = [`\n `, f(p.gutter, F.replace(/\\d/g, \" \")), \" \", N, f(p.marker, \"^\").repeat(x)].join(\"\"), E && v.message && (y += \" \" + f(p.message, v.message));\n                  }\n                  return [f(p.marker, \">\"), f(p.gutter, F), P.length > 0 ? \" \".concat(P) : \"\", y].join(\"\");\n                } else return \" \".concat(f(p.gutter, F)).concat(P.length > 0 ? \" \".concat(P) : \"\");\n              }).join(`\n`);\n            return v.message && !S && (k = \"\".concat(\" \".repeat(B + 1)).concat(v.message, `\n`).concat(k)), m ? d.reset(k) : k;\n          }\n          function i(o, c, v) {\n            let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n            if (!t) {\n              t = !0;\n              let p = \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n              if (Tt.emitWarning) Tt.emitWarning(p, \"DeprecationWarning\");else {\n                let f = new Error(p);\n                f.name = \"DeprecationWarning\", console.warn(new Error(p));\n              }\n            }\n            return v = Math.max(v, 0), u(o, {\n              start: {\n                column: v,\n                line: c\n              }\n            }, m);\n          }\n        }\n      }),\n      Gn = Z({\n        \"src/main/parser.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              ConfigError: t\n            } = zt(),\n            s = st(),\n            a = gm(),\n            {\n              locStart: r,\n              locEnd: u\n            } = s,\n            i = Object.getOwnPropertyNames,\n            o = Object.getOwnPropertyDescriptor;\n          function c(d) {\n            let p = {};\n            for (let f of d.plugins) if (!!f.parsers) for (let h of i(f.parsers)) Object.defineProperty(p, h, o(f.parsers, h));\n            return p;\n          }\n          function v(d) {\n            let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c(d);\n            if (typeof d.parser == \"function\") return {\n              parse: d.parser,\n              astFormat: \"estree\",\n              locStart: r,\n              locEnd: u\n            };\n            if (typeof d.parser == \"string\") {\n              if (Object.prototype.hasOwnProperty.call(p, d.parser)) return p[d.parser];\n              throw new t(`Couldn't resolve parser \"`.concat(d.parser, '\". Parsers must be explicitly added to the standalone bundle.'));\n            }\n          }\n          function m(d, p) {\n            let f = c(p),\n              h = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map(T => [T, {\n                enumerable: !0,\n                get() {\n                  return f[T].parse;\n                }\n              }]))),\n              w = v(p, f);\n            try {\n              return w.preprocess && (d = w.preprocess(d, p)), {\n                text: d,\n                ast: w.parse(d, h, p)\n              };\n            } catch (T) {\n              let {\n                loc: A\n              } = T;\n              if (A) {\n                let {\n                  codeFrameColumns: S\n                } = hm();\n                throw T.codeFrame = S(d, A, {\n                  highlightCode: !0\n                }), T.message += `\n` + T.codeFrame, T;\n              }\n              throw T.stack;\n            }\n          }\n          n.exports = {\n            parse: m,\n            resolveParser: v\n          };\n        }\n      }),\n      Wa = Z({\n        \"src/main/options.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = PD(),\n            {\n              UndefinedParserError: s\n            } = zt(),\n            {\n              getSupportInfo: a\n            } = Mn(),\n            r = dm(),\n            {\n              resolveParser: u\n            } = Gn(),\n            i = {\n              astFormat: \"estree\",\n              printer: {},\n              originalText: void 0,\n              locStart: null,\n              locEnd: null\n            };\n          function o(m) {\n            let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n              p = Object.assign({}, m),\n              f = a({\n                plugins: m.plugins,\n                showUnreleased: !0,\n                showDeprecated: !0\n              }).options,\n              h = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter(B => B.default !== void 0).map(B => [B.name, B.default])));\n            if (!p.parser) {\n              if (!p.filepath) (d.logger || console).warn(\"No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred.\"), p.parser = \"babel\";else if (p.parser = v(p.filepath, p.plugins), !p.parser) throw new s(\"No parser could be inferred for file: \".concat(p.filepath));\n            }\n            let w = u(r.normalizeApiOptions(p, [f.find(B => B.name === \"parser\")], {\n              passThrough: !0,\n              logger: !1\n            }));\n            p.astFormat = w.astFormat, p.locEnd = w.locEnd, p.locStart = w.locStart;\n            let T = c(p);\n            p.printer = T.printers[p.astFormat];\n            let A = Object.fromEntries(f.filter(B => B.pluginDefaults && B.pluginDefaults[T.name] !== void 0).map(B => [B.name, B.pluginDefaults[T.name]])),\n              S = Object.assign(Object.assign({}, h), A);\n            for (let [B, I] of Object.entries(S)) (p[B] === null || p[B] === void 0) && (p[B] = I);\n            return p.parser === \"json\" && (p.trailingComma = \"none\"), r.normalizeApiOptions(p, f, Object.assign({\n              passThrough: Object.keys(i)\n            }, d));\n          }\n          function c(m) {\n            let {\n              astFormat: d\n            } = m;\n            if (!d) throw new Error(\"getPlugin() requires astFormat to be set\");\n            let p = m.plugins.find(f => f.printers && f.printers[d]);\n            if (!p) throw new Error(`Couldn't find plugin for AST format \"`.concat(d, '\"'));\n            return p;\n          }\n          function v(m, d) {\n            let p = t.basename(m).toLowerCase(),\n              h = a({\n                plugins: d\n              }).languages.filter(w => w.since !== null).find(w => w.extensions && w.extensions.some(T => p.endsWith(T)) || w.filenames && w.filenames.some(T => T.toLowerCase() === p));\n            return h && h.parsers[0];\n          }\n          n.exports = {\n            normalize: o,\n            hiddenDefaults: i,\n            inferParser: v\n          };\n        }\n      }),\n      vm = Z({\n        \"src/main/massage-ast.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s, a, r) {\n            if (Array.isArray(s)) return s.map(c => t(c, a, r)).filter(Boolean);\n            if (!s || typeof s != \"object\") return s;\n            let u = a.printer.massageAstNode,\n              i;\n            u && u.ignoredProperties ? i = u.ignoredProperties : i = new Set();\n            let o = {};\n            for (let [c, v] of Object.entries(s)) !i.has(c) && typeof v != \"function\" && (o[c] = t(v, a, s));\n            if (u) {\n              let c = u(s, o, r);\n              if (c === null) return;\n              if (c) return c;\n            }\n            return o;\n          }\n          n.exports = t;\n        }\n      }),\n      Xt = Z({\n        \"scripts/build/shims/assert.cjs\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = () => {};\n          t.ok = t, t.strictEqual = t, n.exports = t;\n        }\n      }),\n      et = Z({\n        \"src/main/comments.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Xt(),\n            {\n              builders: {\n                line: s,\n                hardline: a,\n                breakParent: r,\n                indent: u,\n                lineSuffix: i,\n                join: o,\n                cursor: c\n              }\n            } = Oe(),\n            {\n              hasNewline: v,\n              skipNewline: m,\n              skipSpaces: d,\n              isPreviousLineEmpty: p,\n              addLeadingComment: f,\n              addDanglingComment: h,\n              addTrailingComment: w\n            } = Ue(),\n            T = new WeakMap();\n          function A(L, M, j) {\n            if (!L) return;\n            let {\n              printer: $,\n              locStart: V,\n              locEnd: q\n            } = M;\n            if (j) {\n              if ($.canAttachComment && $.canAttachComment(L)) {\n                let H;\n                for (H = j.length - 1; H >= 0 && !(V(j[H]) <= V(L) && q(j[H]) <= q(L)); --H);\n                j.splice(H + 1, 0, L);\n                return;\n              }\n            } else if (T.has(L)) return T.get(L);\n            let Y = $.getCommentChildNodes && $.getCommentChildNodes(L, M) || typeof L == \"object\" && Object.entries(L).filter(H => {\n              let [R] = H;\n              return R !== \"enclosingNode\" && R !== \"precedingNode\" && R !== \"followingNode\" && R !== \"tokens\" && R !== \"comments\" && R !== \"parent\";\n            }).map(H => {\n              let [, R] = H;\n              return R;\n            });\n            if (!!Y) {\n              j || (j = [], T.set(L, j));\n              for (let H of Y) A(H, M, j);\n              return j;\n            }\n          }\n          function S(L, M, j, $) {\n            let {\n                locStart: V,\n                locEnd: q\n              } = j,\n              Y = V(M),\n              H = q(M),\n              R = A(L, j),\n              Q,\n              ee,\n              te = 0,\n              oe = R.length;\n            for (; te < oe;) {\n              let W = te + oe >> 1,\n                X = R[W],\n                ue = V(X),\n                De = q(X);\n              if (ue <= Y && H <= De) return S(X, M, j, X);\n              if (De <= Y) {\n                Q = X, te = W + 1;\n                continue;\n              }\n              if (H <= ue) {\n                ee = X, oe = W;\n                continue;\n              }\n              throw new Error(\"Comment location overlaps with node location\");\n            }\n            if ($ && $.type === \"TemplateLiteral\") {\n              let {\n                  quasis: W\n                } = $,\n                X = F(W, M, j);\n              Q && F(W, Q, j) !== X && (Q = null), ee && F(W, ee, j) !== X && (ee = null);\n            }\n            return {\n              enclosingNode: $,\n              precedingNode: Q,\n              followingNode: ee\n            };\n          }\n          var B = () => !1;\n          function I(L, M, j, $) {\n            if (!Array.isArray(L)) return;\n            let V = [],\n              {\n                locStart: q,\n                locEnd: Y,\n                printer: {\n                  handleComments: H = {}\n                }\n              } = $,\n              {\n                avoidAstMutation: R,\n                ownLine: Q = B,\n                endOfLine: ee = B,\n                remaining: te = B\n              } = H,\n              oe = L.map((W, X) => Object.assign(Object.assign({}, S(M, W, $)), {}, {\n                comment: W,\n                text: j,\n                options: $,\n                ast: M,\n                isLastComment: L.length - 1 === X\n              }));\n            for (let [W, X] of oe.entries()) {\n              let {\n                comment: ue,\n                precedingNode: De,\n                enclosingNode: ie,\n                followingNode: G,\n                text: z,\n                options: U,\n                ast: le,\n                isLastComment: ge\n              } = X;\n              if (U.parser === \"json\" || U.parser === \"json5\" || U.parser === \"__js_expression\" || U.parser === \"__vue_expression\" || U.parser === \"__vue_ts_expression\") {\n                if (q(ue) - q(le) <= 0) {\n                  f(le, ue);\n                  continue;\n                }\n                if (Y(ue) - Y(le) >= 0) {\n                  w(le, ue);\n                  continue;\n                }\n              }\n              let Ae;\n              if (R ? Ae = [X] : (ue.enclosingNode = ie, ue.precedingNode = De, ue.followingNode = G, Ae = [ue, z, U, le, ge]), P(z, U, oe, W)) ue.placement = \"ownLine\", Q(...Ae) || (G ? f(G, ue) : De ? w(De, ue) : h(ie || le, ue));else if (C(z, U, oe, W)) ue.placement = \"endOfLine\", ee(...Ae) || (De ? w(De, ue) : G ? f(G, ue) : h(ie || le, ue));else if (ue.placement = \"remaining\", !te(...Ae)) if (De && G) {\n                let Ne = V.length;\n                Ne > 0 && V[Ne - 1].followingNode !== G && D(V, z, U), V.push(X);\n              } else De ? w(De, ue) : G ? f(G, ue) : h(ie || le, ue);\n            }\n            if (D(V, j, $), !R) for (let W of L) delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;\n          }\n          var k = L => !/[\\S\\n\\u2028\\u2029]/.test(L);\n          function P(L, M, j, $) {\n            let {\n                comment: V,\n                precedingNode: q\n              } = j[$],\n              {\n                locStart: Y,\n                locEnd: H\n              } = M,\n              R = Y(V);\n            if (q) for (let Q = $ - 1; Q >= 0; Q--) {\n              let {\n                comment: ee,\n                precedingNode: te\n              } = j[Q];\n              if (te !== q || !k(L.slice(H(ee), R))) break;\n              R = Y(ee);\n            }\n            return v(L, R, {\n              backwards: !0\n            });\n          }\n          function C(L, M, j, $) {\n            let {\n                comment: V,\n                followingNode: q\n              } = j[$],\n              {\n                locStart: Y,\n                locEnd: H\n              } = M,\n              R = H(V);\n            if (q) for (let Q = $ + 1; Q < j.length; Q++) {\n              let {\n                comment: ee,\n                followingNode: te\n              } = j[Q];\n              if (te !== q || !k(L.slice(R, Y(ee)))) break;\n              R = H(ee);\n            }\n            return v(L, R);\n          }\n          function D(L, M, j) {\n            let $ = L.length;\n            if ($ === 0) return;\n            let {\n                precedingNode: V,\n                followingNode: q,\n                enclosingNode: Y\n              } = L[0],\n              H = j.printer.getGapRegex && j.printer.getGapRegex(Y) || /^[\\s(]*$/,\n              R = j.locStart(q),\n              Q;\n            for (Q = $; Q > 0; --Q) {\n              let {\n                comment: ee,\n                precedingNode: te,\n                followingNode: oe\n              } = L[Q - 1];\n              t.strictEqual(te, V), t.strictEqual(oe, q);\n              let W = M.slice(j.locEnd(ee), R);\n              if (H.test(W)) R = j.locStart(ee);else break;\n            }\n            for (let [ee, {\n              comment: te\n            }] of L.entries()) ee < Q ? w(V, te) : f(q, te);\n            for (let ee of [V, q]) ee.comments && ee.comments.length > 1 && ee.comments.sort((te, oe) => j.locStart(te) - j.locStart(oe));\n            L.length = 0;\n          }\n          function g(L, M) {\n            let j = L.getValue();\n            return j.printed = !0, M.printer.printComment(L, M);\n          }\n          function F(L, M, j) {\n            let $ = j.locStart(M) - 1;\n            for (let V = 1; V < L.length; ++V) if ($ < j.locStart(L[V])) return V - 1;\n            return 0;\n          }\n          function l(L, M) {\n            let j = L.getValue(),\n              $ = [g(L, M)],\n              {\n                printer: V,\n                originalText: q,\n                locStart: Y,\n                locEnd: H\n              } = M;\n            if (V.isBlockComment && V.isBlockComment(j)) {\n              let ee = v(q, H(j)) ? v(q, Y(j), {\n                backwards: !0\n              }) ? a : s : \" \";\n              $.push(ee);\n            } else $.push(a);\n            let Q = m(q, d(q, H(j)));\n            return Q !== !1 && v(q, Q) && $.push(a), $;\n          }\n          function E(L, M) {\n            let j = L.getValue(),\n              $ = g(L, M),\n              {\n                printer: V,\n                originalText: q,\n                locStart: Y\n              } = M,\n              H = V.isBlockComment && V.isBlockComment(j);\n            if (v(q, Y(j), {\n              backwards: !0\n            })) {\n              let Q = p(q, j, Y);\n              return i([a, Q ? a : \"\", $]);\n            }\n            let R = [\" \", $];\n            return H || (R = [i(R), r]), R;\n          }\n          function y(L, M, j, $) {\n            let V = [],\n              q = L.getValue();\n            return !q || !q.comments || (L.each(() => {\n              let Y = L.getValue();\n              !Y.leading && !Y.trailing && (!$ || $(Y)) && V.push(g(L, M));\n            }, \"comments\"), V.length === 0) ? \"\" : j ? o(a, V) : u([a, o(a, V)]);\n          }\n          function N(L, M, j) {\n            let $ = L.getValue();\n            if (!$) return {};\n            let V = $.comments || [];\n            j && (V = V.filter(R => !j.has(R)));\n            let q = $ === M.cursorNode;\n            if (V.length === 0) {\n              let R = q ? c : \"\";\n              return {\n                leading: R,\n                trailing: R\n              };\n            }\n            let Y = [],\n              H = [];\n            return L.each(() => {\n              let R = L.getValue();\n              if (j && j.has(R)) return;\n              let {\n                leading: Q,\n                trailing: ee\n              } = R;\n              Q ? Y.push(l(L, M)) : ee && H.push(E(L, M));\n            }, \"comments\"), q && (Y.unshift(c), H.push(c)), {\n              leading: Y,\n              trailing: H\n            };\n          }\n          function x(L, M, j, $) {\n            let {\n              leading: V,\n              trailing: q\n            } = N(L, j, $);\n            return !V && !q ? M : [V, M, q];\n          }\n          function b(L) {\n            if (!!L) for (let M of L) {\n              if (!M.printed) throw new Error('Comment \"' + M.value.trim() + '\" was not printed. Please report this error!');\n              delete M.printed;\n            }\n          }\n          n.exports = {\n            attach: I,\n            printComments: x,\n            printCommentsSeparately: N,\n            printDanglingComments: y,\n            getSortedChildNodes: A,\n            ensureAllCommentsPrinted: b\n          };\n        }\n      }),\n      Cm = Z({\n        \"src/common/ast-path.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = it();\n          function s(u, i) {\n            let o = a(u.stack, i);\n            return o === -1 ? null : u.stack[o];\n          }\n          function a(u, i) {\n            for (let o = u.length - 1; o >= 0; o -= 2) {\n              let c = u[o];\n              if (c && !Array.isArray(c) && --i < 0) return o;\n            }\n            return -1;\n          }\n          var r = class {\n            constructor(u) {\n              this.stack = [u];\n            }\n            getName() {\n              let {\n                  stack: u\n                } = this,\n                {\n                  length: i\n                } = u;\n              return i > 1 ? u[i - 2] : null;\n            }\n            getValue() {\n              return t(this.stack);\n            }\n            getNode() {\n              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n              return s(this, u);\n            }\n            getParentNode() {\n              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n              return s(this, u + 1);\n            }\n            call(u) {\n              let {\n                  stack: i\n                } = this,\n                {\n                  length: o\n                } = i,\n                c = t(i);\n              for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++) m[d - 1] = arguments[d];\n              for (let f of m) c = c[f], i.push(f, c);\n              let p = u(this);\n              return i.length = o, p;\n            }\n            callParent(u) {\n              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n                o = a(this.stack, i + 1),\n                c = this.stack.splice(o + 1),\n                v = u(this);\n              return this.stack.push(...c), v;\n            }\n            each(u) {\n              let {\n                  stack: i\n                } = this,\n                {\n                  length: o\n                } = i,\n                c = t(i);\n              for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++) m[d - 1] = arguments[d];\n              for (let p of m) c = c[p], i.push(p, c);\n              for (let p = 0; p < c.length; ++p) i.push(p, c[p]), u(this, p, c), i.length -= 2;\n              i.length = o;\n            }\n            map(u) {\n              let i = [];\n              for (var o = arguments.length, c = new Array(o > 1 ? o - 1 : 0), v = 1; v < o; v++) c[v - 1] = arguments[v];\n              return this.each((m, d, p) => {\n                i[d] = u(m, d, p);\n              }, ...c), i;\n            }\n            try(u) {\n              let {\n                  stack: i\n                } = this,\n                o = [...i];\n              try {\n                return u();\n              } finally {\n                i.length = 0, i.push(...o);\n              }\n            }\n            match() {\n              let u = this.stack.length - 1,\n                i = null,\n                o = this.stack[u--];\n              for (var c = arguments.length, v = new Array(c), m = 0; m < c; m++) v[m] = arguments[m];\n              for (let d of v) {\n                if (o === void 0) return !1;\n                let p = null;\n                if (typeof i == \"number\" && (p = i, i = this.stack[u--], o = this.stack[u--]), d && !d(o, i, p)) return !1;\n                i = this.stack[u--], o = this.stack[u--];\n              }\n              return !0;\n            }\n            findAncestor(u) {\n              let i = this.stack.length - 1,\n                o = null,\n                c = this.stack[i--];\n              for (; c;) {\n                let v = null;\n                if (typeof o == \"number\" && (v = o, o = this.stack[i--], c = this.stack[i--]), o !== null && u(c, o, v)) return c;\n                o = this.stack[i--], c = this.stack[i--];\n              }\n            }\n          };\n          n.exports = r;\n        }\n      }),\n      Em = Z({\n        \"src/main/multiparser.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              utils: {\n                stripTrailingHardline: t\n              }\n            } = Oe(),\n            {\n              normalize: s\n            } = Wa(),\n            a = et();\n          function r(i, o, c, v) {\n            if (c.printer.embed && c.embeddedLanguageFormatting === \"auto\") return c.printer.embed(i, o, (m, d, p) => u(m, d, c, v, p), c);\n          }\n          function u(i, o, c, v) {\n            let {\n                stripTrailingHardline: m = !1\n              } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {},\n              d = s(Object.assign(Object.assign(Object.assign({}, c), o), {}, {\n                parentParser: c.parser,\n                originalText: i\n              }), {\n                passThrough: !0\n              }),\n              p = Gn().parse(i, d),\n              {\n                ast: f\n              } = p;\n            i = p.text;\n            let h = f.comments;\n            delete f.comments, a.attach(h, f, i, d), d[Symbol.for(\"comments\")] = h || [], d[Symbol.for(\"tokens\")] = f.tokens || [];\n            let w = v(f, d);\n            return a.ensureAllCommentsPrinted(h), m ? typeof w == \"string\" ? w.replace(/(?:\\r?\\n)*$/, \"\") : t(w) : w;\n          }\n          n.exports = {\n            printSubtree: r\n          };\n        }\n      }),\n      Fm = Z({\n        \"src/main/ast-to-doc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Cm(),\n            {\n              builders: {\n                hardline: s,\n                addAlignmentToDoc: a\n              },\n              utils: {\n                propagateBreaks: r\n              }\n            } = Oe(),\n            {\n              printComments: u\n            } = et(),\n            i = Em();\n          function o(m, d) {\n            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n              {\n                printer: f\n              } = d;\n            f.preprocess && (m = f.preprocess(m, d));\n            let h = new Map(),\n              w = new t(m),\n              T = A();\n            return p > 0 && (T = a([s, T], p, d.tabWidth)), r(T), T;\n            function A(B, I) {\n              return B === void 0 || B === w ? S(I) : Array.isArray(B) ? w.call(() => S(I), ...B) : w.call(() => S(I), B);\n            }\n            function S(B) {\n              let I = w.getValue(),\n                k = I && typeof I == \"object\" && B === void 0;\n              if (k && h.has(I)) return h.get(I);\n              let P = v(w, d, A, B);\n              return k && h.set(I, P), P;\n            }\n          }\n          function c(m, d) {\n            let {\n                originalText: p,\n                [Symbol.for(\"comments\")]: f,\n                locStart: h,\n                locEnd: w\n              } = d,\n              T = h(m),\n              A = w(m),\n              S = new Set();\n            for (let B of f) h(B) >= T && w(B) <= A && (B.printed = !0, S.add(B));\n            return {\n              doc: p.slice(T, A),\n              printedComments: S\n            };\n          }\n          function v(m, d, p, f) {\n            let h = m.getValue(),\n              {\n                printer: w\n              } = d,\n              T,\n              A;\n            if (w.hasPrettierIgnore && w.hasPrettierIgnore(m)) ({\n              doc: T,\n              printedComments: A\n            } = c(h, d));else {\n              if (h) try {\n                T = i.printSubtree(m, p, d, o);\n              } catch (S) {\n                if (globalThis.PRETTIER_DEBUG) throw S;\n              }\n              T || (T = w.print(m, d, p, f));\n            }\n            return (!w.willPrintOwnComments || !w.willPrintOwnComments(m, d)) && (T = u(m, T, d, A)), T;\n          }\n          n.exports = o;\n        }\n      }),\n      Am = Z({\n        \"src/main/range-util.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Xt(),\n            s = et(),\n            a = f => {\n              let {\n                parser: h\n              } = f;\n              return h === \"json\" || h === \"json5\" || h === \"json-stringify\";\n            };\n          function r(f, h) {\n            let w = [f.node, ...f.parentNodes],\n              T = new Set([h.node, ...h.parentNodes]);\n            return w.find(A => v.has(A.type) && T.has(A));\n          }\n          function u(f) {\n            let h = f.length - 1;\n            for (;;) {\n              let w = f[h];\n              if (w && (w.type === \"Program\" || w.type === \"File\")) h--;else break;\n            }\n            return f.slice(0, h + 1);\n          }\n          function i(f, h, w) {\n            let {\n                locStart: T,\n                locEnd: A\n              } = w,\n              S = f.node,\n              B = h.node;\n            if (S === B) return {\n              startNode: S,\n              endNode: B\n            };\n            let I = T(f.node);\n            for (let P of u(h.parentNodes)) if (T(P) >= I) B = P;else break;\n            let k = A(h.node);\n            for (let P of u(f.parentNodes)) if (A(P) <= k) S = P;else break;\n            return {\n              startNode: S,\n              endNode: B\n            };\n          }\n          function o(f, h, w, T) {\n            let A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [],\n              S = arguments.length > 5 ? arguments[5] : void 0,\n              {\n                locStart: B,\n                locEnd: I\n              } = w,\n              k = B(f),\n              P = I(f);\n            if (!(h > P || h < k || S === \"rangeEnd\" && h === k || S === \"rangeStart\" && h === P)) {\n              for (let C of s.getSortedChildNodes(f, w)) {\n                let D = o(C, h, w, T, [f, ...A], S);\n                if (D) return D;\n              }\n              if (!T || T(f, A[0])) return {\n                node: f,\n                parentNodes: A\n              };\n            }\n          }\n          function c(f, h) {\n            return h !== \"DeclareExportDeclaration\" && f !== \"TypeParameterDeclaration\" && (f === \"Directive\" || f === \"TypeAlias\" || f === \"TSExportAssignment\" || f.startsWith(\"Declare\") || f.startsWith(\"TSDeclare\") || f.endsWith(\"Statement\") || f.endsWith(\"Declaration\"));\n          }\n          var v = new Set([\"ObjectExpression\", \"ArrayExpression\", \"StringLiteral\", \"NumericLiteral\", \"BooleanLiteral\", \"NullLiteral\", \"UnaryExpression\", \"TemplateLiteral\"]),\n            m = new Set([\"OperationDefinition\", \"FragmentDefinition\", \"VariableDefinition\", \"TypeExtensionDefinition\", \"ObjectTypeDefinition\", \"FieldDefinition\", \"DirectiveDefinition\", \"EnumTypeDefinition\", \"EnumValueDefinition\", \"InputValueDefinition\", \"InputObjectTypeDefinition\", \"SchemaDefinition\", \"OperationTypeDefinition\", \"InterfaceTypeDefinition\", \"UnionTypeDefinition\", \"ScalarTypeDefinition\"]);\n          function d(f, h, w) {\n            if (!h) return !1;\n            switch (f.parser) {\n              case \"flow\":\n              case \"babel\":\n              case \"babel-flow\":\n              case \"babel-ts\":\n              case \"typescript\":\n              case \"acorn\":\n              case \"espree\":\n              case \"meriyah\":\n              case \"__babel_estree\":\n                return c(h.type, w && w.type);\n              case \"json\":\n              case \"json5\":\n              case \"json-stringify\":\n                return v.has(h.type);\n              case \"graphql\":\n                return m.has(h.kind);\n              case \"vue\":\n                return h.tag !== \"root\";\n            }\n            return !1;\n          }\n          function p(f, h, w) {\n            let {\n              rangeStart: T,\n              rangeEnd: A,\n              locStart: S,\n              locEnd: B\n            } = h;\n            t.ok(A > T);\n            let I = f.slice(T, A).search(/\\S/),\n              k = I === -1;\n            if (!k) for (T += I; A > T && !/\\S/.test(f[A - 1]); --A);\n            let P = o(w, T, h, (F, l) => d(h, F, l), [], \"rangeStart\"),\n              C = k ? P : o(w, A, h, F => d(h, F), [], \"rangeEnd\");\n            if (!P || !C) return {\n              rangeStart: 0,\n              rangeEnd: 0\n            };\n            let D, g;\n            if (a(h)) {\n              let F = r(P, C);\n              D = F, g = F;\n            } else ({\n              startNode: D,\n              endNode: g\n            } = i(P, C, h));\n            return {\n              rangeStart: Math.min(S(D), S(g)),\n              rangeEnd: Math.max(B(D), B(g))\n            };\n          }\n          n.exports = {\n            calculateRange: p,\n            findNodeAtOffset: o\n          };\n        }\n      }),\n      Sm = Z({\n        \"src/main/core.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              diffArrays: t\n            } = aD(),\n            {\n              printer: {\n                printDocToString: s\n              },\n              debug: {\n                printDocToDebug: a\n              }\n            } = Oe(),\n            {\n              getAlignmentSize: r\n            } = Ue(),\n            {\n              guessEndOfLine: u,\n              convertEndOfLineToChars: i,\n              countEndOfLineChars: o,\n              normalizeEndOfLine: c\n            } = jn(),\n            v = Wa().normalize,\n            m = vm(),\n            d = et(),\n            p = Gn(),\n            f = Fm(),\n            h = Am(),\n            w = \"\\uFEFF\",\n            T = Symbol(\"cursor\");\n          function A(g, F, l) {\n            let E = F.comments;\n            return E && (delete F.comments, d.attach(E, F, g, l)), l[Symbol.for(\"comments\")] = E || [], l[Symbol.for(\"tokens\")] = F.tokens || [], l.originalText = g, E;\n          }\n          function S(g, F) {\n            let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n            if (!g || g.trim().length === 0) return {\n              formatted: \"\",\n              cursorOffset: -1,\n              comments: []\n            };\n            let {\n              ast: E,\n              text: y\n            } = p.parse(g, F);\n            if (F.cursorOffset >= 0) {\n              let L = h.findNodeAtOffset(E, F.cursorOffset, F);\n              L && L.node && (F.cursorNode = L.node);\n            }\n            let N = A(y, E, F),\n              x = f(E, F, l),\n              b = s(x, F);\n            if (d.ensureAllCommentsPrinted(N), l > 0) {\n              let L = b.formatted.trim();\n              b.cursorNodeStart !== void 0 && (b.cursorNodeStart -= b.formatted.indexOf(L)), b.formatted = L + i(F.endOfLine);\n            }\n            if (F.cursorOffset >= 0) {\n              let L, M, j, $, V;\n              if (F.cursorNode && b.cursorNodeText ? (L = F.locStart(F.cursorNode), M = y.slice(L, F.locEnd(F.cursorNode)), j = F.cursorOffset - L, $ = b.cursorNodeStart, V = b.cursorNodeText) : (L = 0, M = y, j = F.cursorOffset, $ = 0, V = b.formatted), M === V) return {\n                formatted: b.formatted,\n                cursorOffset: $ + j,\n                comments: N\n              };\n              let q = [...M];\n              q.splice(j, 0, T);\n              let Y = [...V],\n                H = t(q, Y),\n                R = $;\n              for (let Q of H) if (Q.removed) {\n                if (Q.value.includes(T)) break;\n              } else R += Q.count;\n              return {\n                formatted: b.formatted,\n                cursorOffset: R,\n                comments: N\n              };\n            }\n            return {\n              formatted: b.formatted,\n              cursorOffset: -1,\n              comments: N\n            };\n          }\n          function B(g, F) {\n            let {\n                ast: l,\n                text: E\n              } = p.parse(g, F),\n              {\n                rangeStart: y,\n                rangeEnd: N\n              } = h.calculateRange(E, F, l),\n              x = E.slice(y, N),\n              b = Math.min(y, E.lastIndexOf(`\n`, y) + 1),\n              L = E.slice(b, y).match(/^\\s*/)[0],\n              M = r(L, F.tabWidth),\n              j = S(x, Object.assign(Object.assign({}, F), {}, {\n                rangeStart: 0,\n                rangeEnd: Number.POSITIVE_INFINITY,\n                cursorOffset: F.cursorOffset > y && F.cursorOffset <= N ? F.cursorOffset - y : -1,\n                endOfLine: \"lf\"\n              }), M),\n              $ = j.formatted.trimEnd(),\n              {\n                cursorOffset: V\n              } = F;\n            V > N ? V += $.length - x.length : j.cursorOffset >= 0 && (V = j.cursorOffset + y);\n            let q = E.slice(0, y) + $ + E.slice(N);\n            if (F.endOfLine !== \"lf\") {\n              let Y = i(F.endOfLine);\n              V >= 0 && Y === `\\r\n` && (V += o(q.slice(0, V), `\n`)), q = q.replace(/\\n/g, Y);\n            }\n            return {\n              formatted: q,\n              cursorOffset: V,\n              comments: j.comments\n            };\n          }\n          function I(g, F, l) {\n            return typeof F != \"number\" || Number.isNaN(F) || F < 0 || F > g.length ? l : F;\n          }\n          function k(g, F) {\n            let {\n              cursorOffset: l,\n              rangeStart: E,\n              rangeEnd: y\n            } = F;\n            return l = I(g, l, -1), E = I(g, E, 0), y = I(g, y, g.length), Object.assign(Object.assign({}, F), {}, {\n              cursorOffset: l,\n              rangeStart: E,\n              rangeEnd: y\n            });\n          }\n          function P(g, F) {\n            let {\n                cursorOffset: l,\n                rangeStart: E,\n                rangeEnd: y,\n                endOfLine: N\n              } = k(g, F),\n              x = g.charAt(0) === w;\n            if (x && (g = g.slice(1), l--, E--, y--), N === \"auto\" && (N = u(g)), g.includes(\"\\r\")) {\n              let b = L => o(g.slice(0, Math.max(L, 0)), `\\r\n`);\n              l -= b(l), E -= b(E), y -= b(y), g = c(g);\n            }\n            return {\n              hasBOM: x,\n              text: g,\n              options: k(g, Object.assign(Object.assign({}, F), {}, {\n                cursorOffset: l,\n                rangeStart: E,\n                rangeEnd: y,\n                endOfLine: N\n              }))\n            };\n          }\n          function C(g, F) {\n            let l = p.resolveParser(F);\n            return !l.hasPragma || l.hasPragma(g);\n          }\n          function D(g, F) {\n            let {\n              hasBOM: l,\n              text: E,\n              options: y\n            } = P(g, v(F));\n            if (y.rangeStart >= y.rangeEnd && E !== \"\" || y.requirePragma && !C(E, y)) return {\n              formatted: g,\n              cursorOffset: F.cursorOffset,\n              comments: []\n            };\n            let N;\n            return y.rangeStart > 0 || y.rangeEnd < E.length ? N = B(E, y) : (!y.requirePragma && y.insertPragma && y.printer.insertPragma && !C(E, y) && (E = y.printer.insertPragma(E)), N = S(E, y)), l && (N.formatted = w + N.formatted, N.cursorOffset >= 0 && N.cursorOffset++), N;\n          }\n          n.exports = {\n            formatWithCursor: D,\n            parse(g, F, l) {\n              let {\n                  text: E,\n                  options: y\n                } = P(g, v(F)),\n                N = p.parse(E, y);\n              return l && (N.ast = m(N.ast, y)), N;\n            },\n            formatAST(g, F) {\n              F = v(F);\n              let l = f(g, F);\n              return s(l, F);\n            },\n            formatDoc(g, F) {\n              return D(a(g), Object.assign(Object.assign({}, F), {}, {\n                parser: \"__js_expression\"\n              })).formatted;\n            },\n            printToDoc(g, F) {\n              F = v(F);\n              let {\n                ast: l,\n                text: E\n              } = p.parse(g, F);\n              return A(E, l, F), f(l, F);\n            },\n            printDocToString(g, F) {\n              return s(g, v(F));\n            }\n          };\n        }\n      }),\n      xm = Z({\n        \"src/common/util-shared.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            getMaxContinuousCount: t,\n            getStringWidth: s,\n            getAlignmentSize: a,\n            getIndentSize: r,\n            skip: u,\n            skipWhitespace: i,\n            skipSpaces: o,\n            skipNewline: c,\n            skipToLineEnd: v,\n            skipEverythingButNewLine: m,\n            skipInlineComment: d,\n            skipTrailingComment: p,\n            hasNewline: f,\n            hasNewlineInRange: h,\n            hasSpaces: w,\n            isNextLineEmpty: T,\n            isNextLineEmptyAfterIndex: A,\n            isPreviousLineEmpty: S,\n            getNextNonSpaceNonCommentCharacterIndex: B,\n            makeString: I,\n            addLeadingComment: k,\n            addDanglingComment: P,\n            addTrailingComment: C\n          } = Ue();\n          n.exports = {\n            getMaxContinuousCount: t,\n            getStringWidth: s,\n            getAlignmentSize: a,\n            getIndentSize: r,\n            skip: u,\n            skipWhitespace: i,\n            skipSpaces: o,\n            skipNewline: c,\n            skipToLineEnd: v,\n            skipEverythingButNewLine: m,\n            skipInlineComment: d,\n            skipTrailingComment: p,\n            hasNewline: f,\n            hasNewlineInRange: h,\n            hasSpaces: w,\n            isNextLineEmpty: T,\n            isNextLineEmptyAfterIndex: A,\n            isPreviousLineEmpty: S,\n            getNextNonSpaceNonCommentCharacterIndex: B,\n            makeString: I,\n            addLeadingComment: k,\n            addDanglingComment: P,\n            addTrailingComment: C\n          };\n        }\n      }),\n      Bt = Z({\n        \"src/utils/create-language.js\"(e, n) {\n          \"use strict\";\n\n          re(), n.exports = function (t, s) {\n            let {\n                languageId: a\n              } = t,\n              r = kn(t, Zf);\n            return Object.assign(Object.assign({\n              linguistLanguageId: a\n            }, r), s(t));\n          };\n        }\n      }),\n      bm = Z({\n        \"node_modules/esutils/lib/ast.js\"(e, n) {\n          re(), function () {\n            \"use strict\";\n\n            function t(o) {\n              if (o == null) return !1;\n              switch (o.type) {\n                case \"ArrayExpression\":\n                case \"AssignmentExpression\":\n                case \"BinaryExpression\":\n                case \"CallExpression\":\n                case \"ConditionalExpression\":\n                case \"FunctionExpression\":\n                case \"Identifier\":\n                case \"Literal\":\n                case \"LogicalExpression\":\n                case \"MemberExpression\":\n                case \"NewExpression\":\n                case \"ObjectExpression\":\n                case \"SequenceExpression\":\n                case \"ThisExpression\":\n                case \"UnaryExpression\":\n                case \"UpdateExpression\":\n                  return !0;\n              }\n              return !1;\n            }\n            function s(o) {\n              if (o == null) return !1;\n              switch (o.type) {\n                case \"DoWhileStatement\":\n                case \"ForInStatement\":\n                case \"ForStatement\":\n                case \"WhileStatement\":\n                  return !0;\n              }\n              return !1;\n            }\n            function a(o) {\n              if (o == null) return !1;\n              switch (o.type) {\n                case \"BlockStatement\":\n                case \"BreakStatement\":\n                case \"ContinueStatement\":\n                case \"DebuggerStatement\":\n                case \"DoWhileStatement\":\n                case \"EmptyStatement\":\n                case \"ExpressionStatement\":\n                case \"ForInStatement\":\n                case \"ForStatement\":\n                case \"IfStatement\":\n                case \"LabeledStatement\":\n                case \"ReturnStatement\":\n                case \"SwitchStatement\":\n                case \"ThrowStatement\":\n                case \"TryStatement\":\n                case \"VariableDeclaration\":\n                case \"WhileStatement\":\n                case \"WithStatement\":\n                  return !0;\n              }\n              return !1;\n            }\n            function r(o) {\n              return a(o) || o != null && o.type === \"FunctionDeclaration\";\n            }\n            function u(o) {\n              switch (o.type) {\n                case \"IfStatement\":\n                  return o.alternate != null ? o.alternate : o.consequent;\n                case \"LabeledStatement\":\n                case \"ForStatement\":\n                case \"ForInStatement\":\n                case \"WhileStatement\":\n                case \"WithStatement\":\n                  return o.body;\n              }\n              return null;\n            }\n            function i(o) {\n              var c;\n              if (o.type !== \"IfStatement\" || o.alternate == null) return !1;\n              c = o.consequent;\n              do {\n                if (c.type === \"IfStatement\" && c.alternate == null) return !0;\n                c = u(c);\n              } while (c);\n              return !1;\n            }\n            n.exports = {\n              isExpression: t,\n              isStatement: a,\n              isIterationStatement: s,\n              isSourceElement: r,\n              isProblematicIfStatement: i,\n              trailingStatement: u\n            };\n          }();\n        }\n      }),\n      $a = Z({\n        \"node_modules/esutils/lib/code.js\"(e, n) {\n          re(), function () {\n            \"use strict\";\n\n            var t, s, a, r, u, i;\n            s = {\n              NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n              NonAsciiIdentifierPart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/\n            }, t = {\n              NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n              NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n            };\n            function o(A) {\n              return 48 <= A && A <= 57;\n            }\n            function c(A) {\n              return 48 <= A && A <= 57 || 97 <= A && A <= 102 || 65 <= A && A <= 70;\n            }\n            function v(A) {\n              return A >= 48 && A <= 55;\n            }\n            a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];\n            function m(A) {\n              return A === 32 || A === 9 || A === 11 || A === 12 || A === 160 || A >= 5760 && a.indexOf(A) >= 0;\n            }\n            function d(A) {\n              return A === 10 || A === 13 || A === 8232 || A === 8233;\n            }\n            function p(A) {\n              if (A <= 65535) return String.fromCharCode(A);\n              var S = String.fromCharCode(Math.floor((A - 65536) / 1024) + 55296),\n                B = String.fromCharCode((A - 65536) % 1024 + 56320);\n              return S + B;\n            }\n            for (r = new Array(128), i = 0; i < 128; ++i) r[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;\n            for (u = new Array(128), i = 0; i < 128; ++i) u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;\n            function f(A) {\n              return A < 128 ? r[A] : s.NonAsciiIdentifierStart.test(p(A));\n            }\n            function h(A) {\n              return A < 128 ? u[A] : s.NonAsciiIdentifierPart.test(p(A));\n            }\n            function w(A) {\n              return A < 128 ? r[A] : t.NonAsciiIdentifierStart.test(p(A));\n            }\n            function T(A) {\n              return A < 128 ? u[A] : t.NonAsciiIdentifierPart.test(p(A));\n            }\n            n.exports = {\n              isDecimalDigit: o,\n              isHexDigit: c,\n              isOctalDigit: v,\n              isWhiteSpace: m,\n              isLineTerminator: d,\n              isIdentifierStartES5: f,\n              isIdentifierPartES5: h,\n              isIdentifierStartES6: w,\n              isIdentifierPartES6: T\n            };\n          }();\n        }\n      }),\n      Tm = Z({\n        \"node_modules/esutils/lib/keyword.js\"(e, n) {\n          re(), function () {\n            \"use strict\";\n\n            var t = $a();\n            function s(f) {\n              switch (f) {\n                case \"implements\":\n                case \"interface\":\n                case \"package\":\n                case \"private\":\n                case \"protected\":\n                case \"public\":\n                case \"static\":\n                case \"let\":\n                  return !0;\n                default:\n                  return !1;\n              }\n            }\n            function a(f, h) {\n              return !h && f === \"yield\" ? !1 : r(f, h);\n            }\n            function r(f, h) {\n              if (h && s(f)) return !0;\n              switch (f.length) {\n                case 2:\n                  return f === \"if\" || f === \"in\" || f === \"do\";\n                case 3:\n                  return f === \"var\" || f === \"for\" || f === \"new\" || f === \"try\";\n                case 4:\n                  return f === \"this\" || f === \"else\" || f === \"case\" || f === \"void\" || f === \"with\" || f === \"enum\";\n                case 5:\n                  return f === \"while\" || f === \"break\" || f === \"catch\" || f === \"throw\" || f === \"const\" || f === \"yield\" || f === \"class\" || f === \"super\";\n                case 6:\n                  return f === \"return\" || f === \"typeof\" || f === \"delete\" || f === \"switch\" || f === \"export\" || f === \"import\";\n                case 7:\n                  return f === \"default\" || f === \"finally\" || f === \"extends\";\n                case 8:\n                  return f === \"function\" || f === \"continue\" || f === \"debugger\";\n                case 10:\n                  return f === \"instanceof\";\n                default:\n                  return !1;\n              }\n            }\n            function u(f, h) {\n              return f === \"null\" || f === \"true\" || f === \"false\" || a(f, h);\n            }\n            function i(f, h) {\n              return f === \"null\" || f === \"true\" || f === \"false\" || r(f, h);\n            }\n            function o(f) {\n              return f === \"eval\" || f === \"arguments\";\n            }\n            function c(f) {\n              var h, w, T;\n              if (f.length === 0 || (T = f.charCodeAt(0), !t.isIdentifierStartES5(T))) return !1;\n              for (h = 1, w = f.length; h < w; ++h) if (T = f.charCodeAt(h), !t.isIdentifierPartES5(T)) return !1;\n              return !0;\n            }\n            function v(f, h) {\n              return (f - 55296) * 1024 + (h - 56320) + 65536;\n            }\n            function m(f) {\n              var h, w, T, A, S;\n              if (f.length === 0) return !1;\n              for (S = t.isIdentifierStartES6, h = 0, w = f.length; h < w; ++h) {\n                if (T = f.charCodeAt(h), 55296 <= T && T <= 56319) {\n                  if (++h, h >= w || (A = f.charCodeAt(h), !(56320 <= A && A <= 57343))) return !1;\n                  T = v(T, A);\n                }\n                if (!S(T)) return !1;\n                S = t.isIdentifierPartES6;\n              }\n              return !0;\n            }\n            function d(f, h) {\n              return c(f) && !u(f, h);\n            }\n            function p(f, h) {\n              return m(f) && !i(f, h);\n            }\n            n.exports = {\n              isKeywordES5: a,\n              isKeywordES6: r,\n              isReservedWordES5: u,\n              isReservedWordES6: i,\n              isRestrictedWord: o,\n              isIdentifierNameES5: c,\n              isIdentifierNameES6: m,\n              isIdentifierES5: d,\n              isIdentifierES6: p\n            };\n          }();\n        }\n      }),\n      Bm = Z({\n        \"node_modules/esutils/lib/utils.js\"(e) {\n          re(), function () {\n            \"use strict\";\n\n            e.ast = bm(), e.code = $a(), e.keyword = Tm();\n          }();\n        }\n      }),\n      It = Z({\n        \"src/language-js/utils/is-block-comment.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = new Set([\"Block\", \"CommentBlock\", \"MultiLine\"]),\n            s = a => t.has(a == null ? void 0 : a.type);\n          n.exports = s;\n        }\n      }),\n      Nm = Z({\n        \"src/language-js/utils/is-node-matches.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(a, r) {\n            let u = r.split(\".\");\n            for (let i = u.length - 1; i >= 0; i--) {\n              let o = u[i];\n              if (i === 0) return a.type === \"Identifier\" && a.name === o;\n              if (a.type !== \"MemberExpression\" || a.optional || a.computed || a.property.type !== \"Identifier\" || a.property.name !== o) return !1;\n              a = a.object;\n            }\n          }\n          function s(a, r) {\n            return r.some(u => t(a, u));\n          }\n          n.exports = s;\n        }\n      }),\n      Ke = Z({\n        \"src/language-js/utils/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Bm().keyword.isIdentifierNameES5,\n            {\n              getLast: s,\n              hasNewline: a,\n              skipWhitespace: r,\n              isNonEmptyArray: u,\n              isNextLineEmptyAfterIndex: i,\n              getStringWidth: o\n            } = Ue(),\n            {\n              locStart: c,\n              locEnd: v,\n              hasSameLocStart: m\n            } = st(),\n            d = It(),\n            p = Nm(),\n            f = \"(?:(?=.)\\\\s)\",\n            h = new RegExp(\"^\".concat(f, \"*:\")),\n            w = new RegExp(\"^\".concat(f, \"*::\"));\n          function T(O) {\n            var fe, Te;\n            return ((fe = O.extra) === null || fe === void 0 ? void 0 : fe.parenthesized) && d((Te = O.trailingComments) === null || Te === void 0 ? void 0 : Te[0]) && h.test(O.trailingComments[0].value);\n          }\n          function A(O) {\n            let fe = O == null ? void 0 : O[0];\n            return d(fe) && w.test(fe.value);\n          }\n          function S(O, fe) {\n            if (!O || typeof O != \"object\") return !1;\n            if (Array.isArray(O)) return O.some($e => S($e, fe));\n            let Te = fe(O);\n            return typeof Te == \"boolean\" ? Te : Object.values(O).some($e => S($e, fe));\n          }\n          function B(O) {\n            return O.type === \"AssignmentExpression\" || O.type === \"BinaryExpression\" || O.type === \"LogicalExpression\" || O.type === \"NGPipeExpression\" || O.type === \"ConditionalExpression\" || ue(O) || De(O) || O.type === \"SequenceExpression\" || O.type === \"TaggedTemplateExpression\" || O.type === \"BindExpression\" || O.type === \"UpdateExpression\" && !O.prefix || O.type === \"TSAsExpression\" || O.type === \"TSNonNullExpression\";\n          }\n          function I(O) {\n            var fe, Te, $e, Je, Ze, ut;\n            return O.expressions ? O.expressions[0] : (fe = (Te = ($e = (Je = (Ze = (ut = O.left) !== null && ut !== void 0 ? ut : O.test) !== null && Ze !== void 0 ? Ze : O.callee) !== null && Je !== void 0 ? Je : O.object) !== null && $e !== void 0 ? $e : O.tag) !== null && Te !== void 0 ? Te : O.argument) !== null && fe !== void 0 ? fe : O.expression;\n          }\n          function k(O, fe) {\n            if (fe.expressions) return [\"expressions\", 0];\n            if (fe.left) return [\"left\"];\n            if (fe.test) return [\"test\"];\n            if (fe.object) return [\"object\"];\n            if (fe.callee) return [\"callee\"];\n            if (fe.tag) return [\"tag\"];\n            if (fe.argument) return [\"argument\"];\n            if (fe.expression) return [\"expression\"];\n            throw new Error(\"Unexpected node has no left side.\");\n          }\n          function P(O) {\n            return O = new Set(O), fe => O.has(fe == null ? void 0 : fe.type);\n          }\n          var C = P([\"Line\", \"CommentLine\", \"SingleLine\", \"HashbangComment\", \"HTMLOpen\", \"HTMLClose\"]),\n            D = P([\"ExportDefaultDeclaration\", \"ExportDefaultSpecifier\", \"DeclareExportDeclaration\", \"ExportNamedDeclaration\", \"ExportAllDeclaration\"]);\n          function g(O) {\n            let fe = O.getParentNode();\n            return O.getName() === \"declaration\" && D(fe) ? fe : null;\n          }\n          var F = P([\"BooleanLiteral\", \"DirectiveLiteral\", \"Literal\", \"NullLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"RegExpLiteral\", \"StringLiteral\", \"TemplateLiteral\", \"TSTypeLiteral\", \"JSXText\"]);\n          function l(O) {\n            return O.type === \"NumericLiteral\" || O.type === \"Literal\" && typeof O.value == \"number\";\n          }\n          function E(O) {\n            return O.type === \"UnaryExpression\" && (O.operator === \"+\" || O.operator === \"-\") && l(O.argument);\n          }\n          function y(O) {\n            return O.type === \"StringLiteral\" || O.type === \"Literal\" && typeof O.value == \"string\";\n          }\n          var N = P([\"ObjectTypeAnnotation\", \"TSTypeLiteral\", \"TSMappedType\"]),\n            x = P([\"FunctionExpression\", \"ArrowFunctionExpression\"]);\n          function b(O) {\n            return O.type === \"FunctionExpression\" || O.type === \"ArrowFunctionExpression\" && O.body.type === \"BlockStatement\";\n          }\n          function L(O) {\n            return ue(O) && O.callee.type === \"Identifier\" && [\"async\", \"inject\", \"fakeAsync\", \"waitForAsync\"].includes(O.callee.name);\n          }\n          var M = P([\"JSXElement\", \"JSXFragment\"]);\n          function j(O, fe) {\n            if (O.parentParser !== \"markdown\" && O.parentParser !== \"mdx\") return !1;\n            let Te = fe.getNode();\n            if (!Te.expression || !M(Te.expression)) return !1;\n            let $e = fe.getParentNode();\n            return $e.type === \"Program\" && $e.body.length === 1;\n          }\n          function $(O) {\n            return O.kind === \"get\" || O.kind === \"set\";\n          }\n          function V(O) {\n            return $(O) || m(O, O.value);\n          }\n          function q(O) {\n            return (O.type === \"ObjectTypeProperty\" || O.type === \"ObjectTypeInternalSlot\") && O.value.type === \"FunctionTypeAnnotation\" && !O.static && !V(O);\n          }\n          function Y(O) {\n            return (O.type === \"TypeAnnotation\" || O.type === \"TSTypeAnnotation\") && O.typeAnnotation.type === \"FunctionTypeAnnotation\" && !O.static && !m(O, O.typeAnnotation);\n          }\n          var H = P([\"BinaryExpression\", \"LogicalExpression\", \"NGPipeExpression\"]);\n          function R(O) {\n            return De(O) || O.type === \"BindExpression\" && Boolean(O.object);\n          }\n          var Q = new Set([\"AnyTypeAnnotation\", \"TSAnyKeyword\", \"NullLiteralTypeAnnotation\", \"TSNullKeyword\", \"ThisTypeAnnotation\", \"TSThisType\", \"NumberTypeAnnotation\", \"TSNumberKeyword\", \"VoidTypeAnnotation\", \"TSVoidKeyword\", \"BooleanTypeAnnotation\", \"TSBooleanKeyword\", \"BigIntTypeAnnotation\", \"TSBigIntKeyword\", \"SymbolTypeAnnotation\", \"TSSymbolKeyword\", \"StringTypeAnnotation\", \"TSStringKeyword\", \"BooleanLiteralTypeAnnotation\", \"StringLiteralTypeAnnotation\", \"BigIntLiteralTypeAnnotation\", \"NumberLiteralTypeAnnotation\", \"TSLiteralType\", \"TSTemplateLiteralType\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"TSNeverKeyword\", \"TSObjectKeyword\", \"TSUndefinedKeyword\", \"TSUnknownKeyword\"]);\n          function ee(O) {\n            return O ? !!((O.type === \"GenericTypeAnnotation\" || O.type === \"TSTypeReference\") && !O.typeParameters || Q.has(O.type)) : !1;\n          }\n          function te(O) {\n            let fe = /^(?:before|after)(?:Each|All)$/;\n            return O.callee.type === \"Identifier\" && fe.test(O.callee.name) && O.arguments.length === 1;\n          }\n          var oe = [\"it\", \"it.only\", \"it.skip\", \"describe\", \"describe.only\", \"describe.skip\", \"test\", \"test.only\", \"test.skip\", \"test.step\", \"test.describe\", \"test.describe.only\", \"test.describe.parallel\", \"test.describe.parallel.only\", \"test.describe.serial\", \"test.describe.serial.only\", \"skip\", \"xit\", \"xdescribe\", \"xtest\", \"fit\", \"fdescribe\", \"ftest\"];\n          function W(O) {\n            return p(O, oe);\n          }\n          function X(O, fe) {\n            if (O.type !== \"CallExpression\") return !1;\n            if (O.arguments.length === 1) {\n              if (L(O) && fe && X(fe)) return x(O.arguments[0]);\n              if (te(O)) return L(O.arguments[0]);\n            } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === \"TemplateLiteral\" || y(O.arguments[0])) && W(O.callee)) return O.arguments[2] && !l(O.arguments[2]) ? !1 : (O.arguments.length === 2 ? x(O.arguments[1]) : b(O.arguments[1]) && Se(O.arguments[1]).length <= 1) || L(O.arguments[1]);\n            return !1;\n          }\n          var ue = P([\"CallExpression\", \"OptionalCallExpression\"]),\n            De = P([\"MemberExpression\", \"OptionalMemberExpression\"]);\n          function ie(O) {\n            let fe = \"expressions\";\n            O.type === \"TSTemplateLiteralType\" && (fe = \"types\");\n            let Te = O[fe];\n            return Te.length === 0 ? !1 : Te.every($e => {\n              if (se($e)) return !1;\n              if ($e.type === \"Identifier\" || $e.type === \"ThisExpression\") return !0;\n              if (De($e)) {\n                let Je = $e;\n                for (; De(Je);) if (Je.property.type !== \"Identifier\" && Je.property.type !== \"Literal\" && Je.property.type !== \"StringLiteral\" && Je.property.type !== \"NumericLiteral\" || (Je = Je.object, se(Je))) return !1;\n                return Je.type === \"Identifier\" || Je.type === \"ThisExpression\";\n              }\n              return !1;\n            });\n          }\n          function G(O, fe) {\n            return O === \"+\" || O === \"-\" ? O + fe : fe;\n          }\n          function z(O, fe) {\n            let Te = c(fe),\n              $e = r(O, v(fe));\n            return $e !== !1 && O.slice(Te, Te + 2) === \"/*\" && O.slice($e, $e + 2) === \"*/\";\n          }\n          function U(O, fe) {\n            return M(fe) ? Re(fe) : se(fe, Le.Leading, Te => a(O, v(Te)));\n          }\n          function le(O, fe) {\n            return fe.parser !== \"json\" && y(O.key) && ve(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(fe.parser === \"babel-ts\" && O.type === \"ClassProperty\" || fe.parser === \"typescript\" && O.type === \"PropertyDefinition\") || ge(O.key.value) && String(Number(O.key.value)) === O.key.value && (fe.parser === \"babel\" || fe.parser === \"acorn\" || fe.parser === \"espree\" || fe.parser === \"meriyah\" || fe.parser === \"__babel_estree\"));\n          }\n          function ge(O) {\n            return /^(?:\\d+|\\d+\\.\\d+)$/.test(O);\n          }\n          function Ae(O, fe) {\n            let Te = /^[fx]?(?:describe|it|test)$/;\n            return fe.type === \"TaggedTemplateExpression\" && fe.quasi === O && fe.tag.type === \"MemberExpression\" && fe.tag.property.type === \"Identifier\" && fe.tag.property.name === \"each\" && (fe.tag.object.type === \"Identifier\" && Te.test(fe.tag.object.name) || fe.tag.object.type === \"MemberExpression\" && fe.tag.object.property.type === \"Identifier\" && (fe.tag.object.property.name === \"only\" || fe.tag.object.property.name === \"skip\") && fe.tag.object.object.type === \"Identifier\" && Te.test(fe.tag.object.object.name));\n          }\n          function Ne(O) {\n            return O.quasis.some(fe => fe.value.raw.includes(`\n`));\n          }\n          function ke(O, fe) {\n            return (O.type === \"TemplateLiteral\" && Ne(O) || O.type === \"TaggedTemplateExpression\" && Ne(O.quasi)) && !a(fe, c(O), {\n              backwards: !0\n            });\n          }\n          function ce(O) {\n            if (!se(O)) return !1;\n            let fe = s(He(O, Le.Dangling));\n            return fe && !d(fe);\n          }\n          function pe(O) {\n            if (O.length <= 1) return !1;\n            let fe = 0;\n            for (let Te of O) if (x(Te)) {\n              if (fe += 1, fe > 1) return !0;\n            } else if (ue(Te)) {\n              for (let $e of Te.arguments) if (x($e)) return !0;\n            }\n            return !1;\n          }\n          function de(O) {\n            let fe = O.getValue(),\n              Te = O.getParentNode();\n            return ue(fe) && ue(Te) && Te.callee === fe && fe.arguments.length > Te.arguments.length && Te.arguments.length > 0;\n          }\n          function ae(O, fe) {\n            if (fe >= 2) return !1;\n            let Te = Je => ae(Je, fe + 1),\n              $e = O.type === \"Literal\" && \"regex\" in O && O.regex.pattern || O.type === \"RegExpLiteral\" && O.pattern;\n            return $e && o($e) > 5 ? !1 : O.type === \"Literal\" || O.type === \"BigIntLiteral\" || O.type === \"DecimalLiteral\" || O.type === \"BooleanLiteral\" || O.type === \"NullLiteral\" || O.type === \"NumericLiteral\" || O.type === \"RegExpLiteral\" || O.type === \"StringLiteral\" || O.type === \"Identifier\" || O.type === \"ThisExpression\" || O.type === \"Super\" || O.type === \"PrivateName\" || O.type === \"PrivateIdentifier\" || O.type === \"ArgumentPlaceholder\" || O.type === \"Import\" ? !0 : O.type === \"TemplateLiteral\" ? O.quasis.every(Je => !Je.value.raw.includes(`\n`)) && O.expressions.every(Te) : O.type === \"ObjectExpression\" ? O.properties.every(Je => !Je.computed && (Je.shorthand || Je.value && Te(Je.value))) : O.type === \"ArrayExpression\" ? O.elements.every(Je => Je === null || Te(Je)) : ze(O) ? (O.type === \"ImportExpression\" || ae(O.callee, fe)) && Xe(O).every(Te) : De(O) ? ae(O.object, fe) && ae(O.property, fe) : O.type === \"UnaryExpression\" && (O.operator === \"!\" || O.operator === \"-\") ? ae(O.argument, fe) : O.type === \"TSNonNullExpression\" ? ae(O.expression, fe) : !1;\n          }\n          function ve(O) {\n            var fe, Te;\n            return (fe = (Te = O.extra) === null || Te === void 0 ? void 0 : Te.raw) !== null && fe !== void 0 ? fe : O.raw;\n          }\n          function K(O) {\n            return O;\n          }\n          function he(O) {\n            return O.filepath && /\\.tsx$/i.test(O.filepath);\n          }\n          function ye(O) {\n            let fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"es5\";\n            return O.trailingComma === \"es5\" && fe === \"es5\" || O.trailingComma === \"all\" && (fe === \"all\" || fe === \"es5\");\n          }\n          function Ce(O, fe) {\n            switch (O = Ee(O), O.type) {\n              case \"FunctionExpression\":\n              case \"ClassExpression\":\n              case \"DoExpression\":\n                return fe;\n              case \"ObjectExpression\":\n                return !0;\n              case \"MemberExpression\":\n              case \"OptionalMemberExpression\":\n                return Ce(O.object, fe);\n              case \"TaggedTemplateExpression\":\n                return O.tag.type === \"FunctionExpression\" ? !1 : Ce(O.tag, fe);\n              case \"CallExpression\":\n              case \"OptionalCallExpression\":\n                return O.callee.type === \"FunctionExpression\" ? !1 : Ce(O.callee, fe);\n              case \"ConditionalExpression\":\n                return Ce(O.test, fe);\n              case \"UpdateExpression\":\n                return !O.prefix && Ce(O.argument, fe);\n              case \"BindExpression\":\n                return O.object && Ce(O.object, fe);\n              case \"SequenceExpression\":\n                return Ce(O.expressions[0], fe);\n              case \"TSAsExpression\":\n              case \"TSNonNullExpression\":\n                return Ce(O.expression, fe);\n              default:\n                return !1;\n            }\n          }\n          var Ie = {\n              \"==\": !0,\n              \"!=\": !0,\n              \"===\": !0,\n              \"!==\": !0\n            },\n            Fe = {\n              \"*\": !0,\n              \"/\": !0,\n              \"%\": !0\n            },\n            me = {\n              \">>\": !0,\n              \">>>\": !0,\n              \"<<\": !0\n            };\n          function _(O, fe) {\n            return !(ne(fe) !== ne(O) || O === \"**\" || Ie[O] && Ie[fe] || fe === \"%\" && Fe[O] || O === \"%\" && Fe[fe] || fe !== O && Fe[fe] && Fe[O] || me[O] && me[fe]);\n          }\n          var J = new Map([[\"|>\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].flatMap((O, fe) => O.map(Te => [Te, fe])));\n          function ne(O) {\n            return J.get(O);\n          }\n          function Ee(O) {\n            for (; O.left;) O = O.left;\n            return O;\n          }\n          function We(O) {\n            return Boolean(me[O]) || O === \"|\" || O === \"^\" || O === \"&\";\n          }\n          function Be(O) {\n            var fe;\n            if (O.rest) return !0;\n            let Te = Se(O);\n            return ((fe = s(Te)) === null || fe === void 0 ? void 0 : fe.type) === \"RestElement\";\n          }\n          var Pe = new WeakMap();\n          function Se(O) {\n            if (Pe.has(O)) return Pe.get(O);\n            let fe = [];\n            return O.this && fe.push(O.this), Array.isArray(O.parameters) ? fe.push(...O.parameters) : Array.isArray(O.params) && fe.push(...O.params), O.rest && fe.push(O.rest), Pe.set(O, fe), fe;\n          }\n          function Qe(O, fe) {\n            let Te = O.getValue(),\n              $e = 0,\n              Je = Ze => fe(Ze, $e++);\n            Te.this && O.call(Je, \"this\"), Array.isArray(Te.parameters) ? O.each(Je, \"parameters\") : Array.isArray(Te.params) && O.each(Je, \"params\"), Te.rest && O.call(Je, \"rest\");\n          }\n          var xe = new WeakMap();\n          function Xe(O) {\n            if (xe.has(O)) return xe.get(O);\n            let fe = O.arguments;\n            return O.type === \"ImportExpression\" && (fe = [O.source], O.attributes && fe.push(O.attributes)), xe.set(O, fe), fe;\n          }\n          function _e(O, fe) {\n            let Te = O.getValue();\n            Te.type === \"ImportExpression\" ? (O.call($e => fe($e, 0), \"source\"), Te.attributes && O.call($e => fe($e, 1), \"attributes\")) : O.each(fe, \"arguments\");\n          }\n          function je(O) {\n            return O.value.trim() === \"prettier-ignore\" && !O.unignore;\n          }\n          function Re(O) {\n            return O && (O.prettierIgnore || se(O, Le.PrettierIgnore));\n          }\n          function be(O) {\n            let fe = O.getValue();\n            return Re(fe);\n          }\n          var Le = {\n              Leading: 1 << 1,\n              Trailing: 1 << 2,\n              Dangling: 1 << 3,\n              Block: 1 << 4,\n              Line: 1 << 5,\n              PrettierIgnore: 1 << 6,\n              First: 1 << 7,\n              Last: 1 << 8\n            },\n            qe = (O, fe) => {\n              if (typeof O == \"function\" && (fe = O, O = 0), O || fe) return (Te, $e, Je) => !(O & Le.Leading && !Te.leading || O & Le.Trailing && !Te.trailing || O & Le.Dangling && (Te.leading || Te.trailing) || O & Le.Block && !d(Te) || O & Le.Line && !C(Te) || O & Le.First && $e !== 0 || O & Le.Last && $e !== Je.length - 1 || O & Le.PrettierIgnore && !je(Te) || fe && !fe(Te));\n            };\n          function se(O, fe, Te) {\n            if (!u(O == null ? void 0 : O.comments)) return !1;\n            let $e = qe(fe, Te);\n            return $e ? O.comments.some($e) : !0;\n          }\n          function He(O, fe, Te) {\n            if (!Array.isArray(O == null ? void 0 : O.comments)) return [];\n            let $e = qe(fe, Te);\n            return $e ? O.comments.filter($e) : O.comments;\n          }\n          var Me = (O, fe) => {\n            let {\n              originalText: Te\n            } = fe;\n            return i(Te, v(O));\n          };\n          function ze(O) {\n            return ue(O) || O.type === \"NewExpression\" || O.type === \"ImportExpression\";\n          }\n          function nt(O) {\n            return O && (O.type === \"ObjectProperty\" || O.type === \"Property\" && !O.method && O.kind === \"init\");\n          }\n          function tt(O) {\n            return Boolean(O.__isUsingHackPipeline);\n          }\n          var pt = Symbol(\"ifWithoutBlockAndSameLineComment\");\n          n.exports = {\n            getFunctionParameters: Se,\n            iterateFunctionParametersPath: Qe,\n            getCallArguments: Xe,\n            iterateCallArgumentsPath: _e,\n            hasRestParameter: Be,\n            getLeftSide: I,\n            getLeftSidePathName: k,\n            getParentExportDeclaration: g,\n            getTypeScriptMappedTypeModifier: G,\n            hasFlowAnnotationComment: A,\n            hasFlowShorthandAnnotationComment: T,\n            hasLeadingOwnLineComment: U,\n            hasNakedLeftSide: B,\n            hasNode: S,\n            hasIgnoreComment: be,\n            hasNodeIgnoreComment: Re,\n            identity: K,\n            isBinaryish: H,\n            isCallLikeExpression: ze,\n            isEnabledHackPipeline: tt,\n            isLineComment: C,\n            isPrettierIgnoreComment: je,\n            isCallExpression: ue,\n            isMemberExpression: De,\n            isExportDeclaration: D,\n            isFlowAnnotationComment: z,\n            isFunctionCompositionArgs: pe,\n            isFunctionNotation: V,\n            isFunctionOrArrowExpression: x,\n            isGetterOrSetter: $,\n            isJestEachTemplateLiteral: Ae,\n            isJsxNode: M,\n            isLiteral: F,\n            isLongCurriedCallExpression: de,\n            isSimpleCallArgument: ae,\n            isMemberish: R,\n            isNumericLiteral: l,\n            isSignedNumericLiteral: E,\n            isObjectProperty: nt,\n            isObjectType: N,\n            isObjectTypePropertyAFunction: q,\n            isSimpleType: ee,\n            isSimpleNumber: ge,\n            isSimpleTemplateLiteral: ie,\n            isStringLiteral: y,\n            isStringPropSafeToUnquote: le,\n            isTemplateOnItsOwnLine: ke,\n            isTestCall: X,\n            isTheOnlyJsxElementInMarkdown: j,\n            isTSXFile: he,\n            isTypeAnnotationAFunction: Y,\n            isNextLineEmpty: Me,\n            needsHardlineAfterDanglingComment: ce,\n            rawText: ve,\n            shouldPrintComma: ye,\n            isBitwiseOperator: We,\n            shouldFlatten: _,\n            startsWithNoLookaheadToken: Ce,\n            getPrecedence: ne,\n            hasComment: se,\n            getComments: He,\n            CommentCheckFlags: Le,\n            markerForIfWithoutBlockAndSameLineComment: pt\n          };\n        }\n      }),\n      Lt = Z({\n        \"src/language-js/print/template-literal.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = it(),\n            {\n              getStringWidth: s,\n              getIndentSize: a\n            } = Ue(),\n            {\n              builders: {\n                join: r,\n                hardline: u,\n                softline: i,\n                group: o,\n                indent: c,\n                align: v,\n                lineSuffixBoundary: m,\n                addAlignmentToDoc: d\n              },\n              printer: {\n                printDocToString: p\n              },\n              utils: {\n                mapDoc: f\n              }\n            } = Oe(),\n            {\n              isBinaryish: h,\n              isJestEachTemplateLiteral: w,\n              isSimpleTemplateLiteral: T,\n              hasComment: A,\n              isMemberExpression: S\n            } = Ke();\n          function B(g, F, l) {\n            let E = g.getValue();\n            if (E.type === \"TemplateLiteral\" && w(E, g.getParentNode())) {\n              let M = I(g, l, F);\n              if (M) return M;\n            }\n            let N = \"expressions\";\n            E.type === \"TSTemplateLiteralType\" && (N = \"types\");\n            let x = [],\n              b = g.map(F, N),\n              L = T(E);\n            return L && (b = b.map(M => p(M, Object.assign(Object.assign({}, l), {}, {\n              printWidth: Number.POSITIVE_INFINITY\n            })).formatted)), x.push(m, \"`\"), g.each(M => {\n              let j = M.getName();\n              if (x.push(F()), j < b.length) {\n                let {\n                    tabWidth: $\n                  } = l,\n                  V = M.getValue(),\n                  q = a(V.value.raw, $),\n                  Y = b[j];\n                if (!L) {\n                  let R = E[N][j];\n                  (A(R) || S(R) || R.type === \"ConditionalExpression\" || R.type === \"SequenceExpression\" || R.type === \"TSAsExpression\" || h(R)) && (Y = [c([i, Y]), i]);\n                }\n                let H = q === 0 && V.value.raw.endsWith(`\n`) ? v(Number.NEGATIVE_INFINITY, Y) : d(Y, q, $);\n                x.push(o([\"${\", H, m, \"}\"]));\n              }\n            }, \"quasis\"), x.push(\"`\"), x;\n          }\n          function I(g, F, l) {\n            let E = g.getNode(),\n              y = E.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n            if (y.length > 1 || y.some(N => N.length > 0)) {\n              F.__inJestEach = !0;\n              let N = g.map(l, \"expressions\");\n              F.__inJestEach = !1;\n              let x = [],\n                b = N.map(V => \"${\" + p(V, Object.assign(Object.assign({}, F), {}, {\n                  printWidth: Number.POSITIVE_INFINITY,\n                  endOfLine: \"lf\"\n                })).formatted + \"}\"),\n                L = [{\n                  hasLineBreak: !1,\n                  cells: []\n                }];\n              for (let V = 1; V < E.quasis.length; V++) {\n                let q = t(L),\n                  Y = b[V - 1];\n                q.cells.push(Y), Y.includes(`\n`) && (q.hasLineBreak = !0), E.quasis[V].value.raw.includes(`\n`) && L.push({\n                  hasLineBreak: !1,\n                  cells: []\n                });\n              }\n              let M = Math.max(y.length, ...L.map(V => V.cells.length)),\n                j = Array.from({\n                  length: M\n                }).fill(0),\n                $ = [{\n                  cells: y\n                }, ...L.filter(V => V.cells.length > 0)];\n              for (let {\n                cells: V\n              } of $.filter(q => !q.hasLineBreak)) for (let [q, Y] of V.entries()) j[q] = Math.max(j[q], s(Y));\n              return x.push(m, \"`\", c([u, r(u, $.map(V => r(\" | \", V.cells.map((q, Y) => V.hasLineBreak ? q : q + \" \".repeat(j[Y] - s(q))))))]), u, \"`\"), x;\n            }\n          }\n          function k(g, F) {\n            let l = g.getValue(),\n              E = F();\n            return A(l) && (E = o([c([i, E]), i])), [\"${\", E, m, \"}\"];\n          }\n          function P(g, F) {\n            return g.map(l => k(l, F), \"expressions\");\n          }\n          function C(g, F) {\n            return f(g, l => typeof l == \"string\" ? F ? l.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : D(l) : l);\n          }\n          function D(g) {\n            return g.replace(/([\\\\`]|\\${)/g, \"\\\\$1\");\n          }\n          n.exports = {\n            printTemplateLiteral: B,\n            printTemplateExpressions: P,\n            escapeTemplateCharacters: C,\n            uncookTemplateElementValue: D\n          };\n        }\n      }),\n      wm = Z({\n        \"src/language-js/embed/markdown.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                indent: t,\n                softline: s,\n                literalline: a,\n                dedentToRoot: r\n              }\n            } = Oe(),\n            {\n              escapeTemplateCharacters: u\n            } = Lt();\n          function i(c, v, m) {\n            let p = c.getValue().quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, (T, A) => \"\\\\\".repeat(A.length / 2) + \"`\"),\n              f = o(p),\n              h = f !== \"\";\n            h && (p = p.replace(new RegExp(\"^\".concat(f), \"gm\"), \"\"));\n            let w = u(m(p, {\n              parser: \"markdown\",\n              __inJsTemplate: !0\n            }, {\n              stripTrailingHardline: !0\n            }), !0);\n            return [\"`\", h ? t([s, w]) : [a, r(w)], s, \"`\"];\n          }\n          function o(c) {\n            let v = c.match(/^([^\\S\\n]*)\\S/m);\n            return v === null ? \"\" : v[1];\n          }\n          n.exports = i;\n        }\n      }),\n      _m = Z({\n        \"src/language-js/embed/css.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isNonEmptyArray: t\n            } = Ue(),\n            {\n              builders: {\n                indent: s,\n                hardline: a,\n                softline: r\n              },\n              utils: {\n                mapDoc: u,\n                replaceEndOfLine: i,\n                cleanDoc: o\n              }\n            } = Oe(),\n            {\n              printTemplateExpressions: c\n            } = Lt();\n          function v(p, f, h) {\n            let w = p.getValue(),\n              T = w.quasis.map(k => k.value.raw),\n              A = 0,\n              S = T.reduce((k, P, C) => C === 0 ? P : k + \"@prettier-placeholder-\" + A++ + \"-id\" + P, \"\"),\n              B = h(S, {\n                parser: \"scss\"\n              }, {\n                stripTrailingHardline: !0\n              }),\n              I = c(p, f);\n            return m(B, w, I);\n          }\n          function m(p, f, h) {\n            if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim()) return \"``\";\n            let T = d(p, h);\n            if (!T) throw new Error(\"Couldn't insert all the expressions\");\n            return [\"`\", s([a, T]), r, \"`\"];\n          }\n          function d(p, f) {\n            if (!t(f)) return p;\n            let h = 0,\n              w = u(o(p), T => typeof T != \"string\" || !T.includes(\"@prettier-placeholder\") ? T : T.split(/@prettier-placeholder-(\\d+)-id/).map((A, S) => S % 2 === 0 ? i(A) : (h++, f[A])));\n            return f.length === h ? w : null;\n          }\n          n.exports = v;\n        }\n      }),\n      Pm = Z({\n        \"src/language-js/embed/graphql.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                indent: t,\n                join: s,\n                hardline: a\n              }\n            } = Oe(),\n            {\n              escapeTemplateCharacters: r,\n              printTemplateExpressions: u\n            } = Lt();\n          function i(c, v, m) {\n            let d = c.getValue(),\n              p = d.quasis.length;\n            if (p === 1 && d.quasis[0].value.raw.trim() === \"\") return \"``\";\n            let f = u(c, v),\n              h = [];\n            for (let w = 0; w < p; w++) {\n              let T = d.quasis[w],\n                A = w === 0,\n                S = w === p - 1,\n                B = T.value.cooked,\n                I = B.split(`\n`),\n                k = I.length,\n                P = f[w],\n                C = k > 2 && I[0].trim() === \"\" && I[1].trim() === \"\",\n                D = k > 2 && I[k - 1].trim() === \"\" && I[k - 2].trim() === \"\",\n                g = I.every(l => /^\\s*(?:#[^\\n\\r]*)?$/.test(l));\n              if (!S && /#[^\\n\\r]*$/.test(I[k - 1])) return null;\n              let F = null;\n              g ? F = o(I) : F = m(B, {\n                parser: \"graphql\"\n              }, {\n                stripTrailingHardline: !0\n              }), F ? (F = r(F, !1), !A && C && h.push(\"\"), h.push(F), !S && D && h.push(\"\")) : !A && !S && C && h.push(\"\"), P && h.push(P);\n            }\n            return [\"`\", t([a, s(a, h)]), a, \"`\"];\n          }\n          function o(c) {\n            let v = [],\n              m = !1,\n              d = c.map(p => p.trim());\n            for (let [p, f] of d.entries()) f !== \"\" && (d[p - 1] === \"\" && m ? v.push([a, f]) : v.push(f), m = !0);\n            return v.length === 0 ? null : s(a, v);\n          }\n          n.exports = i;\n        }\n      }),\n      km = Z({\n        \"src/language-js/embed/html.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                indent: t,\n                line: s,\n                hardline: a,\n                group: r\n              },\n              utils: {\n                mapDoc: u\n              }\n            } = Oe(),\n            {\n              printTemplateExpressions: i,\n              uncookTemplateElementValue: o\n            } = Lt(),\n            c = 0;\n          function v(m, d, p, f, h) {\n            let {\n                parser: w\n              } = h,\n              T = m.getValue(),\n              A = c;\n            c = c + 1 >>> 0;\n            let S = E => \"PRETTIER_HTML_PLACEHOLDER_\".concat(E, \"_\").concat(A, \"_IN_JS\"),\n              B = T.quasis.map((E, y, N) => y === N.length - 1 ? E.value.cooked : E.value.cooked + S(y)).join(\"\"),\n              I = i(m, d);\n            if (I.length === 0 && B.trim().length === 0) return \"``\";\n            let k = new RegExp(S(\"(\\\\d+)\"), \"g\"),\n              P = 0,\n              C = p(B, {\n                parser: w,\n                __onHtmlRoot(E) {\n                  P = E.children.length;\n                }\n              }, {\n                stripTrailingHardline: !0\n              }),\n              D = u(C, E => {\n                if (typeof E != \"string\") return E;\n                let y = [],\n                  N = E.split(k);\n                for (let x = 0; x < N.length; x++) {\n                  let b = N[x];\n                  if (x % 2 === 0) {\n                    b && (b = o(b), f.__embeddedInHtml && (b = b.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\")), y.push(b));\n                    continue;\n                  }\n                  let L = Number(b);\n                  y.push(I[L]);\n                }\n                return y;\n              }),\n              g = /^\\s/.test(B) ? \" \" : \"\",\n              F = /\\s$/.test(B) ? \" \" : \"\",\n              l = f.htmlWhitespaceSensitivity === \"ignore\" ? a : g && F ? s : null;\n            return r(l ? [\"`\", t([l, r(D)]), l, \"`\"] : [\"`\", g, P > 1 ? t(r(D)) : r(D), F, \"`\"]);\n          }\n          n.exports = v;\n        }\n      }),\n      Im = Z({\n        \"src/language-js/embed.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              hasComment: t,\n              CommentCheckFlags: s,\n              isObjectProperty: a\n            } = Ke(),\n            r = wm(),\n            u = _m(),\n            i = Pm(),\n            o = km();\n          function c(C) {\n            if (d(C) || w(C) || T(C) || p(C)) return \"css\";\n            if (B(C)) return \"graphql\";\n            if (k(C)) return \"html\";\n            if (f(C)) return \"angular\";\n            if (m(C)) return \"markdown\";\n          }\n          function v(C, D, g, F) {\n            let l = C.getValue();\n            if (l.type !== \"TemplateLiteral\" || P(l)) return;\n            let E = c(C);\n            if (!!E) {\n              if (E === \"markdown\") return r(C, D, g);\n              if (E === \"css\") return u(C, D, g);\n              if (E === \"graphql\") return i(C, D, g);\n              if (E === \"html\" || E === \"angular\") return o(C, D, g, F, {\n                parser: E\n              });\n            }\n          }\n          function m(C) {\n            let D = C.getValue(),\n              g = C.getParentNode();\n            return g && g.type === \"TaggedTemplateExpression\" && D.quasis.length === 1 && g.tag.type === \"Identifier\" && (g.tag.name === \"md\" || g.tag.name === \"markdown\");\n          }\n          function d(C) {\n            let D = C.getValue(),\n              g = C.getParentNode(),\n              F = C.getParentNode(1);\n            return F && D.quasis && g.type === \"JSXExpressionContainer\" && F.type === \"JSXElement\" && F.openingElement.name.name === \"style\" && F.openingElement.attributes.some(l => l.name.name === \"jsx\") || g && g.type === \"TaggedTemplateExpression\" && g.tag.type === \"Identifier\" && g.tag.name === \"css\" || g && g.type === \"TaggedTemplateExpression\" && g.tag.type === \"MemberExpression\" && g.tag.object.name === \"css\" && (g.tag.property.name === \"global\" || g.tag.property.name === \"resolve\");\n          }\n          function p(C) {\n            return C.match(D => D.type === \"TemplateLiteral\", (D, g) => D.type === \"ArrayExpression\" && g === \"elements\", (D, g) => a(D) && D.key.type === \"Identifier\" && D.key.name === \"styles\" && g === \"value\", ...h);\n          }\n          function f(C) {\n            return C.match(D => D.type === \"TemplateLiteral\", (D, g) => a(D) && D.key.type === \"Identifier\" && D.key.name === \"template\" && g === \"value\", ...h);\n          }\n          var h = [(C, D) => C.type === \"ObjectExpression\" && D === \"properties\", (C, D) => C.type === \"CallExpression\" && C.callee.type === \"Identifier\" && C.callee.name === \"Component\" && D === \"arguments\", (C, D) => C.type === \"Decorator\" && D === \"expression\"];\n          function w(C) {\n            let D = C.getParentNode();\n            if (!D || D.type !== \"TaggedTemplateExpression\") return !1;\n            let g = D.tag.type === \"ParenthesizedExpression\" ? D.tag.expression : D.tag;\n            switch (g.type) {\n              case \"MemberExpression\":\n                return A(g.object) || S(g);\n              case \"CallExpression\":\n                return A(g.callee) || g.callee.type === \"MemberExpression\" && (g.callee.object.type === \"MemberExpression\" && (A(g.callee.object.object) || S(g.callee.object)) || g.callee.object.type === \"CallExpression\" && A(g.callee.object.callee));\n              case \"Identifier\":\n                return g.name === \"css\";\n              default:\n                return !1;\n            }\n          }\n          function T(C) {\n            let D = C.getParentNode(),\n              g = C.getParentNode(1);\n            return g && D.type === \"JSXExpressionContainer\" && g.type === \"JSXAttribute\" && g.name.type === \"JSXIdentifier\" && g.name.name === \"css\";\n          }\n          function A(C) {\n            return C.type === \"Identifier\" && C.name === \"styled\";\n          }\n          function S(C) {\n            return /^[A-Z]/.test(C.object.name) && C.property.name === \"extend\";\n          }\n          function B(C) {\n            let D = C.getValue(),\n              g = C.getParentNode();\n            return I(D, \"GraphQL\") || g && (g.type === \"TaggedTemplateExpression\" && (g.tag.type === \"MemberExpression\" && g.tag.object.name === \"graphql\" && g.tag.property.name === \"experimental\" || g.tag.type === \"Identifier\" && (g.tag.name === \"gql\" || g.tag.name === \"graphql\")) || g.type === \"CallExpression\" && g.callee.type === \"Identifier\" && g.callee.name === \"graphql\");\n          }\n          function I(C, D) {\n            return t(C, s.Block | s.Leading, g => {\n              let {\n                value: F\n              } = g;\n              return F === \" \".concat(D, \" \");\n            });\n          }\n          function k(C) {\n            return I(C.getValue(), \"HTML\") || C.match(D => D.type === \"TemplateLiteral\", (D, g) => D.type === \"TaggedTemplateExpression\" && D.tag.type === \"Identifier\" && D.tag.name === \"html\" && g === \"quasi\");\n          }\n          function P(C) {\n            let {\n              quasis: D\n            } = C;\n            return D.some(g => {\n              let {\n                value: {\n                  cooked: F\n                }\n              } = g;\n              return F === null;\n            });\n          }\n          n.exports = v;\n        }\n      }),\n      Lm = Z({\n        \"src/language-js/clean.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = It(),\n            s = new Set([\"range\", \"raw\", \"comments\", \"leadingComments\", \"trailingComments\", \"innerComments\", \"extra\", \"start\", \"end\", \"loc\", \"flags\", \"errors\", \"tokens\"]),\n            a = u => {\n              for (let i of u.quasis) delete i.value;\n            };\n          function r(u, i, o) {\n            if (u.type === \"Program\" && delete i.sourceType, (u.type === \"BigIntLiteral\" || u.type === \"BigIntLiteralTypeAnnotation\") && i.value && (i.value = i.value.toLowerCase()), (u.type === \"BigIntLiteral\" || u.type === \"Literal\") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === \"DecimalLiteral\" && (i.value = Number(i.value)), u.type === \"Literal\" && i.decimal && (i.decimal = Number(i.decimal)), u.type === \"EmptyStatement\" || u.type === \"JSXText\" || u.type === \"JSXExpressionContainer\" && (u.expression.type === \"Literal\" || u.expression.type === \"StringLiteral\") && u.expression.value === \" \") return null;\n            if ((u.type === \"Property\" || u.type === \"ObjectProperty\" || u.type === \"MethodDefinition\" || u.type === \"ClassProperty\" || u.type === \"ClassMethod\" || u.type === \"PropertyDefinition\" || u.type === \"TSDeclareMethod\" || u.type === \"TSPropertySignature\" || u.type === \"ObjectTypeProperty\") && typeof u.key == \"object\" && u.key && (u.key.type === \"Literal\" || u.key.type === \"NumericLiteral\" || u.key.type === \"StringLiteral\" || u.key.type === \"Identifier\") && delete i.key, u.type === \"JSXElement\" && u.openingElement.name.name === \"style\" && u.openingElement.attributes.some(m => m.name.name === \"jsx\")) for (let {\n              type: m,\n              expression: d\n            } of i.children) m === \"JSXExpressionContainer\" && d.type === \"TemplateLiteral\" && a(d);\n            u.type === \"JSXAttribute\" && u.name.name === \"css\" && u.value.type === \"JSXExpressionContainer\" && u.value.expression.type === \"TemplateLiteral\" && a(i.value.expression), u.type === \"JSXAttribute\" && u.value && u.value.type === \"Literal\" && /[\"']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/[\"']|&quot;|&apos;/g, '\"'));\n            let c = u.expression || u.callee;\n            if (u.type === \"Decorator\" && c.type === \"CallExpression\" && c.callee.name === \"Component\" && c.arguments.length === 1) {\n              let m = u.expression.arguments[0].properties;\n              for (let [d, p] of i.expression.arguments[0].properties.entries()) switch (m[d].key.name) {\n                case \"styles\":\n                  p.value.type === \"ArrayExpression\" && a(p.value.elements[0]);\n                  break;\n                case \"template\":\n                  p.value.type === \"TemplateLiteral\" && a(p.value);\n                  break;\n              }\n            }\n            if (u.type === \"TaggedTemplateExpression\" && (u.tag.type === \"MemberExpression\" || u.tag.type === \"Identifier\" && (u.tag.name === \"gql\" || u.tag.name === \"graphql\" || u.tag.name === \"css\" || u.tag.name === \"md\" || u.tag.name === \"markdown\" || u.tag.name === \"html\") || u.tag.type === \"CallExpression\") && a(i.quasi), u.type === \"TemplateLiteral\") {\n              var v;\n              (((v = u.leadingComments) === null || v === void 0 ? void 0 : v.some(d => t(d) && [\"GraphQL\", \"HTML\"].some(p => d.value === \" \".concat(p, \" \")))) || o.type === \"CallExpression\" && o.callee.name === \"graphql\" || !u.leadingComments) && a(i);\n            }\n            if (u.type === \"InterpreterDirective\" && (i.value = i.value.trimEnd()), (u.type === \"TSIntersectionType\" || u.type === \"TSUnionType\") && u.types.length === 1) return i.types[0];\n          }\n          r.ignoredProperties = s, n.exports = r;\n        }\n      }),\n      Ha = {};\n    Ut(Ha, {\n      EOL: () => Pn,\n      arch: () => jm,\n      cpus: () => Ya,\n      default: () => ro,\n      endianness: () => Ga,\n      freemem: () => Xa,\n      getNetworkInterfaces: () => to,\n      hostname: () => Ja,\n      loadavg: () => Ua,\n      networkInterfaces: () => eo,\n      platform: () => Om,\n      release: () => Za,\n      tmpDir: () => wn,\n      tmpdir: () => _n,\n      totalmem: () => Ka,\n      type: () => Qa,\n      uptime: () => za\n    });\n    function Ga() {\n      if (typeof Sr > \"u\") {\n        var e = new ArrayBuffer(2),\n          n = new Uint8Array(e),\n          t = new Uint16Array(e);\n        if (n[0] = 1, n[1] = 2, t[0] === 258) Sr = \"BE\";else if (t[0] === 513) Sr = \"LE\";else throw new Error(\"unable to figure out endianess\");\n      }\n      return Sr;\n    }\n    function Ja() {\n      return typeof globalThis.location < \"u\" ? globalThis.location.hostname : \"\";\n    }\n    function Ua() {\n      return [];\n    }\n    function za() {\n      return 0;\n    }\n    function Xa() {\n      return Number.MAX_VALUE;\n    }\n    function Ka() {\n      return Number.MAX_VALUE;\n    }\n    function Ya() {\n      return [];\n    }\n    function Qa() {\n      return \"Browser\";\n    }\n    function Za() {\n      return typeof globalThis.navigator < \"u\" ? globalThis.navigator.appVersion : \"\";\n    }\n    function eo() {}\n    function to() {}\n    function jm() {\n      return \"javascript\";\n    }\n    function Om() {\n      return \"browser\";\n    }\n    function wn() {\n      return \"/tmp\";\n    }\n    var Sr,\n      _n,\n      Pn,\n      ro,\n      qm = mt({\n        \"node-modules-polyfills:os\"() {\n          re(), _n = wn, Pn = `\n`, ro = {\n            EOL: Pn,\n            tmpdir: _n,\n            tmpDir: wn,\n            networkInterfaces: eo,\n            getNetworkInterfaces: to,\n            release: Za,\n            type: Qa,\n            cpus: Ya,\n            totalmem: Ka,\n            freemem: Xa,\n            uptime: za,\n            loadavg: Ua,\n            hostname: Ja,\n            endianness: Ga\n          };\n        }\n      }),\n      Mm = Z({\n        \"node-modules-polyfills-commonjs:os\"(e, n) {\n          re();\n          var t = (qm(), lt(Ha));\n          if (t && t.default) {\n            n.exports = t.default;\n            for (let s in t) n.exports[s] = t[s];\n          } else t && (n.exports = t);\n        }\n      }),\n      Rm = Z({\n        \"node_modules/detect-newline/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = s => {\n            if (typeof s != \"string\") throw new TypeError(\"Expected a string\");\n            let a = s.match(/(?:\\r?\\n)/g) || [];\n            if (a.length === 0) return;\n            let r = a.filter(i => i === `\\r\n`).length,\n              u = a.length - r;\n            return r > u ? `\\r\n` : `\n`;\n          };\n          n.exports = t, n.exports.graceful = s => typeof s == \"string\" && t(s) || `\n`;\n        }\n      }),\n      Vm = Z({\n        \"node_modules/jest-docblock/build/index.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.extract = p, e.parse = h, e.parseWithComments = w, e.print = T, e.strip = f;\n          function n() {\n            let S = Mm();\n            return n = function () {\n              return S;\n            }, S;\n          }\n          function t() {\n            let S = s(Rm());\n            return t = function () {\n              return S;\n            }, S;\n          }\n          function s(S) {\n            return S && S.__esModule ? S : {\n              default: S\n            };\n          }\n          var a = /\\*\\/$/,\n            r = /^\\/\\*\\*/,\n            u = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/,\n            i = /(^|\\s+)\\/\\/([^\\r\\n]*)/g,\n            o = /^(\\r?\\n)+/,\n            c = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g,\n            v = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g,\n            m = /(\\r?\\n|^) *\\* ?/g,\n            d = [];\n          function p(S) {\n            let B = S.match(u);\n            return B ? B[0].trimLeft() : \"\";\n          }\n          function f(S) {\n            let B = S.match(u);\n            return B && B[0] ? S.substring(B[0].length) : S;\n          }\n          function h(S) {\n            return w(S).pragmas;\n          }\n          function w(S) {\n            let B = (0, t().default)(S) || n().EOL;\n            S = S.replace(r, \"\").replace(a, \"\").replace(m, \"$1\");\n            let I = \"\";\n            for (; I !== S;) I = S, S = S.replace(c, \"\".concat(B, \"$1 $2\").concat(B));\n            S = S.replace(o, \"\").trimRight();\n            let k = Object.create(null),\n              P = S.replace(v, \"\").replace(o, \"\").trimRight(),\n              C;\n            for (; C = v.exec(S);) {\n              let D = C[2].replace(i, \"\");\n              typeof k[C[1]] == \"string\" || Array.isArray(k[C[1]]) ? k[C[1]] = d.concat(k[C[1]], D) : k[C[1]] = D;\n            }\n            return {\n              comments: P,\n              pragmas: k\n            };\n          }\n          function T(S) {\n            let {\n                comments: B = \"\",\n                pragmas: I = {}\n              } = S,\n              k = (0, t().default)(B) || n().EOL,\n              P = \"/**\",\n              C = \" *\",\n              D = \" */\",\n              g = Object.keys(I),\n              F = g.map(E => A(E, I[E])).reduce((E, y) => E.concat(y), []).map(E => C + \" \" + E + k).join(\"\");\n            if (!B) {\n              if (g.length === 0) return \"\";\n              if (g.length === 1 && !Array.isArray(I[g[0]])) {\n                let E = I[g[0]];\n                return \"\".concat(P, \" \").concat(A(g[0], E)[0]).concat(D);\n              }\n            }\n            let l = B.split(k).map(E => \"\".concat(C, \" \").concat(E)).join(k) + k;\n            return P + k + (B ? l : \"\") + (B && g.length ? C + k : \"\") + F + D;\n          }\n          function A(S, B) {\n            return d.concat(B).map(I => \"@\".concat(S, \" \").concat(I).trim());\n          }\n        }\n      }),\n      Wm = Z({\n        \"src/language-js/utils/get-shebang.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s) {\n            if (!s.startsWith(\"#!\")) return \"\";\n            let a = s.indexOf(`\n`);\n            return a === -1 ? s : s.slice(0, a);\n          }\n          n.exports = t;\n        }\n      }),\n      no = Z({\n        \"src/language-js/pragma.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              parseWithComments: t,\n              strip: s,\n              extract: a,\n              print: r\n            } = Vm(),\n            {\n              normalizeEndOfLine: u\n            } = jn(),\n            i = Wm();\n          function o(m) {\n            let d = i(m);\n            d && (m = m.slice(d.length + 1));\n            let p = a(m),\n              {\n                pragmas: f,\n                comments: h\n              } = t(p);\n            return {\n              shebang: d,\n              text: m,\n              pragmas: f,\n              comments: h\n            };\n          }\n          function c(m) {\n            let d = Object.keys(o(m).pragmas);\n            return d.includes(\"prettier\") || d.includes(\"format\");\n          }\n          function v(m) {\n            let {\n                shebang: d,\n                text: p,\n                pragmas: f,\n                comments: h\n              } = o(m),\n              w = s(p),\n              T = r({\n                pragmas: Object.assign({\n                  format: \"\"\n                }, f),\n                comments: h.trimStart()\n              });\n            return (d ? \"\".concat(d, `\n`) : \"\") + u(T) + (w.startsWith(`\n`) ? `\n` : `\n\n`) + w;\n          }\n          n.exports = {\n            hasPragma: c,\n            insertPragma: v\n          };\n        }\n      }),\n      uo = Z({\n        \"src/language-js/comments.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              getLast: t,\n              hasNewline: s,\n              getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a,\n              getNextNonSpaceNonCommentCharacter: r,\n              hasNewlineInRange: u,\n              addLeadingComment: i,\n              addTrailingComment: o,\n              addDanglingComment: c,\n              getNextNonSpaceNonCommentCharacterIndex: v,\n              isNonEmptyArray: m\n            } = Ue(),\n            {\n              getFunctionParameters: d,\n              isPrettierIgnoreComment: p,\n              isJsxNode: f,\n              hasFlowShorthandAnnotationComment: h,\n              hasFlowAnnotationComment: w,\n              hasIgnoreComment: T,\n              isCallLikeExpression: A,\n              getCallArguments: S,\n              isCallExpression: B,\n              isMemberExpression: I,\n              isObjectProperty: k,\n              isLineComment: P,\n              getComments: C,\n              CommentCheckFlags: D,\n              markerForIfWithoutBlockAndSameLineComment: g\n            } = Ke(),\n            {\n              locStart: F,\n              locEnd: l\n            } = st(),\n            E = It();\n          function y(me) {\n            return [ve, De, q, j, $, V, Q, Ae, U, ge, Ne, ke, te, ie, G].some(_ => _(me));\n          }\n          function N(me) {\n            return [M, De, Y, Ne, j, $, V, Q, ie, z, le, ge, de, G, he].some(_ => _(me));\n          }\n          function x(me) {\n            return [ve, j, $, H, ue, te, ge, X, W, K, G, ae].some(_ => _(me));\n          }\n          function b(me, _) {\n            let J = (me.body || me.properties).find(ne => {\n              let {\n                type: Ee\n              } = ne;\n              return Ee !== \"EmptyStatement\";\n            });\n            J ? i(J, _) : c(me, _);\n          }\n          function L(me, _) {\n            me.type === \"BlockStatement\" ? b(me, _) : i(me, _);\n          }\n          function M(me) {\n            let {\n              comment: _,\n              followingNode: J\n            } = me;\n            return J && Ie(_) ? (i(J, _), !0) : !1;\n          }\n          function j(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              followingNode: Ee,\n              text: We\n            } = me;\n            if ((ne == null ? void 0 : ne.type) !== \"IfStatement\" || !Ee) return !1;\n            if (r(We, _, l) === \")\") return o(J, _), !0;\n            if (J === ne.consequent && Ee === ne.alternate) {\n              if (J.type === \"BlockStatement\") o(J, _);else {\n                let Pe = _.type === \"SingleLine\" || _.loc.start.line === _.loc.end.line,\n                  Se = _.loc.start.line === J.loc.start.line;\n                Pe && Se ? c(J, _, g) : c(ne, _);\n              }\n              return !0;\n            }\n            return Ee.type === \"BlockStatement\" ? (b(Ee, _), !0) : Ee.type === \"IfStatement\" ? (L(Ee.consequent, _), !0) : ne.consequent === Ee ? (i(Ee, _), !0) : !1;\n          }\n          function $(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              followingNode: Ee,\n              text: We\n            } = me;\n            return (ne == null ? void 0 : ne.type) !== \"WhileStatement\" || !Ee ? !1 : r(We, _, l) === \")\" ? (o(J, _), !0) : Ee.type === \"BlockStatement\" ? (b(Ee, _), !0) : ne.body === Ee ? (i(Ee, _), !0) : !1;\n          }\n          function V(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              followingNode: Ee\n            } = me;\n            return (ne == null ? void 0 : ne.type) !== \"TryStatement\" && (ne == null ? void 0 : ne.type) !== \"CatchClause\" || !Ee ? !1 : ne.type === \"CatchClause\" && J ? (o(J, _), !0) : Ee.type === \"BlockStatement\" ? (b(Ee, _), !0) : Ee.type === \"TryStatement\" ? (L(Ee.finalizer, _), !0) : Ee.type === \"CatchClause\" ? (L(Ee.body, _), !0) : !1;\n          }\n          function q(me) {\n            let {\n              comment: _,\n              enclosingNode: J,\n              followingNode: ne\n            } = me;\n            return I(J) && (ne == null ? void 0 : ne.type) === \"Identifier\" ? (i(J, _), !0) : !1;\n          }\n          function Y(me) {\n            let {\n                comment: _,\n                precedingNode: J,\n                enclosingNode: ne,\n                followingNode: Ee,\n                text: We\n              } = me,\n              Be = J && !u(We, l(J), F(_));\n            return (!J || !Be) && ((ne == null ? void 0 : ne.type) === \"ConditionalExpression\" || (ne == null ? void 0 : ne.type) === \"TSConditionalType\") && Ee ? (i(Ee, _), !0) : !1;\n          }\n          function H(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne\n            } = me;\n            return k(ne) && ne.shorthand && ne.key === J && ne.value.type === \"AssignmentPattern\" ? (o(ne.value.left, _), !0) : !1;\n          }\n          var R = new Set([\"ClassDeclaration\", \"ClassExpression\", \"DeclareClass\", \"DeclareInterface\", \"InterfaceDeclaration\", \"TSInterfaceDeclaration\"]);\n          function Q(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              followingNode: Ee\n            } = me;\n            if (R.has(ne == null ? void 0 : ne.type)) {\n              if (m(ne.decorators) && !(Ee && Ee.type === \"Decorator\")) return o(t(ne.decorators), _), !0;\n              if (ne.body && Ee === ne.body) return b(ne.body, _), !0;\n              if (Ee) {\n                if (ne.superClass && Ee === ne.superClass && J && (J === ne.id || J === ne.typeParameters)) return o(J, _), !0;\n                for (let We of [\"implements\", \"extends\", \"mixins\"]) if (ne[We] && Ee === ne[We][0]) return J && (J === ne.id || J === ne.typeParameters || J === ne.superClass) ? o(J, _) : c(ne, _, We), !0;\n              }\n            }\n            return !1;\n          }\n          var ee = new Set([\"ClassMethod\", \"ClassProperty\", \"PropertyDefinition\", \"TSAbstractPropertyDefinition\", \"TSAbstractMethodDefinition\", \"TSDeclareMethod\", \"MethodDefinition\"]);\n          function te(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              text: Ee\n            } = me;\n            return ne && J && r(Ee, _, l) === \"(\" && (ne.type === \"Property\" || ne.type === \"TSDeclareMethod\" || ne.type === \"TSAbstractMethodDefinition\") && J.type === \"Identifier\" && ne.key === J && r(Ee, J, l) !== \":\" || (J == null ? void 0 : J.type) === \"Decorator\" && ee.has(ne == null ? void 0 : ne.type) ? (o(J, _), !0) : !1;\n          }\n          var oe = new Set([\"FunctionDeclaration\", \"FunctionExpression\", \"ClassMethod\", \"MethodDefinition\", \"ObjectMethod\"]);\n          function W(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              text: Ee\n            } = me;\n            return r(Ee, _, l) !== \"(\" ? !1 : J && oe.has(ne == null ? void 0 : ne.type) ? (o(J, _), !0) : !1;\n          }\n          function X(me) {\n            let {\n              comment: _,\n              enclosingNode: J,\n              text: ne\n            } = me;\n            if ((J == null ? void 0 : J.type) !== \"ArrowFunctionExpression\") return !1;\n            let Ee = v(ne, _, l);\n            return Ee !== !1 && ne.slice(Ee, Ee + 2) === \"=>\" ? (c(J, _), !0) : !1;\n          }\n          function ue(me) {\n            let {\n              comment: _,\n              enclosingNode: J,\n              text: ne\n            } = me;\n            return r(ne, _, l) !== \")\" ? !1 : J && (ye(J) && d(J).length === 0 || A(J) && S(J).length === 0) ? (c(J, _), !0) : ((J == null ? void 0 : J.type) === \"MethodDefinition\" || (J == null ? void 0 : J.type) === \"TSAbstractMethodDefinition\") && d(J.value).length === 0 ? (c(J.value, _), !0) : !1;\n          }\n          function De(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              followingNode: Ee,\n              text: We\n            } = me;\n            if ((J == null ? void 0 : J.type) === \"FunctionTypeParam\" && (ne == null ? void 0 : ne.type) === \"FunctionTypeAnnotation\" && (Ee == null ? void 0 : Ee.type) !== \"FunctionTypeParam\" || ((J == null ? void 0 : J.type) === \"Identifier\" || (J == null ? void 0 : J.type) === \"AssignmentPattern\") && ne && ye(ne) && r(We, _, l) === \")\") return o(J, _), !0;\n            if ((ne == null ? void 0 : ne.type) === \"FunctionDeclaration\" && (Ee == null ? void 0 : Ee.type) === \"BlockStatement\") {\n              let Be = (() => {\n                let Pe = d(ne);\n                if (Pe.length > 0) return a(We, l(t(Pe)));\n                let Se = a(We, l(ne.id));\n                return Se !== !1 && a(We, Se + 1);\n              })();\n              if (F(_) > Be) return b(Ee, _), !0;\n            }\n            return !1;\n          }\n          function ie(me) {\n            let {\n              comment: _,\n              enclosingNode: J\n            } = me;\n            return (J == null ? void 0 : J.type) === \"LabeledStatement\" ? (i(J, _), !0) : !1;\n          }\n          function G(me) {\n            let {\n              comment: _,\n              enclosingNode: J\n            } = me;\n            return ((J == null ? void 0 : J.type) === \"ContinueStatement\" || (J == null ? void 0 : J.type) === \"BreakStatement\") && !J.label ? (o(J, _), !0) : !1;\n          }\n          function z(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne\n            } = me;\n            return B(ne) && J && ne.callee === J && ne.arguments.length > 0 ? (i(ne.arguments[0], _), !0) : !1;\n          }\n          function U(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              followingNode: Ee\n            } = me;\n            return (ne == null ? void 0 : ne.type) === \"UnionTypeAnnotation\" || (ne == null ? void 0 : ne.type) === \"TSUnionType\" ? (p(_) && (Ee.prettierIgnore = !0, _.unignore = !0), J ? (o(J, _), !0) : !1) : (((Ee == null ? void 0 : Ee.type) === \"UnionTypeAnnotation\" || (Ee == null ? void 0 : Ee.type) === \"TSUnionType\") && p(_) && (Ee.types[0].prettierIgnore = !0, _.unignore = !0), !1);\n          }\n          function le(me) {\n            let {\n              comment: _,\n              enclosingNode: J\n            } = me;\n            return k(J) ? (i(J, _), !0) : !1;\n          }\n          function ge(me) {\n            let {\n              comment: _,\n              enclosingNode: J,\n              followingNode: ne,\n              ast: Ee,\n              isLastComment: We\n            } = me;\n            return Ee && Ee.body && Ee.body.length === 0 ? (We ? c(Ee, _) : i(Ee, _), !0) : (J == null ? void 0 : J.type) === \"Program\" && (J == null ? void 0 : J.body.length) === 0 && !m(J.directives) ? (We ? c(J, _) : i(J, _), !0) : (ne == null ? void 0 : ne.type) === \"Program\" && (ne == null ? void 0 : ne.body.length) === 0 && (J == null ? void 0 : J.type) === \"ModuleExpression\" ? (c(ne, _), !0) : !1;\n          }\n          function Ae(me) {\n            let {\n              comment: _,\n              enclosingNode: J\n            } = me;\n            return (J == null ? void 0 : J.type) === \"ForInStatement\" || (J == null ? void 0 : J.type) === \"ForOfStatement\" ? (i(J, _), !0) : !1;\n          }\n          function Ne(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              text: Ee\n            } = me;\n            if ((ne == null ? void 0 : ne.type) === \"ImportSpecifier\" || (ne == null ? void 0 : ne.type) === \"ExportSpecifier\") return i(ne, _), !0;\n            let We = (J == null ? void 0 : J.type) === \"ImportSpecifier\" && (ne == null ? void 0 : ne.type) === \"ImportDeclaration\",\n              Be = (J == null ? void 0 : J.type) === \"ExportSpecifier\" && (ne == null ? void 0 : ne.type) === \"ExportNamedDeclaration\";\n            return (We || Be) && s(Ee, l(_)) ? (o(J, _), !0) : !1;\n          }\n          function ke(me) {\n            let {\n              comment: _,\n              enclosingNode: J\n            } = me;\n            return (J == null ? void 0 : J.type) === \"AssignmentPattern\" ? (i(J, _), !0) : !1;\n          }\n          var ce = new Set([\"VariableDeclarator\", \"AssignmentExpression\", \"TypeAlias\", \"TSTypeAliasDeclaration\"]),\n            pe = new Set([\"ObjectExpression\", \"ArrayExpression\", \"TemplateLiteral\", \"TaggedTemplateExpression\", \"ObjectTypeAnnotation\", \"TSTypeLiteral\"]);\n          function de(me) {\n            let {\n              comment: _,\n              enclosingNode: J,\n              followingNode: ne\n            } = me;\n            return ce.has(J == null ? void 0 : J.type) && ne && (pe.has(ne.type) || E(_)) ? (i(ne, _), !0) : !1;\n          }\n          function ae(me) {\n            let {\n              comment: _,\n              enclosingNode: J,\n              followingNode: ne,\n              text: Ee\n            } = me;\n            return !ne && ((J == null ? void 0 : J.type) === \"TSMethodSignature\" || (J == null ? void 0 : J.type) === \"TSDeclareFunction\" || (J == null ? void 0 : J.type) === \"TSAbstractMethodDefinition\") && r(Ee, _, l) === \";\" ? (o(J, _), !0) : !1;\n          }\n          function ve(me) {\n            let {\n              comment: _,\n              enclosingNode: J,\n              followingNode: ne\n            } = me;\n            if (p(_) && (J == null ? void 0 : J.type) === \"TSMappedType\" && (ne == null ? void 0 : ne.type) === \"TSTypeParameter\" && ne.constraint) return J.prettierIgnore = !0, _.unignore = !0, !0;\n          }\n          function K(me) {\n            let {\n              comment: _,\n              precedingNode: J,\n              enclosingNode: ne,\n              followingNode: Ee\n            } = me;\n            return (ne == null ? void 0 : ne.type) !== \"TSMappedType\" ? !1 : (Ee == null ? void 0 : Ee.type) === \"TSTypeParameter\" && Ee.name ? (i(Ee.name, _), !0) : (J == null ? void 0 : J.type) === \"TSTypeParameter\" && J.constraint ? (o(J.constraint, _), !0) : !1;\n          }\n          function he(me) {\n            let {\n              comment: _,\n              enclosingNode: J,\n              followingNode: ne\n            } = me;\n            return !J || J.type !== \"SwitchCase\" || J.test ? !1 : (ne.type === \"BlockStatement\" && P(_) ? b(ne, _) : c(J, _), !0);\n          }\n          function ye(me) {\n            return me.type === \"ArrowFunctionExpression\" || me.type === \"FunctionExpression\" || me.type === \"FunctionDeclaration\" || me.type === \"ObjectMethod\" || me.type === \"ClassMethod\" || me.type === \"TSDeclareFunction\" || me.type === \"TSCallSignatureDeclaration\" || me.type === \"TSConstructSignatureDeclaration\" || me.type === \"TSMethodSignature\" || me.type === \"TSConstructorType\" || me.type === \"TSFunctionType\" || me.type === \"TSDeclareMethod\";\n          }\n          function Ce(me, _) {\n            if ((_.parser === \"typescript\" || _.parser === \"flow\" || _.parser === \"acorn\" || _.parser === \"espree\" || _.parser === \"meriyah\" || _.parser === \"__babel_estree\") && me.type === \"MethodDefinition\" && me.value && me.value.type === \"FunctionExpression\" && d(me.value).length === 0 && !me.value.returnType && !m(me.value.typeParameters) && me.value.body) return [...(me.decorators || []), me.key, me.value.body];\n          }\n          function Ie(me) {\n            return E(me) && me.value[0] === \"*\" && /@type\\b/.test(me.value);\n          }\n          function Fe(me) {\n            let _ = me.getValue(),\n              J = me.getParentNode(),\n              ne = Ee => w(C(Ee, D.Leading)) || w(C(Ee, D.Trailing));\n            return (_ && (f(_) || h(_) || B(J) && ne(_)) || J && (J.type === \"JSXSpreadAttribute\" || J.type === \"JSXSpreadChild\" || J.type === \"UnionTypeAnnotation\" || J.type === \"TSUnionType\" || (J.type === \"ClassDeclaration\" || J.type === \"ClassExpression\") && J.superClass === _)) && (!T(me) || J.type === \"UnionTypeAnnotation\" || J.type === \"TSUnionType\");\n          }\n          n.exports = {\n            handleOwnLineComment: y,\n            handleEndOfLineComment: N,\n            handleRemainingComment: x,\n            isTypeCastComment: Ie,\n            getCommentChildNodes: Ce,\n            willPrintOwnComments: Fe\n          };\n        }\n      }),\n      jt = Z({\n        \"src/language-js/needs-parens.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = it(),\n            s = Rn(),\n            {\n              getFunctionParameters: a,\n              getLeftSidePathName: r,\n              hasFlowShorthandAnnotationComment: u,\n              hasNakedLeftSide: i,\n              hasNode: o,\n              isBitwiseOperator: c,\n              startsWithNoLookaheadToken: v,\n              shouldFlatten: m,\n              getPrecedence: d,\n              isCallExpression: p,\n              isMemberExpression: f,\n              isObjectProperty: h\n            } = Ke();\n          function w(P, C) {\n            let D = P.getParentNode();\n            if (!D) return !1;\n            let g = P.getName(),\n              F = P.getNode();\n            if (C.__isInHtmlInterpolation && !C.bracketSpacing && B(F) && I(P)) return !0;\n            if (T(F)) return !1;\n            if (C.parser !== \"flow\" && u(P.getValue())) return !0;\n            if (F.type === \"Identifier\") return !!(F.extra && F.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(F.name) || g === \"left\" && F.name === \"async\" && D.type === \"ForOfStatement\" && !D.await);\n            switch (D.type) {\n              case \"ParenthesizedExpression\":\n                return !1;\n              case \"ClassDeclaration\":\n              case \"ClassExpression\":\n                {\n                  if (g === \"superClass\" && (F.type === \"ArrowFunctionExpression\" || F.type === \"AssignmentExpression\" || F.type === \"AwaitExpression\" || F.type === \"BinaryExpression\" || F.type === \"ConditionalExpression\" || F.type === \"LogicalExpression\" || F.type === \"NewExpression\" || F.type === \"ObjectExpression\" || F.type === \"SequenceExpression\" || F.type === \"TaggedTemplateExpression\" || F.type === \"UnaryExpression\" || F.type === \"UpdateExpression\" || F.type === \"YieldExpression\" || F.type === \"TSNonNullExpression\")) return !0;\n                  break;\n                }\n              case \"ExportDefaultDeclaration\":\n                return k(P, C) || F.type === \"SequenceExpression\";\n              case \"Decorator\":\n                {\n                  if (g === \"expression\") {\n                    let l = !1,\n                      E = !1,\n                      y = F;\n                    for (; y;) switch (y.type) {\n                      case \"MemberExpression\":\n                        E = !0, y = y.object;\n                        break;\n                      case \"CallExpression\":\n                        if (E || l) return C.parser !== \"typescript\";\n                        l = !0, y = y.callee;\n                        break;\n                      case \"Identifier\":\n                        return !1;\n                      case \"TaggedTemplateExpression\":\n                        return C.parser !== \"typescript\";\n                      default:\n                        return !0;\n                    }\n                    return !0;\n                  }\n                  break;\n                }\n              case \"ExpressionStatement\":\n                {\n                  if (v(F, !0)) return !0;\n                  break;\n                }\n              case \"ArrowFunctionExpression\":\n                {\n                  if (g === \"body\" && F.type !== \"SequenceExpression\" && v(F, !1)) return !0;\n                  break;\n                }\n            }\n            switch (F.type) {\n              case \"UpdateExpression\":\n                if (D.type === \"UnaryExpression\") return F.prefix && (F.operator === \"++\" && D.operator === \"+\" || F.operator === \"--\" && D.operator === \"-\");\n              case \"UnaryExpression\":\n                switch (D.type) {\n                  case \"UnaryExpression\":\n                    return F.operator === D.operator && (F.operator === \"+\" || F.operator === \"-\");\n                  case \"BindExpression\":\n                    return !0;\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return g === \"object\";\n                  case \"TaggedTemplateExpression\":\n                    return !0;\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return g === \"callee\";\n                  case \"BinaryExpression\":\n                    return g === \"left\" && D.operator === \"**\";\n                  case \"TSNonNullExpression\":\n                    return !0;\n                  default:\n                    return !1;\n                }\n              case \"BinaryExpression\":\n                {\n                  if (D.type === \"UpdateExpression\" || F.operator === \"in\" && A(P)) return !0;\n                  if (F.operator === \"|>\" && F.extra && F.extra.parenthesized) {\n                    let l = P.getParentNode(1);\n                    if (l.type === \"BinaryExpression\" && l.operator === \"|>\") return !0;\n                  }\n                }\n              case \"TSTypeAssertion\":\n              case \"TSAsExpression\":\n              case \"LogicalExpression\":\n                switch (D.type) {\n                  case \"TSAsExpression\":\n                    return F.type !== \"TSAsExpression\";\n                  case \"ConditionalExpression\":\n                    return F.type === \"TSAsExpression\";\n                  case \"CallExpression\":\n                  case \"NewExpression\":\n                  case \"OptionalCallExpression\":\n                    return g === \"callee\";\n                  case \"ClassExpression\":\n                  case \"ClassDeclaration\":\n                    return g === \"superClass\";\n                  case \"TSTypeAssertion\":\n                  case \"TaggedTemplateExpression\":\n                  case \"UnaryExpression\":\n                  case \"JSXSpreadAttribute\":\n                  case \"SpreadElement\":\n                  case \"SpreadProperty\":\n                  case \"BindExpression\":\n                  case \"AwaitExpression\":\n                  case \"TSNonNullExpression\":\n                  case \"UpdateExpression\":\n                    return !0;\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return g === \"object\";\n                  case \"AssignmentExpression\":\n                  case \"AssignmentPattern\":\n                    return g === \"left\" && (F.type === \"TSTypeAssertion\" || F.type === \"TSAsExpression\");\n                  case \"LogicalExpression\":\n                    if (F.type === \"LogicalExpression\") return D.operator !== F.operator;\n                  case \"BinaryExpression\":\n                    {\n                      let {\n                        operator: l,\n                        type: E\n                      } = F;\n                      if (!l && E !== \"TSTypeAssertion\") return !0;\n                      let y = d(l),\n                        N = D.operator,\n                        x = d(N);\n                      return x > y || g === \"right\" && x === y || x === y && !m(N, l) ? !0 : x < y && l === \"%\" ? N === \"+\" || N === \"-\" : !!c(N);\n                    }\n                  default:\n                    return !1;\n                }\n              case \"SequenceExpression\":\n                switch (D.type) {\n                  case \"ReturnStatement\":\n                    return !1;\n                  case \"ForStatement\":\n                    return !1;\n                  case \"ExpressionStatement\":\n                    return g !== \"expression\";\n                  case \"ArrowFunctionExpression\":\n                    return g !== \"body\";\n                  default:\n                    return !0;\n                }\n              case \"YieldExpression\":\n                if (D.type === \"UnaryExpression\" || D.type === \"AwaitExpression\" || D.type === \"TSAsExpression\" || D.type === \"TSNonNullExpression\") return !0;\n              case \"AwaitExpression\":\n                switch (D.type) {\n                  case \"TaggedTemplateExpression\":\n                  case \"UnaryExpression\":\n                  case \"LogicalExpression\":\n                  case \"SpreadElement\":\n                  case \"SpreadProperty\":\n                  case \"TSAsExpression\":\n                  case \"TSNonNullExpression\":\n                  case \"BindExpression\":\n                    return !0;\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return g === \"object\";\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return g === \"callee\";\n                  case \"ConditionalExpression\":\n                    return g === \"test\";\n                  case \"BinaryExpression\":\n                    return !(!F.argument && D.operator === \"|>\");\n                  default:\n                    return !1;\n                }\n              case \"TSConditionalType\":\n                if (g === \"extendsType\" && D.type === \"TSConditionalType\") return !0;\n              case \"TSFunctionType\":\n              case \"TSConstructorType\":\n                if (g === \"checkType\" && D.type === \"TSConditionalType\") return !0;\n              case \"TSUnionType\":\n              case \"TSIntersectionType\":\n                if ((D.type === \"TSUnionType\" || D.type === \"TSIntersectionType\") && D.types.length > 1 && (!F.types || F.types.length > 1)) return !0;\n              case \"TSInferType\":\n                if (F.type === \"TSInferType\" && D.type === \"TSRestType\") return !1;\n              case \"TSTypeOperator\":\n                return D.type === \"TSArrayType\" || D.type === \"TSOptionalType\" || D.type === \"TSRestType\" || g === \"objectType\" && D.type === \"TSIndexedAccessType\" || D.type === \"TSTypeOperator\" || D.type === \"TSTypeAnnotation\" && P.getParentNode(1).type.startsWith(\"TSJSDoc\");\n              case \"ArrayTypeAnnotation\":\n                return D.type === \"NullableTypeAnnotation\";\n              case \"IntersectionTypeAnnotation\":\n              case \"UnionTypeAnnotation\":\n                return D.type === \"ArrayTypeAnnotation\" || D.type === \"NullableTypeAnnotation\" || D.type === \"IntersectionTypeAnnotation\" || D.type === \"UnionTypeAnnotation\" || g === \"objectType\" && (D.type === \"IndexedAccessType\" || D.type === \"OptionalIndexedAccessType\");\n              case \"NullableTypeAnnotation\":\n                return D.type === \"ArrayTypeAnnotation\" || g === \"objectType\" && (D.type === \"IndexedAccessType\" || D.type === \"OptionalIndexedAccessType\");\n              case \"FunctionTypeAnnotation\":\n                {\n                  let l = D.type === \"NullableTypeAnnotation\" ? P.getParentNode(1) : D;\n                  return l.type === \"UnionTypeAnnotation\" || l.type === \"IntersectionTypeAnnotation\" || l.type === \"ArrayTypeAnnotation\" || g === \"objectType\" && (l.type === \"IndexedAccessType\" || l.type === \"OptionalIndexedAccessType\") || l.type === \"NullableTypeAnnotation\" || D.type === \"FunctionTypeParam\" && D.name === null && a(F).some(E => E.typeAnnotation && E.typeAnnotation.type === \"NullableTypeAnnotation\");\n                }\n              case \"OptionalIndexedAccessType\":\n                return g === \"objectType\" && D.type === \"IndexedAccessType\";\n              case \"TypeofTypeAnnotation\":\n                return g === \"objectType\" && (D.type === \"IndexedAccessType\" || D.type === \"OptionalIndexedAccessType\");\n              case \"StringLiteral\":\n              case \"NumericLiteral\":\n              case \"Literal\":\n                if (typeof F.value == \"string\" && D.type === \"ExpressionStatement\" && !D.directive) {\n                  let l = P.getParentNode(1);\n                  return l.type === \"Program\" || l.type === \"BlockStatement\";\n                }\n                return g === \"object\" && D.type === \"MemberExpression\" && typeof F.value == \"number\";\n              case \"AssignmentExpression\":\n                {\n                  let l = P.getParentNode(1);\n                  return g === \"body\" && D.type === \"ArrowFunctionExpression\" ? !0 : g === \"key\" && (D.type === \"ClassProperty\" || D.type === \"PropertyDefinition\") && D.computed || (g === \"init\" || g === \"update\") && D.type === \"ForStatement\" ? !1 : D.type === \"ExpressionStatement\" ? F.left.type === \"ObjectPattern\" : !(g === \"key\" && D.type === \"TSPropertySignature\" || D.type === \"AssignmentExpression\" || D.type === \"SequenceExpression\" && l && l.type === \"ForStatement\" && (l.init === D || l.update === D) || g === \"value\" && D.type === \"Property\" && l && l.type === \"ObjectPattern\" && l.properties.includes(D) || D.type === \"NGChainedExpression\");\n                }\n              case \"ConditionalExpression\":\n                switch (D.type) {\n                  case \"TaggedTemplateExpression\":\n                  case \"UnaryExpression\":\n                  case \"SpreadElement\":\n                  case \"SpreadProperty\":\n                  case \"BinaryExpression\":\n                  case \"LogicalExpression\":\n                  case \"NGPipeExpression\":\n                  case \"ExportDefaultDeclaration\":\n                  case \"AwaitExpression\":\n                  case \"JSXSpreadAttribute\":\n                  case \"TSTypeAssertion\":\n                  case \"TypeCastExpression\":\n                  case \"TSAsExpression\":\n                  case \"TSNonNullExpression\":\n                    return !0;\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return g === \"callee\";\n                  case \"ConditionalExpression\":\n                    return g === \"test\";\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return g === \"object\";\n                  default:\n                    return !1;\n                }\n              case \"FunctionExpression\":\n                switch (D.type) {\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return g === \"callee\";\n                  case \"TaggedTemplateExpression\":\n                    return !0;\n                  default:\n                    return !1;\n                }\n              case \"ArrowFunctionExpression\":\n                switch (D.type) {\n                  case \"BinaryExpression\":\n                    return D.operator !== \"|>\" || F.extra && F.extra.parenthesized;\n                  case \"NewExpression\":\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return g === \"callee\";\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                    return g === \"object\";\n                  case \"TSAsExpression\":\n                  case \"TSNonNullExpression\":\n                  case \"BindExpression\":\n                  case \"TaggedTemplateExpression\":\n                  case \"UnaryExpression\":\n                  case \"LogicalExpression\":\n                  case \"AwaitExpression\":\n                  case \"TSTypeAssertion\":\n                    return !0;\n                  case \"ConditionalExpression\":\n                    return g === \"test\";\n                  default:\n                    return !1;\n                }\n              case \"ClassExpression\":\n                if (s(F.decorators)) return !0;\n                switch (D.type) {\n                  case \"NewExpression\":\n                    return g === \"callee\";\n                  default:\n                    return !1;\n                }\n              case \"OptionalMemberExpression\":\n              case \"OptionalCallExpression\":\n                {\n                  let l = P.getParentNode(1);\n                  if (g === \"object\" && D.type === \"MemberExpression\" || g === \"callee\" && (D.type === \"CallExpression\" || D.type === \"NewExpression\") || D.type === \"TSNonNullExpression\" && l.type === \"MemberExpression\" && l.object === D) return !0;\n                }\n              case \"CallExpression\":\n              case \"MemberExpression\":\n              case \"TaggedTemplateExpression\":\n              case \"TSNonNullExpression\":\n                if (g === \"callee\" && (D.type === \"BindExpression\" || D.type === \"NewExpression\")) {\n                  let l = F;\n                  for (; l;) switch (l.type) {\n                    case \"CallExpression\":\n                    case \"OptionalCallExpression\":\n                      return !0;\n                    case \"MemberExpression\":\n                    case \"OptionalMemberExpression\":\n                    case \"BindExpression\":\n                      l = l.object;\n                      break;\n                    case \"TaggedTemplateExpression\":\n                      l = l.tag;\n                      break;\n                    case \"TSNonNullExpression\":\n                      l = l.expression;\n                      break;\n                    default:\n                      return !1;\n                  }\n                }\n                return !1;\n              case \"BindExpression\":\n                return g === \"callee\" && (D.type === \"BindExpression\" || D.type === \"NewExpression\") || g === \"object\" && f(D);\n              case \"NGPipeExpression\":\n                return !(D.type === \"NGRoot\" || D.type === \"NGMicrosyntaxExpression\" || D.type === \"ObjectProperty\" && !(F.extra && F.extra.parenthesized) || D.type === \"ArrayExpression\" || p(D) && D.arguments[g] === F || g === \"right\" && D.type === \"NGPipeExpression\" || g === \"property\" && D.type === \"MemberExpression\" || D.type === \"AssignmentExpression\");\n              case \"JSXFragment\":\n              case \"JSXElement\":\n                return g === \"callee\" || g === \"left\" && D.type === \"BinaryExpression\" && D.operator === \"<\" || D.type !== \"ArrayExpression\" && D.type !== \"ArrowFunctionExpression\" && D.type !== \"AssignmentExpression\" && D.type !== \"AssignmentPattern\" && D.type !== \"BinaryExpression\" && D.type !== \"NewExpression\" && D.type !== \"ConditionalExpression\" && D.type !== \"ExpressionStatement\" && D.type !== \"JsExpressionRoot\" && D.type !== \"JSXAttribute\" && D.type !== \"JSXElement\" && D.type !== \"JSXExpressionContainer\" && D.type !== \"JSXFragment\" && D.type !== \"LogicalExpression\" && !p(D) && !h(D) && D.type !== \"ReturnStatement\" && D.type !== \"ThrowStatement\" && D.type !== \"TypeCastExpression\" && D.type !== \"VariableDeclarator\" && D.type !== \"YieldExpression\";\n              case \"TypeAnnotation\":\n                return g === \"returnType\" && D.type === \"ArrowFunctionExpression\" && S(F);\n            }\n            return !1;\n          }\n          function T(P) {\n            return P.type === \"BlockStatement\" || P.type === \"BreakStatement\" || P.type === \"ClassBody\" || P.type === \"ClassDeclaration\" || P.type === \"ClassMethod\" || P.type === \"ClassProperty\" || P.type === \"PropertyDefinition\" || P.type === \"ClassPrivateProperty\" || P.type === \"ContinueStatement\" || P.type === \"DebuggerStatement\" || P.type === \"DeclareClass\" || P.type === \"DeclareExportAllDeclaration\" || P.type === \"DeclareExportDeclaration\" || P.type === \"DeclareFunction\" || P.type === \"DeclareInterface\" || P.type === \"DeclareModule\" || P.type === \"DeclareModuleExports\" || P.type === \"DeclareVariable\" || P.type === \"DoWhileStatement\" || P.type === \"EnumDeclaration\" || P.type === \"ExportAllDeclaration\" || P.type === \"ExportDefaultDeclaration\" || P.type === \"ExportNamedDeclaration\" || P.type === \"ExpressionStatement\" || P.type === \"ForInStatement\" || P.type === \"ForOfStatement\" || P.type === \"ForStatement\" || P.type === \"FunctionDeclaration\" || P.type === \"IfStatement\" || P.type === \"ImportDeclaration\" || P.type === \"InterfaceDeclaration\" || P.type === \"LabeledStatement\" || P.type === \"MethodDefinition\" || P.type === \"ReturnStatement\" || P.type === \"SwitchStatement\" || P.type === \"ThrowStatement\" || P.type === \"TryStatement\" || P.type === \"TSDeclareFunction\" || P.type === \"TSEnumDeclaration\" || P.type === \"TSImportEqualsDeclaration\" || P.type === \"TSInterfaceDeclaration\" || P.type === \"TSModuleDeclaration\" || P.type === \"TSNamespaceExportDeclaration\" || P.type === \"TypeAlias\" || P.type === \"VariableDeclaration\" || P.type === \"WhileStatement\" || P.type === \"WithStatement\";\n          }\n          function A(P) {\n            let C = 0,\n              D = P.getValue();\n            for (; D;) {\n              let g = P.getParentNode(C++);\n              if (g && g.type === \"ForStatement\" && g.init === D) return !0;\n              D = g;\n            }\n            return !1;\n          }\n          function S(P) {\n            return o(P, C => C.type === \"ObjectTypeAnnotation\" && o(C, D => D.type === \"FunctionTypeAnnotation\" || void 0) || void 0);\n          }\n          function B(P) {\n            switch (P.type) {\n              case \"ObjectExpression\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          function I(P) {\n            let C = P.getValue(),\n              D = P.getParentNode(),\n              g = P.getName();\n            switch (D.type) {\n              case \"NGPipeExpression\":\n                if (typeof g == \"number\" && D.arguments[g] === C && D.arguments.length - 1 === g) return P.callParent(I);\n                break;\n              case \"ObjectProperty\":\n                if (g === \"value\") {\n                  let F = P.getParentNode(1);\n                  return t(F.properties) === D;\n                }\n                break;\n              case \"BinaryExpression\":\n              case \"LogicalExpression\":\n                if (g === \"right\") return P.callParent(I);\n                break;\n              case \"ConditionalExpression\":\n                if (g === \"alternate\") return P.callParent(I);\n                break;\n              case \"UnaryExpression\":\n                if (D.prefix) return P.callParent(I);\n                break;\n            }\n            return !1;\n          }\n          function k(P, C) {\n            let D = P.getValue(),\n              g = P.getParentNode();\n            return D.type === \"FunctionExpression\" || D.type === \"ClassExpression\" ? g.type === \"ExportDefaultDeclaration\" || !w(P, C) : !i(D) || g.type !== \"ExportDefaultDeclaration\" && w(P, C) ? !1 : P.call(F => k(F, C), ...r(P, D));\n          }\n          n.exports = w;\n        }\n      }),\n      so = Z({\n        \"src/language-js/print-preprocess.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s, a) {\n            switch (a.parser) {\n              case \"json\":\n              case \"json5\":\n              case \"json-stringify\":\n              case \"__js_expression\":\n              case \"__vue_expression\":\n              case \"__vue_ts_expression\":\n                return Object.assign(Object.assign({}, s), {}, {\n                  type: a.parser.startsWith(\"__\") ? \"JsExpressionRoot\" : \"JsonRoot\",\n                  node: s,\n                  comments: [],\n                  rootMarker: a.rootMarker\n                });\n              default:\n                return s;\n            }\n          }\n          n.exports = t;\n        }\n      }),\n      $m = Z({\n        \"src/language-js/print/html-binding.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            builders: {\n              join: t,\n              line: s,\n              group: a,\n              softline: r,\n              indent: u\n            }\n          } = Oe();\n          function i(c, v, m) {\n            let d = c.getValue();\n            if (v.__onHtmlBindingRoot && c.getName() === null && v.__onHtmlBindingRoot(d, v), d.type === \"File\") {\n              if (v.__isVueForBindingLeft) return c.call(p => {\n                let f = t([\",\", s], p.map(m, \"params\")),\n                  {\n                    params: h\n                  } = p.getValue();\n                return h.length === 1 ? f : [\"(\", u([r, a(f)]), r, \")\"];\n              }, \"program\", \"body\", 0);\n              if (v.__isVueBindings) return c.call(p => t([\",\", s], p.map(m, \"params\")), \"program\", \"body\", 0);\n            }\n          }\n          function o(c) {\n            switch (c.type) {\n              case \"MemberExpression\":\n                switch (c.property.type) {\n                  case \"Identifier\":\n                  case \"NumericLiteral\":\n                  case \"StringLiteral\":\n                    return o(c.object);\n                }\n                return !1;\n              case \"Identifier\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          n.exports = {\n            isVueEventBindingExpression: o,\n            printHtmlBinding: i\n          };\n        }\n      }),\n      Jn = Z({\n        \"src/language-js/print/binaryish.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printComments: t\n            } = et(),\n            {\n              getLast: s\n            } = Ue(),\n            {\n              builders: {\n                join: a,\n                line: r,\n                softline: u,\n                group: i,\n                indent: o,\n                align: c,\n                ifBreak: v,\n                indentIfBreak: m\n              },\n              utils: {\n                cleanDoc: d,\n                getDocParts: p,\n                isConcat: f\n              }\n            } = Oe(),\n            {\n              hasLeadingOwnLineComment: h,\n              isBinaryish: w,\n              isJsxNode: T,\n              shouldFlatten: A,\n              hasComment: S,\n              CommentCheckFlags: B,\n              isCallExpression: I,\n              isMemberExpression: k,\n              isObjectProperty: P,\n              isEnabledHackPipeline: C\n            } = Ke(),\n            D = 0;\n          function g(E, y, N) {\n            let x = E.getValue(),\n              b = E.getParentNode(),\n              L = E.getParentNode(1),\n              M = x !== b.body && (b.type === \"IfStatement\" || b.type === \"WhileStatement\" || b.type === \"SwitchStatement\" || b.type === \"DoWhileStatement\"),\n              j = C(y) && x.operator === \"|>\",\n              $ = F(E, N, y, !1, M);\n            if (M) return $;\n            if (j) return i($);\n            if (I(b) && b.callee === x || b.type === \"UnaryExpression\" || k(b) && !b.computed) return i([o([u, ...$]), u]);\n            let V = b.type === \"ReturnStatement\" || b.type === \"ThrowStatement\" || b.type === \"JSXExpressionContainer\" && L.type === \"JSXAttribute\" || x.operator !== \"|\" && b.type === \"JsExpressionRoot\" || x.type !== \"NGPipeExpression\" && (b.type === \"NGRoot\" && y.parser === \"__ng_binding\" || b.type === \"NGMicrosyntaxExpression\" && L.type === \"NGMicrosyntax\" && L.body.length === 1) || x === b.body && b.type === \"ArrowFunctionExpression\" || x !== b.body && b.type === \"ForStatement\" || b.type === \"ConditionalExpression\" && L.type !== \"ReturnStatement\" && L.type !== \"ThrowStatement\" && !I(L) || b.type === \"TemplateLiteral\",\n              q = b.type === \"AssignmentExpression\" || b.type === \"VariableDeclarator\" || b.type === \"ClassProperty\" || b.type === \"PropertyDefinition\" || b.type === \"TSAbstractPropertyDefinition\" || b.type === \"ClassPrivateProperty\" || P(b),\n              Y = w(x.left) && A(x.operator, x.left.operator);\n            if (V || l(x) && !Y || !l(x) && q) return i($);\n            if ($.length === 0) return \"\";\n            let H = T(x.right),\n              R = $.findIndex(X => typeof X != \"string\" && !Array.isArray(X) && X.type === \"group\"),\n              Q = $.slice(0, R === -1 ? 1 : R + 1),\n              ee = $.slice(Q.length, H ? -1 : void 0),\n              te = Symbol(\"logicalChain-\" + ++D),\n              oe = i([...Q, o(ee)], {\n                id: te\n              });\n            if (!H) return oe;\n            let W = s($);\n            return i([oe, m(W, {\n              groupId: te\n            })]);\n          }\n          function F(E, y, N, x, b) {\n            let L = E.getValue();\n            if (!w(L)) return [i(y())];\n            let M = [];\n            A(L.operator, L.left.operator) ? M = E.call(ee => F(ee, y, N, !0, b), \"left\") : M.push(i(y(\"left\")));\n            let j = l(L),\n              $ = (L.operator === \"|>\" || L.type === \"NGPipeExpression\" || L.operator === \"|\" && N.parser === \"__vue_expression\") && !h(N.originalText, L.right),\n              V = L.type === \"NGPipeExpression\" ? \"|\" : L.operator,\n              q = L.type === \"NGPipeExpression\" && L.arguments.length > 0 ? i(o([u, \": \", a([u, \":\", v(\" \")], E.map(y, \"arguments\").map(ee => c(2, i(ee))))])) : \"\",\n              Y;\n            if (j) Y = [V, \" \", y(\"right\"), q];else {\n              let te = C(N) && V === \"|>\" ? E.call(oe => F(oe, y, N, !0, b), \"right\") : y(\"right\");\n              Y = [$ ? r : \"\", V, $ ? \" \" : r, te, q];\n            }\n            let H = E.getParentNode(),\n              R = S(L.left, B.Trailing | B.Line),\n              Q = R || !(b && L.type === \"LogicalExpression\") && H.type !== L.type && L.left.type !== L.type && L.right.type !== L.type;\n            if (M.push($ ? \"\" : \" \", Q ? i(Y, {\n              shouldBreak: R\n            }) : Y), x && S(L)) {\n              let ee = d(t(E, M, N));\n              return f(ee) || ee.type === \"fill\" ? p(ee) : [ee];\n            }\n            return M;\n          }\n          function l(E) {\n            return E.type !== \"LogicalExpression\" ? !1 : !!(E.right.type === \"ObjectExpression\" && E.right.properties.length > 0 || E.right.type === \"ArrayExpression\" && E.right.elements.length > 0 || T(E.right));\n          }\n          n.exports = {\n            printBinaryishExpression: g,\n            shouldInlineLogicalExpression: l\n          };\n        }\n      }),\n      Hm = Z({\n        \"src/language-js/print/angular.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                join: t,\n                line: s,\n                group: a\n              }\n            } = Oe(),\n            {\n              hasNode: r,\n              hasComment: u,\n              getComments: i\n            } = Ke(),\n            {\n              printBinaryishExpression: o\n            } = Jn();\n          function c(d, p, f) {\n            let h = d.getValue();\n            if (!!h.type.startsWith(\"NG\")) switch (h.type) {\n              case \"NGRoot\":\n                return [f(\"node\"), u(h.node) ? \" //\" + i(h.node)[0].value.trimEnd() : \"\"];\n              case \"NGPipeExpression\":\n                return o(d, p, f);\n              case \"NGChainedExpression\":\n                return a(t([\";\", s], d.map(w => m(w) ? f() : [\"(\", f(), \")\"], \"expressions\")));\n              case \"NGEmptyExpression\":\n                return \"\";\n              case \"NGQuotedExpression\":\n                return [h.prefix, \": \", h.value.trim()];\n              case \"NGMicrosyntax\":\n                return d.map((w, T) => [T === 0 ? \"\" : v(w.getValue(), T, h) ? \" \" : [\";\", s], f()], \"body\");\n              case \"NGMicrosyntaxKey\":\n                return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(h.name) ? h.name : JSON.stringify(h.name);\n              case \"NGMicrosyntaxExpression\":\n                return [f(\"expression\"), h.alias === null ? \"\" : [\" as \", f(\"alias\")]];\n              case \"NGMicrosyntaxKeyedExpression\":\n                {\n                  let w = d.getName(),\n                    T = d.getParentNode(),\n                    A = v(h, w, T) || (w === 1 && (h.key.name === \"then\" || h.key.name === \"else\") || w === 2 && h.key.name === \"else\" && T.body[w - 1].type === \"NGMicrosyntaxKeyedExpression\" && T.body[w - 1].key.name === \"then\") && T.body[0].type === \"NGMicrosyntaxExpression\";\n                  return [f(\"key\"), A ? \" \" : \": \", f(\"expression\")];\n                }\n              case \"NGMicrosyntaxLet\":\n                return [\"let \", f(\"key\"), h.value === null ? \"\" : [\" = \", f(\"value\")]];\n              case \"NGMicrosyntaxAs\":\n                return [f(\"key\"), \" as \", f(\"alias\")];\n              default:\n                throw new Error(\"Unknown Angular node type: \".concat(JSON.stringify(h.type), \".\"));\n            }\n          }\n          function v(d, p, f) {\n            return d.type === \"NGMicrosyntaxKeyedExpression\" && d.key.name === \"of\" && p === 1 && f.body[0].type === \"NGMicrosyntaxLet\" && f.body[0].value === null;\n          }\n          function m(d) {\n            return r(d.getValue(), p => {\n              switch (p.type) {\n                case void 0:\n                  return !1;\n                case \"CallExpression\":\n                case \"OptionalCallExpression\":\n                case \"AssignmentExpression\":\n                  return !0;\n              }\n            });\n          }\n          n.exports = {\n            printAngular: c\n          };\n        }\n      }),\n      Gm = Z({\n        \"src/language-js/print/jsx.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printComments: t,\n              printDanglingComments: s\n            } = et(),\n            {\n              builders: {\n                line: a,\n                hardline: r,\n                softline: u,\n                group: i,\n                indent: o,\n                conditionalGroup: c,\n                fill: v,\n                ifBreak: m,\n                lineSuffixBoundary: d,\n                join: p\n              },\n              utils: {\n                willBreak: f\n              }\n            } = Oe(),\n            {\n              getLast: h,\n              getPreferredQuote: w\n            } = Ue(),\n            {\n              isJsxNode: T,\n              rawText: A,\n              isLiteral: S,\n              isCallExpression: B,\n              isStringLiteral: I,\n              isBinaryish: k,\n              hasComment: P,\n              CommentCheckFlags: C,\n              hasNodeIgnoreComment: D\n            } = Ke(),\n            g = jt(),\n            {\n              willPrintOwnComments: F\n            } = uo(),\n            l = ie => ie === \"\" || ie === a || ie === r || ie === u;\n          function E(ie, G, z) {\n            let U = ie.getValue();\n            if (U.type === \"JSXElement\" && W(U)) return [z(\"openingElement\"), z(\"closingElement\")];\n            let le = U.type === \"JSXElement\" ? z(\"openingElement\") : z(\"openingFragment\"),\n              ge = U.type === \"JSXElement\" ? z(\"closingElement\") : z(\"closingFragment\");\n            if (U.children.length === 1 && U.children[0].type === \"JSXExpressionContainer\" && (U.children[0].expression.type === \"TemplateLiteral\" || U.children[0].expression.type === \"TaggedTemplateExpression\")) return [le, ...ie.map(z, \"children\"), ge];\n            U.children = U.children.map(Fe => ue(Fe) ? {\n              type: \"JSXText\",\n              value: \" \",\n              raw: \" \"\n            } : Fe);\n            let Ae = U.children.some(T),\n              Ne = U.children.filter(Fe => Fe.type === \"JSXExpressionContainer\").length > 1,\n              ke = U.type === \"JSXElement\" && U.openingElement.attributes.length > 1,\n              ce = f(le) || Ae || ke || Ne,\n              pe = ie.getParentNode().rootMarker === \"mdx\",\n              de = G.singleQuote ? \"{' '}\" : '{\" \"}',\n              ae = pe ? \" \" : m([de, u], \" \"),\n              ve = U.openingElement && U.openingElement.name && U.openingElement.name.name === \"fbt\",\n              K = y(ie, G, z, ae, ve),\n              he = U.children.some(Fe => X(Fe));\n            for (let Fe = K.length - 2; Fe >= 0; Fe--) {\n              let me = K[Fe] === \"\" && K[Fe + 1] === \"\",\n                _ = K[Fe] === r && K[Fe + 1] === \"\" && K[Fe + 2] === r,\n                J = (K[Fe] === u || K[Fe] === r) && K[Fe + 1] === \"\" && K[Fe + 2] === ae,\n                ne = K[Fe] === ae && K[Fe + 1] === \"\" && (K[Fe + 2] === u || K[Fe + 2] === r),\n                Ee = K[Fe] === ae && K[Fe + 1] === \"\" && K[Fe + 2] === ae,\n                We = K[Fe] === u && K[Fe + 1] === \"\" && K[Fe + 2] === r || K[Fe] === r && K[Fe + 1] === \"\" && K[Fe + 2] === u;\n              _ && he || me || J || Ee || We ? K.splice(Fe, 2) : ne && K.splice(Fe + 1, 2);\n            }\n            for (; K.length > 0 && l(h(K));) K.pop();\n            for (; K.length > 1 && l(K[0]) && l(K[1]);) K.shift(), K.shift();\n            let ye = [];\n            for (let [Fe, me] of K.entries()) {\n              if (me === ae) {\n                if (Fe === 1 && K[Fe - 1] === \"\") {\n                  if (K.length === 2) {\n                    ye.push(de);\n                    continue;\n                  }\n                  ye.push([de, r]);\n                  continue;\n                } else if (Fe === K.length - 1) {\n                  ye.push(de);\n                  continue;\n                } else if (K[Fe - 1] === \"\" && K[Fe - 2] === r) {\n                  ye.push(de);\n                  continue;\n                }\n              }\n              ye.push(me), f(me) && (ce = !0);\n            }\n            let Ce = he ? v(ye) : i(ye, {\n              shouldBreak: !0\n            });\n            if (pe) return Ce;\n            let Ie = i([le, o([r, Ce]), r, ge]);\n            return ce ? Ie : c([i([le, ...K, ge]), Ie]);\n          }\n          function y(ie, G, z, U, le) {\n            let ge = [];\n            return ie.each((Ae, Ne, ke) => {\n              let ce = Ae.getValue();\n              if (S(ce)) {\n                let pe = A(ce);\n                if (X(ce)) {\n                  let de = pe.split(ee);\n                  if (de[0] === \"\") {\n                    if (ge.push(\"\"), de.shift(), /\\n/.test(de[0])) {\n                      let ve = ke[Ne + 1];\n                      ge.push(x(le, de[1], ce, ve));\n                    } else ge.push(U);\n                    de.shift();\n                  }\n                  let ae;\n                  if (h(de) === \"\" && (de.pop(), ae = de.pop()), de.length === 0) return;\n                  for (let [ve, K] of de.entries()) ve % 2 === 1 ? ge.push(a) : ge.push(K);\n                  if (ae !== void 0) {\n                    if (/\\n/.test(ae)) {\n                      let ve = ke[Ne + 1];\n                      ge.push(x(le, h(ge), ce, ve));\n                    } else ge.push(U);\n                  } else {\n                    let ve = ke[Ne + 1];\n                    ge.push(N(le, h(ge), ce, ve));\n                  }\n                } else /\\n/.test(pe) ? pe.match(/\\n/g).length > 1 && ge.push(\"\", r) : ge.push(\"\", U);\n              } else {\n                let pe = z();\n                ge.push(pe);\n                let de = ke[Ne + 1];\n                if (de && X(de)) {\n                  let ve = oe(A(de)).split(ee)[0];\n                  ge.push(N(le, ve, ce, de));\n                } else ge.push(r);\n              }\n            }, \"children\"), ge;\n          }\n          function N(ie, G, z, U) {\n            return ie ? \"\" : z.type === \"JSXElement\" && !z.closingElement || U && U.type === \"JSXElement\" && !U.closingElement ? G.length === 1 ? u : r : u;\n          }\n          function x(ie, G, z, U) {\n            return ie ? r : G.length === 1 ? z.type === \"JSXElement\" && !z.closingElement || U && U.type === \"JSXElement\" && !U.closingElement ? r : u : r;\n          }\n          function b(ie, G, z) {\n            let U = ie.getParentNode();\n            if (!U || {\n              ArrayExpression: !0,\n              JSXAttribute: !0,\n              JSXElement: !0,\n              JSXExpressionContainer: !0,\n              JSXFragment: !0,\n              ExpressionStatement: !0,\n              CallExpression: !0,\n              OptionalCallExpression: !0,\n              ConditionalExpression: !0,\n              JsExpressionRoot: !0\n            }[U.type]) return G;\n            let ge = ie.match(void 0, Ne => Ne.type === \"ArrowFunctionExpression\", B, Ne => Ne.type === \"JSXExpressionContainer\"),\n              Ae = g(ie, z);\n            return i([Ae ? \"\" : m(\"(\"), o([u, G]), u, Ae ? \"\" : m(\")\")], {\n              shouldBreak: ge\n            });\n          }\n          function L(ie, G, z) {\n            let U = ie.getValue(),\n              le = [];\n            if (le.push(z(\"name\")), U.value) {\n              let ge;\n              if (I(U.value)) {\n                let Ne = A(U.value).slice(1, -1).replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"'),\n                  {\n                    escaped: ke,\n                    quote: ce,\n                    regex: pe\n                  } = w(Ne, G.jsxSingleQuote ? \"'\" : '\"');\n                Ne = Ne.replace(pe, ke), ge = [ce, Ne, ce];\n              } else ge = z(\"value\");\n              le.push(\"=\", ge);\n            }\n            return le;\n          }\n          function M(ie, G, z) {\n            let U = ie.getValue(),\n              le = (ge, Ae) => ge.type === \"JSXEmptyExpression\" || !P(ge) && (ge.type === \"ArrayExpression\" || ge.type === \"ObjectExpression\" || ge.type === \"ArrowFunctionExpression\" || ge.type === \"AwaitExpression\" && (le(ge.argument, ge) || ge.argument.type === \"JSXElement\") || B(ge) || ge.type === \"FunctionExpression\" || ge.type === \"TemplateLiteral\" || ge.type === \"TaggedTemplateExpression\" || ge.type === \"DoExpression\" || T(Ae) && (ge.type === \"ConditionalExpression\" || k(ge)));\n            return le(U.expression, ie.getParentNode(0)) ? i([\"{\", z(\"expression\"), d, \"}\"]) : i([\"{\", o([u, z(\"expression\")]), u, d, \"}\"]);\n          }\n          function j(ie, G, z) {\n            let U = ie.getValue(),\n              le = U.name && P(U.name) || U.typeParameters && P(U.typeParameters);\n            if (U.selfClosing && U.attributes.length === 0 && !le) return [\"<\", z(\"name\"), z(\"typeParameters\"), \" />\"];\n            if (U.attributes && U.attributes.length === 1 && U.attributes[0].value && I(U.attributes[0].value) && !U.attributes[0].value.value.includes(`\n`) && !le && !P(U.attributes[0])) return i([\"<\", z(\"name\"), z(\"typeParameters\"), \" \", ...ie.map(z, \"attributes\"), U.selfClosing ? \" />\" : \">\"]);\n            let ge = U.attributes.length > 0 && P(h(U.attributes), C.Trailing),\n              Ae = U.attributes.length === 0 && !le || (G.bracketSameLine || G.jsxBracketSameLine) && (!le || U.attributes.length > 0) && !ge,\n              Ne = U.attributes && U.attributes.some(ce => ce.value && I(ce.value) && ce.value.value.includes(`\n`)),\n              ke = G.singleAttributePerLine && U.attributes.length > 1 ? r : a;\n            return i([\"<\", z(\"name\"), z(\"typeParameters\"), o(ie.map(() => [ke, z()], \"attributes\")), U.selfClosing ? a : Ae ? \">\" : u, U.selfClosing ? \"/>\" : Ae ? \"\" : \">\"], {\n              shouldBreak: Ne\n            });\n          }\n          function $(ie, G, z) {\n            let U = ie.getValue(),\n              le = [];\n            le.push(\"</\");\n            let ge = z(\"name\");\n            return P(U.name, C.Leading | C.Line) ? le.push(o([r, ge]), r) : P(U.name, C.Leading | C.Block) ? le.push(\" \", ge) : le.push(ge), le.push(\">\"), le;\n          }\n          function V(ie, G) {\n            let z = ie.getValue(),\n              U = P(z),\n              le = P(z, C.Line),\n              ge = z.type === \"JSXOpeningFragment\";\n            return [ge ? \"<\" : \"</\", o([le ? r : U && !ge ? \" \" : \"\", s(ie, G, !0)]), le ? r : \"\", \">\"];\n          }\n          function q(ie, G, z) {\n            let U = t(ie, E(ie, G, z), G);\n            return b(ie, U, G);\n          }\n          function Y(ie, G) {\n            let z = ie.getValue(),\n              U = P(z, C.Line);\n            return [s(ie, G, !U), U ? r : \"\"];\n          }\n          function H(ie, G, z) {\n            let U = ie.getValue();\n            return [\"{\", ie.call(le => {\n              let ge = [\"...\", z()],\n                Ae = le.getValue();\n              return !P(Ae) || !F(le) ? ge : [o([u, t(le, ge, G)]), u];\n            }, U.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"];\n          }\n          function R(ie, G, z) {\n            let U = ie.getValue();\n            if (!!U.type.startsWith(\"JSX\")) switch (U.type) {\n              case \"JSXAttribute\":\n                return L(ie, G, z);\n              case \"JSXIdentifier\":\n                return String(U.name);\n              case \"JSXNamespacedName\":\n                return p(\":\", [z(\"namespace\"), z(\"name\")]);\n              case \"JSXMemberExpression\":\n                return p(\".\", [z(\"object\"), z(\"property\")]);\n              case \"JSXSpreadAttribute\":\n                return H(ie, G, z);\n              case \"JSXSpreadChild\":\n                return H(ie, G, z);\n              case \"JSXExpressionContainer\":\n                return M(ie, G, z);\n              case \"JSXFragment\":\n              case \"JSXElement\":\n                return q(ie, G, z);\n              case \"JSXOpeningElement\":\n                return j(ie, G, z);\n              case \"JSXClosingElement\":\n                return $(ie, G, z);\n              case \"JSXOpeningFragment\":\n              case \"JSXClosingFragment\":\n                return V(ie, G);\n              case \"JSXEmptyExpression\":\n                return Y(ie, G);\n              case \"JSXText\":\n                throw new Error(\"JSXTest should be handled by JSXElement\");\n              default:\n                throw new Error(\"Unknown JSX node type: \".concat(JSON.stringify(U.type), \".\"));\n            }\n          }\n          var Q = ` \n\\r\t`,\n            ee = new RegExp(\"([\" + Q + \"]+)\"),\n            te = new RegExp(\"[^\" + Q + \"]\"),\n            oe = ie => ie.replace(new RegExp(\"(?:^\" + ee.source + \"|\" + ee.source + \"$)\"), \"\");\n          function W(ie) {\n            if (ie.children.length === 0) return !0;\n            if (ie.children.length > 1) return !1;\n            let G = ie.children[0];\n            return S(G) && !X(G);\n          }\n          function X(ie) {\n            return S(ie) && (te.test(A(ie)) || !/\\n/.test(A(ie)));\n          }\n          function ue(ie) {\n            return ie.type === \"JSXExpressionContainer\" && S(ie.expression) && ie.expression.value === \" \" && !P(ie.expression);\n          }\n          function De(ie) {\n            let G = ie.getValue(),\n              z = ie.getParentNode();\n            if (!z || !G || !T(G) || !T(z)) return !1;\n            let U = z.children.indexOf(G),\n              le = null;\n            for (let ge = U; ge > 0; ge--) {\n              let Ae = z.children[ge - 1];\n              if (!(Ae.type === \"JSXText\" && !X(Ae))) {\n                le = Ae;\n                break;\n              }\n            }\n            return le && le.type === \"JSXExpressionContainer\" && le.expression.type === \"JSXEmptyExpression\" && D(le.expression);\n          }\n          n.exports = {\n            hasJsxIgnoreComment: De,\n            printJsx: R\n          };\n        }\n      }),\n      ct = Z({\n        \"src/language-js/print/misc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isNonEmptyArray: t\n            } = Ue(),\n            {\n              builders: {\n                indent: s,\n                join: a,\n                line: r\n              }\n            } = Oe(),\n            {\n              isFlowAnnotationComment: u\n            } = Ke();\n          function i(h) {\n            let w = h.getValue();\n            return !w.optional || w.type === \"Identifier\" && w === h.getParentNode().key ? \"\" : w.type === \"OptionalCallExpression\" || w.type === \"OptionalMemberExpression\" && w.computed ? \"?.\" : \"?\";\n          }\n          function o(h) {\n            return h.getValue().definite || h.match(void 0, (w, T) => T === \"id\" && w.type === \"VariableDeclarator\" && w.definite) ? \"!\" : \"\";\n          }\n          function c(h, w, T) {\n            let A = h.getValue();\n            return A.typeArguments ? T(\"typeArguments\") : A.typeParameters ? T(\"typeParameters\") : \"\";\n          }\n          function v(h, w, T) {\n            let A = h.getValue();\n            if (!A.typeAnnotation) return \"\";\n            let S = h.getParentNode(),\n              B = S.type === \"DeclareFunction\" && S.id === A;\n            return u(w.originalText, A.typeAnnotation) ? [\" /*: \", T(\"typeAnnotation\"), \" */\"] : [B ? \"\" : \": \", T(\"typeAnnotation\")];\n          }\n          function m(h, w, T) {\n            return [\"::\", T(\"callee\")];\n          }\n          function d(h, w, T) {\n            let A = h.getValue();\n            return t(A.modifiers) ? [a(\" \", h.map(T, \"modifiers\")), \" \"] : \"\";\n          }\n          function p(h, w, T) {\n            return h.type === \"EmptyStatement\" ? \";\" : h.type === \"BlockStatement\" || T ? [\" \", w] : s([r, w]);\n          }\n          function f(h, w, T) {\n            return [\"...\", T(\"argument\"), v(h, w, T)];\n          }\n          n.exports = {\n            printOptionalToken: i,\n            printDefiniteToken: o,\n            printFunctionTypeParameters: c,\n            printBindExpressionCallee: m,\n            printTypeScriptModifiers: d,\n            printTypeAnnotation: v,\n            printRestSpread: f,\n            adjustClause: p\n          };\n        }\n      }),\n      Kt = Z({\n        \"src/language-js/print/array.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              builders: {\n                line: s,\n                softline: a,\n                hardline: r,\n                group: u,\n                indent: i,\n                ifBreak: o,\n                fill: c\n              }\n            } = Oe(),\n            {\n              getLast: v,\n              hasNewline: m\n            } = Ue(),\n            {\n              shouldPrintComma: d,\n              hasComment: p,\n              CommentCheckFlags: f,\n              isNextLineEmpty: h,\n              isNumericLiteral: w,\n              isSignedNumericLiteral: T\n            } = Ke(),\n            {\n              locStart: A\n            } = st(),\n            {\n              printOptionalToken: S,\n              printTypeAnnotation: B\n            } = ct();\n          function I(D, g, F) {\n            let l = D.getValue(),\n              E = [],\n              y = l.type === \"TupleExpression\" ? \"#[\" : \"[\",\n              N = \"]\";\n            if (l.elements.length === 0) p(l, f.Dangling) ? E.push(u([y, t(D, g), a, N])) : E.push(y, N);else {\n              let x = v(l.elements),\n                b = !(x && x.type === \"RestElement\"),\n                L = x === null,\n                M = Symbol(\"array\"),\n                j = !g.__inJestEach && l.elements.length > 1 && l.elements.every((q, Y, H) => {\n                  let R = q && q.type;\n                  if (R !== \"ArrayExpression\" && R !== \"ObjectExpression\") return !1;\n                  let Q = H[Y + 1];\n                  if (Q && R !== Q.type) return !1;\n                  let ee = R === \"ArrayExpression\" ? \"elements\" : \"properties\";\n                  return q[ee] && q[ee].length > 1;\n                }),\n                $ = k(l, g),\n                V = b ? L ? \",\" : d(g) ? $ ? o(\",\", \"\", {\n                  groupId: M\n                }) : o(\",\") : \"\" : \"\";\n              E.push(u([y, i([a, $ ? C(D, g, F, V) : [P(D, g, \"elements\", F), V], t(D, g, !0)]), a, N], {\n                shouldBreak: j,\n                id: M\n              }));\n            }\n            return E.push(S(D), B(D, g, F)), E;\n          }\n          function k(D, g) {\n            return D.elements.length > 1 && D.elements.every(F => F && (w(F) || T(F) && !p(F.argument)) && !p(F, f.Trailing | f.Line, l => !m(g.originalText, A(l), {\n              backwards: !0\n            })));\n          }\n          function P(D, g, F, l) {\n            let E = [],\n              y = [];\n            return D.each(N => {\n              E.push(y, u(l())), y = [\",\", s], N.getValue() && h(N.getValue(), g) && y.push(a);\n            }, F), E;\n          }\n          function C(D, g, F, l) {\n            let E = [];\n            return D.each((y, N, x) => {\n              let b = N === x.length - 1;\n              E.push([F(), b ? l : \",\"]), b || E.push(h(y.getValue(), g) ? [r, r] : p(x[N + 1], f.Leading | f.Line) ? r : s);\n            }, \"elements\"), c(E);\n          }\n          n.exports = {\n            printArray: I,\n            printArrayItems: P,\n            isConciselyPrintedArray: k\n          };\n        }\n      }),\n      io = Z({\n        \"src/language-js/print/call-arguments.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              getLast: s,\n              getPenultimate: a\n            } = Ue(),\n            {\n              getFunctionParameters: r,\n              hasComment: u,\n              CommentCheckFlags: i,\n              isFunctionCompositionArgs: o,\n              isJsxNode: c,\n              isLongCurriedCallExpression: v,\n              shouldPrintComma: m,\n              getCallArguments: d,\n              iterateCallArgumentsPath: p,\n              isNextLineEmpty: f,\n              isCallExpression: h,\n              isStringLiteral: w,\n              isObjectProperty: T\n            } = Ke(),\n            {\n              builders: {\n                line: A,\n                hardline: S,\n                softline: B,\n                group: I,\n                indent: k,\n                conditionalGroup: P,\n                ifBreak: C,\n                breakParent: D\n              },\n              utils: {\n                willBreak: g\n              }\n            } = Oe(),\n            {\n              ArgExpansionBailout: F\n            } = zt(),\n            {\n              isConciselyPrintedArray: l\n            } = Kt();\n          function E(j, $, V) {\n            let q = j.getValue(),\n              Y = q.type === \"ImportExpression\",\n              H = d(q);\n            if (H.length === 0) return [\"(\", t(j, $, !0), \")\"];\n            if (b(H)) return [\"(\", V([\"arguments\", 0]), \", \", V([\"arguments\", 1]), \")\"];\n            let R = !1,\n              Q = !1,\n              ee = H.length - 1,\n              te = [];\n            p(j, (ie, G) => {\n              let z = ie.getNode(),\n                U = [V()];\n              G === ee || (f(z, $) ? (G === 0 && (Q = !0), R = !0, U.push(\",\", S, S)) : U.push(\",\", A)), te.push(U);\n            });\n            let oe = !(Y || q.callee && q.callee.type === \"Import\") && m($, \"all\") ? \",\" : \"\";\n            function W() {\n              return I([\"(\", k([A, ...te]), oe, A, \")\"], {\n                shouldBreak: !0\n              });\n            }\n            if (R || j.getParentNode().type !== \"Decorator\" && o(H)) return W();\n            let X = x(H),\n              ue = N(H, $);\n            if (X || ue) {\n              if (X ? te.slice(1).some(g) : te.slice(0, -1).some(g)) return W();\n              let ie = [];\n              try {\n                j.try(() => {\n                  p(j, (G, z) => {\n                    X && z === 0 && (ie = [[V([], {\n                      expandFirstArg: !0\n                    }), te.length > 1 ? \",\" : \"\", Q ? S : A, Q ? S : \"\"], ...te.slice(1)]), ue && z === ee && (ie = [...te.slice(0, -1), V([], {\n                      expandLastArg: !0\n                    })]);\n                  });\n                });\n              } catch (G) {\n                if (G instanceof F) return W();\n                throw G;\n              }\n              return [te.some(g) ? D : \"\", P([[\"(\", ...ie, \")\"], X ? [\"(\", I(ie[0], {\n                shouldBreak: !0\n              }), ...ie.slice(1), \")\"] : [\"(\", ...te.slice(0, -1), I(s(ie), {\n                shouldBreak: !0\n              }), \")\"], W()])];\n            }\n            let De = [\"(\", k([B, ...te]), C(oe), B, \")\"];\n            return v(j) ? De : I(De, {\n              shouldBreak: te.some(g) || R\n            });\n          }\n          function y(j) {\n            let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n            return j.type === \"ObjectExpression\" && (j.properties.length > 0 || u(j)) || j.type === \"ArrayExpression\" && (j.elements.length > 0 || u(j)) || j.type === \"TSTypeAssertion\" && y(j.expression) || j.type === \"TSAsExpression\" && y(j.expression) || j.type === \"FunctionExpression\" || j.type === \"ArrowFunctionExpression\" && (!j.returnType || !j.returnType.typeAnnotation || j.returnType.typeAnnotation.type !== \"TSTypeReference\" || L(j.body)) && (j.body.type === \"BlockStatement\" || j.body.type === \"ArrowFunctionExpression\" && y(j.body, !0) || j.body.type === \"ObjectExpression\" || j.body.type === \"ArrayExpression\" || !$ && (h(j.body) || j.body.type === \"ConditionalExpression\") || c(j.body)) || j.type === \"DoExpression\" || j.type === \"ModuleExpression\";\n          }\n          function N(j, $) {\n            let V = s(j),\n              q = a(j);\n            return !u(V, i.Leading) && !u(V, i.Trailing) && y(V) && (!q || q.type !== V.type) && (j.length !== 2 || q.type !== \"ArrowFunctionExpression\" || V.type !== \"ArrayExpression\") && !(j.length > 1 && V.type === \"ArrayExpression\" && l(V, $));\n          }\n          function x(j) {\n            if (j.length !== 2) return !1;\n            let [$, V] = j;\n            return $.type === \"ModuleExpression\" && M(V) ? !0 : !u($) && ($.type === \"FunctionExpression\" || $.type === \"ArrowFunctionExpression\" && $.body.type === \"BlockStatement\") && V.type !== \"FunctionExpression\" && V.type !== \"ArrowFunctionExpression\" && V.type !== \"ConditionalExpression\" && !y(V);\n          }\n          function b(j) {\n            return j.length === 2 && j[0].type === \"ArrowFunctionExpression\" && r(j[0]).length === 0 && j[0].body.type === \"BlockStatement\" && j[1].type === \"ArrayExpression\" && !j.some($ => u($));\n          }\n          function L(j) {\n            return j.type === \"BlockStatement\" && (j.body.some($ => $.type !== \"EmptyStatement\") || u(j, i.Dangling));\n          }\n          function M(j) {\n            return j.type === \"ObjectExpression\" && j.properties.length === 1 && T(j.properties[0]) && j.properties[0].key.type === \"Identifier\" && j.properties[0].key.name === \"type\" && w(j.properties[0].value) && j.properties[0].value.value === \"module\";\n          }\n          n.exports = E;\n        }\n      }),\n      ao = Z({\n        \"src/language-js/print/member.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                softline: t,\n                group: s,\n                indent: a,\n                label: r\n              }\n            } = Oe(),\n            {\n              isNumericLiteral: u,\n              isMemberExpression: i,\n              isCallExpression: o\n            } = Ke(),\n            {\n              printOptionalToken: c\n            } = ct();\n          function v(d, p, f) {\n            let h = d.getValue(),\n              w = d.getParentNode(),\n              T,\n              A = 0;\n            do T = d.getParentNode(A), A++; while (T && (i(T) || T.type === \"TSNonNullExpression\"));\n            let S = f(\"object\"),\n              B = m(d, p, f),\n              I = T && (T.type === \"NewExpression\" || T.type === \"BindExpression\" || T.type === \"AssignmentExpression\" && T.left.type !== \"Identifier\") || h.computed || h.object.type === \"Identifier\" && h.property.type === \"Identifier\" && !i(w) || (w.type === \"AssignmentExpression\" || w.type === \"VariableDeclarator\") && (o(h.object) && h.object.arguments.length > 0 || h.object.type === \"TSNonNullExpression\" && o(h.object.expression) && h.object.expression.arguments.length > 0 || S.label === \"member-chain\");\n            return r(S.label === \"member-chain\" ? \"member-chain\" : \"member\", [S, I ? B : s(a([t, B]))]);\n          }\n          function m(d, p, f) {\n            let h = f(\"property\"),\n              w = d.getValue(),\n              T = c(d);\n            return w.computed ? !w.property || u(w.property) ? [T, \"[\", h, \"]\"] : s([T, \"[\", a([t, h]), t, \"]\"]) : [T, \".\", h];\n          }\n          n.exports = {\n            printMemberExpression: v,\n            printMemberLookup: m\n          };\n        }\n      }),\n      Jm = Z({\n        \"src/language-js/print/member-chain.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printComments: t\n            } = et(),\n            {\n              getLast: s,\n              isNextLineEmptyAfterIndex: a,\n              getNextNonSpaceNonCommentCharacterIndex: r\n            } = Ue(),\n            u = jt(),\n            {\n              isCallExpression: i,\n              isMemberExpression: o,\n              isFunctionOrArrowExpression: c,\n              isLongCurriedCallExpression: v,\n              isMemberish: m,\n              isNumericLiteral: d,\n              isSimpleCallArgument: p,\n              hasComment: f,\n              CommentCheckFlags: h,\n              isNextLineEmpty: w\n            } = Ke(),\n            {\n              locEnd: T\n            } = st(),\n            {\n              builders: {\n                join: A,\n                hardline: S,\n                group: B,\n                indent: I,\n                conditionalGroup: k,\n                breakParent: P,\n                label: C\n              },\n              utils: {\n                willBreak: D\n              }\n            } = Oe(),\n            g = io(),\n            {\n              printMemberLookup: F\n            } = ao(),\n            {\n              printOptionalToken: l,\n              printFunctionTypeParameters: E,\n              printBindExpressionCallee: y\n            } = ct();\n          function N(x, b, L) {\n            let M = x.getParentNode(),\n              j = !M || M.type === \"ExpressionStatement\",\n              $ = [];\n            function V(de) {\n              let {\n                  originalText: ae\n                } = b,\n                ve = r(ae, de, T);\n              return ae.charAt(ve) === \")\" ? ve !== !1 && a(ae, ve + 1) : w(de, b);\n            }\n            function q(de) {\n              let ae = de.getValue();\n              i(ae) && (m(ae.callee) || i(ae.callee)) ? ($.unshift({\n                node: ae,\n                printed: [t(de, [l(de), E(de, b, L), g(de, b, L)], b), V(ae) ? S : \"\"]\n              }), de.call(ve => q(ve), \"callee\")) : m(ae) ? ($.unshift({\n                node: ae,\n                needsParens: u(de, b),\n                printed: t(de, o(ae) ? F(de, b, L) : y(de, b, L), b)\n              }), de.call(ve => q(ve), \"object\")) : ae.type === \"TSNonNullExpression\" ? ($.unshift({\n                node: ae,\n                printed: t(de, \"!\", b)\n              }), de.call(ve => q(ve), \"expression\")) : $.unshift({\n                node: ae,\n                printed: L()\n              });\n            }\n            let Y = x.getValue();\n            $.unshift({\n              node: Y,\n              printed: [l(x), E(x, b, L), g(x, b, L)]\n            }), Y.callee && x.call(de => q(de), \"callee\");\n            let H = [],\n              R = [$[0]],\n              Q = 1;\n            for (; Q < $.length && ($[Q].node.type === \"TSNonNullExpression\" || i($[Q].node) || o($[Q].node) && $[Q].node.computed && d($[Q].node.property)); ++Q) R.push($[Q]);\n            if (!i($[0].node)) for (; Q + 1 < $.length && m($[Q].node) && m($[Q + 1].node); ++Q) R.push($[Q]);\n            H.push(R), R = [];\n            let ee = !1;\n            for (; Q < $.length; ++Q) {\n              if (ee && m($[Q].node)) {\n                if ($[Q].node.computed && d($[Q].node.property)) {\n                  R.push($[Q]);\n                  continue;\n                }\n                H.push(R), R = [], ee = !1;\n              }\n              (i($[Q].node) || $[Q].node.type === \"ImportExpression\") && (ee = !0), R.push($[Q]), f($[Q].node, h.Trailing) && (H.push(R), R = [], ee = !1);\n            }\n            R.length > 0 && H.push(R);\n            function te(de) {\n              return /^[A-Z]|^[$_]+$/.test(de);\n            }\n            function oe(de) {\n              return de.length <= b.tabWidth;\n            }\n            function W(de) {\n              let ae = de[1].length > 0 && de[1][0].node.computed;\n              if (de[0].length === 1) {\n                let K = de[0][0].node;\n                return K.type === \"ThisExpression\" || K.type === \"Identifier\" && (te(K.name) || j && oe(K.name) || ae);\n              }\n              let ve = s(de[0]).node;\n              return o(ve) && ve.property.type === \"Identifier\" && (te(ve.property.name) || ae);\n            }\n            let X = H.length >= 2 && !f(H[1][0].node) && W(H);\n            function ue(de) {\n              let ae = de.map(ve => ve.printed);\n              return de.length > 0 && s(de).needsParens ? [\"(\", ...ae, \")\"] : ae;\n            }\n            function De(de) {\n              return de.length === 0 ? \"\" : I(B([S, A(S, de.map(ue))]));\n            }\n            let ie = H.map(ue),\n              G = ie,\n              z = X ? 3 : 2,\n              U = H.flat(),\n              le = U.slice(1, -1).some(de => f(de.node, h.Leading)) || U.slice(0, -1).some(de => f(de.node, h.Trailing)) || H[z] && f(H[z][0].node, h.Leading);\n            if (H.length <= z && !le) return v(x) ? G : B(G);\n            let ge = s(H[X ? 1 : 0]).node,\n              Ae = !i(ge) && V(ge),\n              Ne = [ue(H[0]), X ? H.slice(1, 2).map(ue) : \"\", Ae ? S : \"\", De(H.slice(X ? 2 : 1))],\n              ke = $.map(de => {\n                let {\n                  node: ae\n                } = de;\n                return ae;\n              }).filter(i);\n            function ce() {\n              let de = s(s(H)).node,\n                ae = s(ie);\n              return i(de) && D(ae) && ke.slice(0, -1).some(ve => ve.arguments.some(c));\n            }\n            let pe;\n            return le || ke.length > 2 && ke.some(de => !de.arguments.every(ae => p(ae, 0))) || ie.slice(0, -1).some(D) || ce() ? pe = B(Ne) : pe = [D(G) || Ae ? P : \"\", k([G, Ne])], C(\"member-chain\", pe);\n          }\n          n.exports = N;\n        }\n      }),\n      oo = Z({\n        \"src/language-js/print/call-expression.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                join: t,\n                group: s\n              }\n            } = Oe(),\n            a = jt(),\n            {\n              getCallArguments: r,\n              hasFlowAnnotationComment: u,\n              isCallExpression: i,\n              isMemberish: o,\n              isStringLiteral: c,\n              isTemplateOnItsOwnLine: v,\n              isTestCall: m,\n              iterateCallArgumentsPath: d\n            } = Ke(),\n            p = Jm(),\n            f = io(),\n            {\n              printOptionalToken: h,\n              printFunctionTypeParameters: w\n            } = ct();\n          function T(S, B, I) {\n            let k = S.getValue(),\n              P = S.getParentNode(),\n              C = k.type === \"NewExpression\",\n              D = k.type === \"ImportExpression\",\n              g = h(S),\n              F = r(k);\n            if (F.length > 0 && (!D && !C && A(k, P) || F.length === 1 && v(F[0], B.originalText) || !C && m(k, P))) {\n              let y = [];\n              return d(S, () => {\n                y.push(I());\n              }), [C ? \"new \" : \"\", I(\"callee\"), g, w(S, B, I), \"(\", t(\", \", y), \")\"];\n            }\n            let l = (B.parser === \"babel\" || B.parser === \"babel-flow\") && k.callee && k.callee.type === \"Identifier\" && u(k.callee.trailingComments);\n            if (l && (k.callee.trailingComments[0].printed = !0), !D && !C && o(k.callee) && !S.call(y => a(y, B), \"callee\")) return p(S, B, I);\n            let E = [C ? \"new \" : \"\", D ? \"import\" : I(\"callee\"), g, l ? \"/*:: \".concat(k.callee.trailingComments[0].value.slice(2).trim(), \" */\") : \"\", w(S, B, I), f(S, B, I)];\n            return D || i(k.callee) ? s(E) : E;\n          }\n          function A(S, B) {\n            if (S.callee.type !== \"Identifier\") return !1;\n            if (S.callee.name === \"require\") return !0;\n            if (S.callee.name === \"define\") {\n              let I = r(S);\n              return B.type === \"ExpressionStatement\" && (I.length === 1 || I.length === 2 && I[0].type === \"ArrayExpression\" || I.length === 3 && c(I[0]) && I[1].type === \"ArrayExpression\");\n            }\n            return !1;\n          }\n          n.exports = {\n            printCallExpression: T\n          };\n        }\n      }),\n      Yt = Z({\n        \"src/language-js/print/assignment.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isNonEmptyArray: t,\n              getStringWidth: s\n            } = Ue(),\n            {\n              builders: {\n                line: a,\n                group: r,\n                indent: u,\n                indentIfBreak: i,\n                lineSuffixBoundary: o\n              },\n              utils: {\n                cleanDoc: c,\n                willBreak: v,\n                canBreak: m\n              }\n            } = Oe(),\n            {\n              hasLeadingOwnLineComment: d,\n              isBinaryish: p,\n              isStringLiteral: f,\n              isLiteral: h,\n              isNumericLiteral: w,\n              isCallExpression: T,\n              isMemberExpression: A,\n              getCallArguments: S,\n              rawText: B,\n              hasComment: I,\n              isSignedNumericLiteral: k,\n              isObjectProperty: P\n            } = Ke(),\n            {\n              shouldInlineLogicalExpression: C\n            } = Jn(),\n            {\n              printCallExpression: D\n            } = oo();\n          function g(W, X, ue, De, ie, G) {\n            let z = E(W, X, ue, De, G),\n              U = ue(G, {\n                assignmentLayout: z\n              });\n            switch (z) {\n              case \"break-after-operator\":\n                return r([r(De), ie, r(u([a, U]))]);\n              case \"never-break-after-operator\":\n                return r([r(De), ie, \" \", U]);\n              case \"fluid\":\n                {\n                  let le = Symbol(\"assignment\");\n                  return r([r(De), ie, r(u(a), {\n                    id: le\n                  }), o, i(U, {\n                    groupId: le\n                  })]);\n                }\n              case \"break-lhs\":\n                return r([De, ie, \" \", r(U)]);\n              case \"chain\":\n                return [r(De), ie, a, U];\n              case \"chain-tail\":\n                return [r(De), ie, u([a, U])];\n              case \"chain-tail-arrow-chain\":\n                return [r(De), ie, U];\n              case \"only-left\":\n                return De;\n            }\n          }\n          function F(W, X, ue) {\n            let De = W.getValue();\n            return g(W, X, ue, ue(\"left\"), [\" \", De.operator], \"right\");\n          }\n          function l(W, X, ue) {\n            return g(W, X, ue, ue(\"id\"), \" =\", \"init\");\n          }\n          function E(W, X, ue, De, ie) {\n            let G = W.getValue(),\n              z = G[ie];\n            if (!z) return \"only-left\";\n            let U = !x(z);\n            if (W.match(x, b, Ne => !U || Ne.type !== \"ExpressionStatement\" && Ne.type !== \"VariableDeclaration\")) return U ? z.type === \"ArrowFunctionExpression\" && z.body.type === \"ArrowFunctionExpression\" ? \"chain-tail-arrow-chain\" : \"chain-tail\" : \"chain\";\n            if (!U && x(z.right) || d(X.originalText, z)) return \"break-after-operator\";\n            if (z.type === \"CallExpression\" && z.callee.name === \"require\" || X.parser === \"json5\" || X.parser === \"json\") return \"never-break-after-operator\";\n            if (N(G) || L(G) || $(G) || V(G) && m(De)) return \"break-lhs\";\n            let Ae = ee(G, De, X);\n            return W.call(() => y(W, X, ue, Ae), ie) ? \"break-after-operator\" : Ae || z.type === \"TemplateLiteral\" || z.type === \"TaggedTemplateExpression\" || z.type === \"BooleanLiteral\" || w(z) || z.type === \"ClassExpression\" ? \"never-break-after-operator\" : \"fluid\";\n          }\n          function y(W, X, ue, De) {\n            let ie = W.getValue();\n            if (p(ie) && !C(ie)) return !0;\n            switch (ie.type) {\n              case \"StringLiteralTypeAnnotation\":\n              case \"SequenceExpression\":\n                return !0;\n              case \"ConditionalExpression\":\n                {\n                  let {\n                    test: U\n                  } = ie;\n                  return p(U) && !C(U);\n                }\n              case \"ClassExpression\":\n                return t(ie.decorators);\n            }\n            if (De) return !1;\n            let G = ie,\n              z = [];\n            for (;;) if (G.type === \"UnaryExpression\") G = G.argument, z.push(\"argument\");else if (G.type === \"TSNonNullExpression\") G = G.expression, z.push(\"expression\");else break;\n            return !!(f(G) || W.call(() => H(W, X, ue), ...z));\n          }\n          function N(W) {\n            if (b(W)) {\n              let X = W.left || W.id;\n              return X.type === \"ObjectPattern\" && X.properties.length > 2 && X.properties.some(ue => P(ue) && (!ue.shorthand || ue.value && ue.value.type === \"AssignmentPattern\"));\n            }\n            return !1;\n          }\n          function x(W) {\n            return W.type === \"AssignmentExpression\";\n          }\n          function b(W) {\n            return x(W) || W.type === \"VariableDeclarator\";\n          }\n          function L(W) {\n            let X = M(W);\n            if (t(X)) {\n              let ue = W.type === \"TSTypeAliasDeclaration\" ? \"constraint\" : \"bound\";\n              if (X.length > 1 && X.some(De => De[ue] || De.default)) return !0;\n            }\n            return !1;\n          }\n          function M(W) {\n            return j(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;\n          }\n          function j(W) {\n            return W.type === \"TSTypeAliasDeclaration\" || W.type === \"TypeAlias\";\n          }\n          function $(W) {\n            if (W.type !== \"VariableDeclarator\") return !1;\n            let {\n              typeAnnotation: X\n            } = W.id;\n            if (!X || !X.typeAnnotation) return !1;\n            let ue = q(X.typeAnnotation);\n            return t(ue) && ue.length > 1 && ue.some(De => t(q(De)) || De.type === \"TSConditionalType\");\n          }\n          function V(W) {\n            return W.type === \"VariableDeclarator\" && W.init && W.init.type === \"ArrowFunctionExpression\";\n          }\n          function q(W) {\n            return Y(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;\n          }\n          function Y(W) {\n            return W.type === \"TSTypeReference\" || W.type === \"GenericTypeAnnotation\";\n          }\n          function H(W, X, ue) {\n            let De = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,\n              ie = W.getValue(),\n              G = () => H(W, X, ue, !0);\n            if (ie.type === \"TSNonNullExpression\") return W.call(G, \"expression\");\n            if (T(ie)) {\n              if (D(W, X, ue).label === \"member-chain\") return !1;\n              let U = S(ie);\n              return !(U.length === 0 || U.length === 1 && Q(U[0], X)) || te(ie, ue) ? !1 : W.call(G, \"callee\");\n            }\n            return A(ie) ? W.call(G, \"object\") : De && (ie.type === \"Identifier\" || ie.type === \"ThisExpression\");\n          }\n          var R = .25;\n          function Q(W, X) {\n            let {\n              printWidth: ue\n            } = X;\n            if (I(W)) return !1;\n            let De = ue * R;\n            if (W.type === \"ThisExpression\" || W.type === \"Identifier\" && W.name.length <= De || k(W) && !I(W.argument)) return !0;\n            let ie = W.type === \"Literal\" && \"regex\" in W && W.regex.pattern || W.type === \"RegExpLiteral\" && W.pattern;\n            return ie ? ie.length <= De : f(W) ? B(W).length <= De : W.type === \"TemplateLiteral\" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= De && !W.quasis[0].value.raw.includes(`\n`) : h(W);\n          }\n          function ee(W, X, ue) {\n            if (!P(W)) return !1;\n            X = c(X);\n            let De = 3;\n            return typeof X == \"string\" && s(X) < ue.tabWidth + De;\n          }\n          function te(W, X) {\n            let ue = oe(W);\n            if (t(ue)) {\n              if (ue.length > 1) return !0;\n              if (ue.length === 1) {\n                let ie = ue[0];\n                if (ie.type === \"TSUnionType\" || ie.type === \"UnionTypeAnnotation\" || ie.type === \"TSIntersectionType\" || ie.type === \"IntersectionTypeAnnotation\" || ie.type === \"TSTypeLiteral\" || ie.type === \"ObjectTypeAnnotation\") return !0;\n              }\n              let De = W.typeParameters ? \"typeParameters\" : \"typeArguments\";\n              if (v(X(De))) return !0;\n            }\n            return !1;\n          }\n          function oe(W) {\n            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;\n          }\n          n.exports = {\n            printVariableDeclarator: l,\n            printAssignmentExpression: F,\n            printAssignment: g,\n            isArrowFunctionVariableDeclarator: V\n          };\n        }\n      }),\n      Pr = Z({\n        \"src/language-js/print/function-parameters.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              getNextNonSpaceNonCommentCharacter: t\n            } = Ue(),\n            {\n              printDanglingComments: s\n            } = et(),\n            {\n              builders: {\n                line: a,\n                hardline: r,\n                softline: u,\n                group: i,\n                indent: o,\n                ifBreak: c\n              },\n              utils: {\n                removeLines: v,\n                willBreak: m\n              }\n            } = Oe(),\n            {\n              getFunctionParameters: d,\n              iterateFunctionParametersPath: p,\n              isSimpleType: f,\n              isTestCall: h,\n              isTypeAnnotationAFunction: w,\n              isObjectType: T,\n              isObjectTypePropertyAFunction: A,\n              hasRestParameter: S,\n              shouldPrintComma: B,\n              hasComment: I,\n              isNextLineEmpty: k\n            } = Ke(),\n            {\n              locEnd: P\n            } = st(),\n            {\n              ArgExpansionBailout: C\n            } = zt(),\n            {\n              printFunctionTypeParameters: D\n            } = ct();\n          function g(y, N, x, b, L) {\n            let M = y.getValue(),\n              j = d(M),\n              $ = L ? D(y, x, N) : \"\";\n            if (j.length === 0) return [$, \"(\", s(y, x, !0, ee => t(x.originalText, ee, P) === \")\"), \")\"];\n            let V = y.getParentNode(),\n              q = h(V),\n              Y = F(M),\n              H = [];\n            if (p(y, (ee, te) => {\n              let oe = te === j.length - 1;\n              oe && M.rest && H.push(\"...\"), H.push(N()), !oe && (H.push(\",\"), q || Y ? H.push(\" \") : k(j[te], x) ? H.push(r, r) : H.push(a));\n            }), b) {\n              if (m($) || m(H)) throw new C();\n              return i([v($), \"(\", v(H), \")\"]);\n            }\n            let R = j.every(ee => !ee.decorators);\n            return Y && R ? [$, \"(\", ...H, \")\"] : q ? [$, \"(\", ...H, \")\"] : (A(V) || w(V) || V.type === \"TypeAlias\" || V.type === \"UnionTypeAnnotation\" || V.type === \"TSUnionType\" || V.type === \"IntersectionTypeAnnotation\" || V.type === \"FunctionTypeAnnotation\" && V.returnType === M) && j.length === 1 && j[0].name === null && M.this !== j[0] && j[0].typeAnnotation && M.typeParameters === null && f(j[0].typeAnnotation) && !M.rest ? x.arrowParens === \"always\" ? [\"(\", ...H, \")\"] : H : [$, \"(\", o([u, ...H]), c(!S(M) && B(x, \"all\") ? \",\" : \"\"), u, \")\"];\n          }\n          function F(y) {\n            if (!y) return !1;\n            let N = d(y);\n            if (N.length !== 1) return !1;\n            let [x] = N;\n            return !I(x) && (x.type === \"ObjectPattern\" || x.type === \"ArrayPattern\" || x.type === \"Identifier\" && x.typeAnnotation && (x.typeAnnotation.type === \"TypeAnnotation\" || x.typeAnnotation.type === \"TSTypeAnnotation\") && T(x.typeAnnotation.typeAnnotation) || x.type === \"FunctionTypeParam\" && T(x.typeAnnotation) || x.type === \"AssignmentPattern\" && (x.left.type === \"ObjectPattern\" || x.left.type === \"ArrayPattern\") && (x.right.type === \"Identifier\" || x.right.type === \"ObjectExpression\" && x.right.properties.length === 0 || x.right.type === \"ArrayExpression\" && x.right.elements.length === 0));\n          }\n          function l(y) {\n            let N;\n            return y.returnType ? (N = y.returnType, N.typeAnnotation && (N = N.typeAnnotation)) : y.typeAnnotation && (N = y.typeAnnotation), N;\n          }\n          function E(y, N) {\n            let x = l(y);\n            if (!x) return !1;\n            let b = y.typeParameters && y.typeParameters.params;\n            if (b) {\n              if (b.length > 1) return !1;\n              if (b.length === 1) {\n                let L = b[0];\n                if (L.constraint || L.default) return !1;\n              }\n            }\n            return d(y).length === 1 && (T(x) || m(N));\n          }\n          n.exports = {\n            printFunctionParameters: g,\n            shouldHugFunctionParameters: F,\n            shouldGroupFunctionParameters: E\n          };\n        }\n      }),\n      kr = Z({\n        \"src/language-js/print/type-annotation.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printComments: t,\n              printDanglingComments: s\n            } = et(),\n            {\n              isNonEmptyArray: a\n            } = Ue(),\n            {\n              builders: {\n                group: r,\n                join: u,\n                line: i,\n                softline: o,\n                indent: c,\n                align: v,\n                ifBreak: m\n              }\n            } = Oe(),\n            d = jt(),\n            {\n              locStart: p\n            } = st(),\n            {\n              isSimpleType: f,\n              isObjectType: h,\n              hasLeadingOwnLineComment: w,\n              isObjectTypePropertyAFunction: T,\n              shouldPrintComma: A\n            } = Ke(),\n            {\n              printAssignment: S\n            } = Yt(),\n            {\n              printFunctionParameters: B,\n              shouldGroupFunctionParameters: I\n            } = Pr(),\n            {\n              printArrayItems: k\n            } = Kt();\n          function P(x) {\n            if (f(x) || h(x)) return !0;\n            if (x.type === \"UnionTypeAnnotation\" || x.type === \"TSUnionType\") {\n              let b = x.types.filter(M => M.type === \"VoidTypeAnnotation\" || M.type === \"TSVoidKeyword\" || M.type === \"NullLiteralTypeAnnotation\" || M.type === \"TSNullKeyword\").length,\n                L = x.types.some(M => M.type === \"ObjectTypeAnnotation\" || M.type === \"TSTypeLiteral\" || M.type === \"GenericTypeAnnotation\" || M.type === \"TSTypeReference\");\n              if (x.types.length - 1 === b && L) return !0;\n            }\n            return !1;\n          }\n          function C(x, b, L) {\n            let M = b.semi ? \";\" : \"\",\n              j = x.getValue(),\n              $ = [];\n            return $.push(\"opaque type \", L(\"id\"), L(\"typeParameters\")), j.supertype && $.push(\": \", L(\"supertype\")), j.impltype && $.push(\" = \", L(\"impltype\")), $.push(M), $;\n          }\n          function D(x, b, L) {\n            let M = b.semi ? \";\" : \"\",\n              j = x.getValue(),\n              $ = [];\n            j.declare && $.push(\"declare \"), $.push(\"type \", L(\"id\"), L(\"typeParameters\"));\n            let V = j.type === \"TSTypeAliasDeclaration\" ? \"typeAnnotation\" : \"right\";\n            return [S(x, b, L, $, \" =\", V), M];\n          }\n          function g(x, b, L) {\n            let M = x.getValue(),\n              j = x.map(L, \"types\"),\n              $ = [],\n              V = !1;\n            for (let q = 0; q < j.length; ++q) q === 0 ? $.push(j[q]) : h(M.types[q - 1]) && h(M.types[q]) ? $.push([\" & \", V ? c(j[q]) : j[q]]) : !h(M.types[q - 1]) && !h(M.types[q]) ? $.push(c([\" &\", i, j[q]])) : (q > 1 && (V = !0), $.push(\" & \", q > 1 ? c(j[q]) : j[q]));\n            return r($);\n          }\n          function F(x, b, L) {\n            let M = x.getValue(),\n              j = x.getParentNode(),\n              $ = j.type !== \"TypeParameterInstantiation\" && j.type !== \"TSTypeParameterInstantiation\" && j.type !== \"GenericTypeAnnotation\" && j.type !== \"TSTypeReference\" && j.type !== \"TSTypeAssertion\" && j.type !== \"TupleTypeAnnotation\" && j.type !== \"TSTupleType\" && !(j.type === \"FunctionTypeParam\" && !j.name && x.getParentNode(1).this !== j) && !((j.type === \"TypeAlias\" || j.type === \"VariableDeclarator\" || j.type === \"TSTypeAliasDeclaration\") && w(b.originalText, M)),\n              V = P(M),\n              q = x.map(R => {\n                let Q = L();\n                return V || (Q = v(2, Q)), t(R, Q, b);\n              }, \"types\");\n            if (V) return u(\" | \", q);\n            let Y = $ && !w(b.originalText, M),\n              H = [m([Y ? i : \"\", \"| \"]), u([i, \"| \"], q)];\n            return d(x, b) ? r([c(H), o]) : j.type === \"TupleTypeAnnotation\" && j.types.length > 1 || j.type === \"TSTupleType\" && j.elementTypes.length > 1 ? r([c([m([\"(\", o]), H]), o, m(\")\")]) : r($ ? c(H) : H);\n          }\n          function l(x, b, L) {\n            let M = x.getValue(),\n              j = [],\n              $ = x.getParentNode(0),\n              V = x.getParentNode(1),\n              q = x.getParentNode(2),\n              Y = M.type === \"TSFunctionType\" || !(($.type === \"ObjectTypeProperty\" || $.type === \"ObjectTypeInternalSlot\") && !$.variance && !$.optional && p($) === p(M) || $.type === \"ObjectTypeCallProperty\" || q && q.type === \"DeclareFunction\"),\n              H = Y && ($.type === \"TypeAnnotation\" || $.type === \"TSTypeAnnotation\"),\n              R = H && Y && ($.type === \"TypeAnnotation\" || $.type === \"TSTypeAnnotation\") && V.type === \"ArrowFunctionExpression\";\n            T($) && (Y = !0, H = !0), R && j.push(\"(\");\n            let Q = B(x, L, b, !1, !0),\n              ee = M.returnType || M.predicate || M.typeAnnotation ? [Y ? \" => \" : \": \", L(\"returnType\"), L(\"predicate\"), L(\"typeAnnotation\")] : \"\",\n              te = I(M, ee);\n            return j.push(te ? r(Q) : Q), ee && j.push(ee), R && j.push(\")\"), r(j);\n          }\n          function E(x, b, L) {\n            let M = x.getValue(),\n              j = M.type === \"TSTupleType\" ? \"elementTypes\" : \"types\",\n              $ = M[j],\n              V = a($),\n              q = V ? o : \"\";\n            return r([\"[\", c([q, k(x, b, j, L)]), m(V && A(b, \"all\") ? \",\" : \"\"), s(x, b, !0), q, \"]\"]);\n          }\n          function y(x, b, L) {\n            let M = x.getValue(),\n              j = M.type === \"OptionalIndexedAccessType\" && M.optional ? \"?.[\" : \"[\";\n            return [L(\"objectType\"), j, L(\"indexType\"), \"]\"];\n          }\n          function N(x, b, L) {\n            let M = x.getValue();\n            return [M.postfix ? \"\" : L, b(\"typeAnnotation\"), M.postfix ? L : \"\"];\n          }\n          n.exports = {\n            printOpaqueType: C,\n            printTypeAlias: D,\n            printIntersectionType: g,\n            printUnionType: F,\n            printFunctionType: l,\n            printTupleType: E,\n            printIndexedAccessType: y,\n            shouldHugType: P,\n            printJSDocType: N\n          };\n        }\n      }),\n      Ir = Z({\n        \"src/language-js/print/type-parameters.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              builders: {\n                join: s,\n                line: a,\n                hardline: r,\n                softline: u,\n                group: i,\n                indent: o,\n                ifBreak: c\n              }\n            } = Oe(),\n            {\n              isTestCall: v,\n              hasComment: m,\n              CommentCheckFlags: d,\n              isTSXFile: p,\n              shouldPrintComma: f,\n              getFunctionParameters: h,\n              isObjectType: w\n            } = Ke(),\n            {\n              createGroupIdMapper: T\n            } = Ue(),\n            {\n              shouldHugType: A\n            } = kr(),\n            {\n              isArrowFunctionVariableDeclarator: S\n            } = Yt(),\n            B = T(\"typeParameters\");\n          function I(C, D, g, F) {\n            let l = C.getValue();\n            if (!l[F]) return \"\";\n            if (!Array.isArray(l[F])) return g(F);\n            let E = C.getNode(2),\n              y = E && v(E);\n            if (!C.match(L => !(L[F].length === 1 && w(L[F][0])), void 0, (L, M) => M === \"typeAnnotation\", L => L.type === \"Identifier\", S) && (y || l[F].length === 0 || l[F].length === 1 && (l[F][0].type === \"NullableTypeAnnotation\" || A(l[F][0])))) return [\"<\", s(\", \", C.map(g, F)), k(C, D), \">\"];\n            let b = l.type === \"TSTypeParameterInstantiation\" ? \"\" : h(l).length === 1 && p(D) && !l[F][0].constraint && C.getParentNode().type === \"ArrowFunctionExpression\" ? \",\" : f(D, \"all\") ? c(\",\") : \"\";\n            return i([\"<\", o([u, s([\",\", a], C.map(g, F))]), b, u, \">\"], {\n              id: B(l)\n            });\n          }\n          function k(C, D) {\n            let g = C.getValue();\n            if (!m(g, d.Dangling)) return \"\";\n            let F = !m(g, d.Line),\n              l = t(C, D, F);\n            return F ? l : [l, r];\n          }\n          function P(C, D, g) {\n            let F = C.getValue(),\n              l = [],\n              E = C.getParentNode();\n            return E.type === \"TSMappedType\" ? (l.push(\"[\", g(\"name\")), F.constraint && l.push(\" in \", g(\"constraint\")), E.nameType && l.push(\" as \", C.callParent(() => g(\"nameType\"))), l.push(\"]\"), l) : (F.variance && l.push(g(\"variance\")), F.in && l.push(\"in \"), F.out && l.push(\"out \"), l.push(g(\"name\")), F.bound && l.push(\": \", g(\"bound\")), F.constraint && l.push(\" extends \", g(\"constraint\")), F.default && l.push(\" = \", g(\"default\")), l);\n          }\n          n.exports = {\n            printTypeParameter: P,\n            printTypeParameters: I,\n            getTypeParametersGroupId: B\n          };\n        }\n      }),\n      Qt = Z({\n        \"src/language-js/print/property.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printComments: t\n            } = et(),\n            {\n              printString: s,\n              printNumber: a\n            } = Ue(),\n            {\n              isNumericLiteral: r,\n              isSimpleNumber: u,\n              isStringLiteral: i,\n              isStringPropSafeToUnquote: o,\n              rawText: c\n            } = Ke(),\n            {\n              printAssignment: v\n            } = Yt(),\n            m = new WeakMap();\n          function d(f, h, w) {\n            let T = f.getNode();\n            if (T.computed) return [\"[\", w(\"key\"), \"]\"];\n            let A = f.getParentNode(),\n              {\n                key: S\n              } = T;\n            if (T.type === \"ClassPrivateProperty\" && S.type === \"Identifier\") return [\"#\", w(\"key\")];\n            if (h.quoteProps === \"consistent\" && !m.has(A)) {\n              let B = (A.properties || A.body || A.members).some(I => !I.computed && I.key && i(I.key) && !o(I, h));\n              m.set(A, B);\n            }\n            if ((S.type === \"Identifier\" || r(S) && u(a(c(S))) && String(S.value) === a(c(S)) && !(h.parser === \"typescript\" || h.parser === \"babel-ts\")) && (h.parser === \"json\" || h.quoteProps === \"consistent\" && m.get(A))) {\n              let B = s(JSON.stringify(S.type === \"Identifier\" ? S.name : S.value.toString()), h);\n              return f.call(I => t(I, B, h), \"key\");\n            }\n            return o(T, h) && (h.quoteProps === \"as-needed\" || h.quoteProps === \"consistent\" && !m.get(A)) ? f.call(B => t(B, /^\\d/.test(S.value) ? a(S.value) : S.value, h), \"key\") : w(\"key\");\n          }\n          function p(f, h, w) {\n            return f.getValue().shorthand ? w(\"value\") : v(f, h, w, d(f, h, w), \":\", \"value\");\n          }\n          n.exports = {\n            printProperty: p,\n            printPropertyKey: d\n          };\n        }\n      }),\n      Lr = Z({\n        \"src/language-js/print/function.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Xt(),\n            {\n              printDanglingComments: s,\n              printCommentsSeparately: a\n            } = et(),\n            r = it(),\n            {\n              getNextNonSpaceNonCommentCharacterIndex: u\n            } = Ue(),\n            {\n              builders: {\n                line: i,\n                softline: o,\n                group: c,\n                indent: v,\n                ifBreak: m,\n                hardline: d,\n                join: p,\n                indentIfBreak: f\n              },\n              utils: {\n                removeLines: h,\n                willBreak: w\n              }\n            } = Oe(),\n            {\n              ArgExpansionBailout: T\n            } = zt(),\n            {\n              getFunctionParameters: A,\n              hasLeadingOwnLineComment: S,\n              isFlowAnnotationComment: B,\n              isJsxNode: I,\n              isTemplateOnItsOwnLine: k,\n              shouldPrintComma: P,\n              startsWithNoLookaheadToken: C,\n              isBinaryish: D,\n              isLineComment: g,\n              hasComment: F,\n              getComments: l,\n              CommentCheckFlags: E,\n              isCallLikeExpression: y,\n              isCallExpression: N,\n              getCallArguments: x,\n              hasNakedLeftSide: b,\n              getLeftSide: L\n            } = Ke(),\n            {\n              locEnd: M\n            } = st(),\n            {\n              printFunctionParameters: j,\n              shouldGroupFunctionParameters: $\n            } = Pr(),\n            {\n              printPropertyKey: V\n            } = Qt(),\n            {\n              printFunctionTypeParameters: q\n            } = ct();\n          function Y(z, U, le, ge) {\n            let Ae = z.getValue(),\n              Ne = !1;\n            if ((Ae.type === \"FunctionDeclaration\" || Ae.type === \"FunctionExpression\") && ge && ge.expandLastArg) {\n              let ae = z.getParentNode();\n              N(ae) && x(ae).length > 1 && (Ne = !0);\n            }\n            let ke = [];\n            Ae.type === \"TSDeclareFunction\" && Ae.declare && ke.push(\"declare \"), Ae.async && ke.push(\"async \"), Ae.generator ? ke.push(\"function* \") : ke.push(\"function \"), Ae.id && ke.push(U(\"id\"));\n            let ce = j(z, U, le, Ne),\n              pe = X(z, U, le),\n              de = $(Ae, pe);\n            return ke.push(q(z, le, U), c([de ? c(ce) : ce, pe]), Ae.body ? \" \" : \"\", U(\"body\")), le.semi && (Ae.declare || !Ae.body) && ke.push(\";\"), ke;\n          }\n          function H(z, U, le) {\n            let ge = z.getNode(),\n              {\n                kind: Ae\n              } = ge,\n              Ne = ge.value || ge,\n              ke = [];\n            return !Ae || Ae === \"init\" || Ae === \"method\" || Ae === \"constructor\" ? Ne.async && ke.push(\"async \") : (t.ok(Ae === \"get\" || Ae === \"set\"), ke.push(Ae, \" \")), Ne.generator && ke.push(\"*\"), ke.push(V(z, U, le), ge.optional || ge.key.optional ? \"?\" : \"\"), ge === Ne ? ke.push(R(z, U, le)) : Ne.type === \"FunctionExpression\" ? ke.push(z.call(ce => R(ce, U, le), \"value\")) : ke.push(le(\"value\")), ke;\n          }\n          function R(z, U, le) {\n            let ge = z.getNode(),\n              Ae = j(z, le, U),\n              Ne = X(z, le, U),\n              ke = $(ge, Ne),\n              ce = [q(z, U, le), c([ke ? c(Ae) : Ae, Ne])];\n            return ge.body ? ce.push(\" \", le(\"body\")) : ce.push(U.semi ? \";\" : \"\"), ce;\n          }\n          function Q(z, U, le, ge) {\n            let Ae = z.getValue(),\n              Ne = [];\n            if (Ae.async && Ne.push(\"async \"), W(z, U)) Ne.push(le([\"params\", 0]));else {\n              let ce = ge && (ge.expandLastArg || ge.expandFirstArg),\n                pe = X(z, le, U);\n              if (ce) {\n                if (w(pe)) throw new T();\n                pe = c(h(pe));\n              }\n              Ne.push(c([j(z, le, U, ce, !0), pe]));\n            }\n            let ke = s(z, U, !0, ce => {\n              let pe = u(U.originalText, ce, M);\n              return pe !== !1 && U.originalText.slice(pe, pe + 2) === \"=>\";\n            });\n            return ke && Ne.push(\" \", ke), Ne;\n          }\n          function ee(z, U, le, ge, Ae, Ne) {\n            let ke = z.getName(),\n              ce = z.getParentNode(),\n              pe = y(ce) && ke === \"callee\",\n              de = Boolean(U && U.assignmentLayout),\n              ae = Ne.body.type !== \"BlockStatement\" && Ne.body.type !== \"ObjectExpression\" && Ne.body.type !== \"SequenceExpression\",\n              ve = pe && ae || U && U.assignmentLayout === \"chain-tail-arrow-chain\",\n              K = Symbol(\"arrow-chain\");\n            return Ne.body.type === \"SequenceExpression\" && (Ae = c([\"(\", v([o, Ae]), o, \")\"])), c([c(v([pe || de ? o : \"\", c(p([\" =>\", i], le), {\n              shouldBreak: ge\n            })]), {\n              id: K,\n              shouldBreak: ve\n            }), \" =>\", f(ae ? v([i, Ae]) : [\" \", Ae], {\n              groupId: K\n            }), pe ? m(o, \"\", {\n              groupId: K\n            }) : \"\"]);\n          }\n          function te(z, U, le, ge) {\n            let Ae = z.getValue(),\n              Ne = [],\n              ke = [],\n              ce = !1;\n            if (function K() {\n              let he = Q(z, U, le, ge);\n              if (Ne.length === 0) Ne.push(he);else {\n                let {\n                  leading: ye,\n                  trailing: Ce\n                } = a(z, U);\n                Ne.push([ye, he]), ke.unshift(Ce);\n              }\n              ce = ce || Ae.returnType && A(Ae).length > 0 || Ae.typeParameters || A(Ae).some(ye => ye.type !== \"Identifier\"), Ae.body.type !== \"ArrowFunctionExpression\" || ge && ge.expandLastArg ? ke.unshift(le(\"body\", ge)) : (Ae = Ae.body, z.call(K, \"body\"));\n            }(), Ne.length > 1) return ee(z, ge, Ne, ce, ke, Ae);\n            let pe = Ne;\n            if (pe.push(\" =>\"), !S(U.originalText, Ae.body) && (Ae.body.type === \"ArrayExpression\" || Ae.body.type === \"ObjectExpression\" || Ae.body.type === \"BlockStatement\" || I(Ae.body) || k(Ae.body, U.originalText) || Ae.body.type === \"ArrowFunctionExpression\" || Ae.body.type === \"DoExpression\")) return c([...pe, \" \", ke]);\n            if (Ae.body.type === \"SequenceExpression\") return c([...pe, c([\" (\", v([o, ke]), o, \")\"])]);\n            let de = (ge && ge.expandLastArg || z.getParentNode().type === \"JSXExpressionContainer\") && !F(Ae),\n              ae = ge && ge.expandLastArg && P(U, \"all\"),\n              ve = Ae.body.type === \"ConditionalExpression\" && !C(Ae.body, !1);\n            return c([...pe, c([v([i, ve ? m(\"\", \"(\") : \"\", ke, ve ? m(\"\", \")\") : \"\"]), de ? [m(ae ? \",\" : \"\"), o] : \"\"])]);\n          }\n          function oe(z) {\n            let U = A(z);\n            return U.length === 1 && !z.typeParameters && !F(z, E.Dangling) && U[0].type === \"Identifier\" && !U[0].typeAnnotation && !F(U[0]) && !U[0].optional && !z.predicate && !z.returnType;\n          }\n          function W(z, U) {\n            if (U.arrowParens === \"always\") return !1;\n            if (U.arrowParens === \"avoid\") {\n              let le = z.getValue();\n              return oe(le);\n            }\n            return !1;\n          }\n          function X(z, U, le) {\n            let ge = z.getValue(),\n              Ae = U(\"returnType\");\n            if (ge.returnType && B(le.originalText, ge.returnType)) return [\" /*: \", Ae, \" */\"];\n            let Ne = [Ae];\n            return ge.returnType && ge.returnType.typeAnnotation && Ne.unshift(\": \"), ge.predicate && Ne.push(ge.returnType ? \" \" : \": \", U(\"predicate\")), Ne;\n          }\n          function ue(z, U, le) {\n            let ge = z.getValue(),\n              Ae = U.semi ? \";\" : \"\",\n              Ne = [];\n            ge.argument && (G(U, ge.argument) ? Ne.push([\" (\", v([d, le(\"argument\")]), d, \")\"]) : D(ge.argument) || ge.argument.type === \"SequenceExpression\" ? Ne.push(c([m(\" (\", \" \"), v([o, le(\"argument\")]), o, m(\")\")])) : Ne.push(\" \", le(\"argument\")));\n            let ke = l(ge),\n              ce = r(ke),\n              pe = ce && g(ce);\n            return pe && Ne.push(Ae), F(ge, E.Dangling) && Ne.push(\" \", s(z, U, !0)), pe || Ne.push(Ae), Ne;\n          }\n          function De(z, U, le) {\n            return [\"return\", ue(z, U, le)];\n          }\n          function ie(z, U, le) {\n            return [\"throw\", ue(z, U, le)];\n          }\n          function G(z, U) {\n            if (S(z.originalText, U)) return !0;\n            if (b(U)) {\n              let le = U,\n                ge;\n              for (; ge = L(le);) if (le = ge, S(z.originalText, le)) return !0;\n            }\n            return !1;\n          }\n          n.exports = {\n            printFunction: Y,\n            printArrowFunction: te,\n            printMethod: H,\n            printReturnStatement: De,\n            printThrowStatement: ie,\n            printMethodInternal: R,\n            shouldPrintParamsWithoutParens: W\n          };\n        }\n      }),\n      Un = Z({\n        \"src/language-js/print/decorators.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isNonEmptyArray: t,\n              hasNewline: s\n            } = Ue(),\n            {\n              builders: {\n                line: a,\n                hardline: r,\n                join: u,\n                breakParent: i,\n                group: o\n              }\n            } = Oe(),\n            {\n              locStart: c,\n              locEnd: v\n            } = st(),\n            {\n              getParentExportDeclaration: m\n            } = Ke();\n          function d(T, A, S) {\n            let B = T.getValue();\n            return o([u(a, T.map(S, \"decorators\")), h(B, A) ? r : a]);\n          }\n          function p(T, A, S) {\n            return [u(r, T.map(S, \"declaration\", \"decorators\")), r];\n          }\n          function f(T, A, S) {\n            let B = T.getValue(),\n              {\n                decorators: I\n              } = B;\n            if (!t(I) || w(T.getParentNode())) return;\n            let k = B.type === \"ClassExpression\" || B.type === \"ClassDeclaration\" || h(B, A);\n            return [m(T) ? r : k ? i : \"\", u(a, T.map(S, \"decorators\")), a];\n          }\n          function h(T, A) {\n            return T.decorators.some(S => s(A.originalText, v(S)));\n          }\n          function w(T) {\n            if (T.type !== \"ExportDefaultDeclaration\" && T.type !== \"ExportNamedDeclaration\" && T.type !== \"DeclareExportDeclaration\") return !1;\n            let A = T.declaration && T.declaration.decorators;\n            return t(A) && c(T, {\n              ignoreDecorators: !0\n            }) > c(A[0]);\n          }\n          n.exports = {\n            printDecorators: f,\n            printClassMemberDecorators: d,\n            printDecoratorsBeforeExport: p,\n            hasDecoratorsBeforeExport: w\n          };\n        }\n      }),\n      Zt = Z({\n        \"src/language-js/print/class.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isNonEmptyArray: t,\n              createGroupIdMapper: s\n            } = Ue(),\n            {\n              printComments: a,\n              printDanglingComments: r\n            } = et(),\n            {\n              builders: {\n                join: u,\n                line: i,\n                hardline: o,\n                softline: c,\n                group: v,\n                indent: m,\n                ifBreak: d\n              }\n            } = Oe(),\n            {\n              hasComment: p,\n              CommentCheckFlags: f\n            } = Ke(),\n            {\n              getTypeParametersGroupId: h\n            } = Ir(),\n            {\n              printMethod: w\n            } = Lr(),\n            {\n              printOptionalToken: T,\n              printTypeAnnotation: A,\n              printDefiniteToken: S\n            } = ct(),\n            {\n              printPropertyKey: B\n            } = Qt(),\n            {\n              printAssignment: I\n            } = Yt(),\n            {\n              printClassMemberDecorators: k\n            } = Un();\n          function P(x, b, L) {\n            let M = x.getValue(),\n              j = [];\n            M.declare && j.push(\"declare \"), M.abstract && j.push(\"abstract \"), j.push(\"class\");\n            let $ = M.id && p(M.id, f.Trailing) || M.typeParameters && p(M.typeParameters, f.Trailing) || M.superClass && p(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements),\n              V = [],\n              q = [];\n            if (M.id && V.push(\" \", L(\"id\")), V.push(L(\"typeParameters\")), M.superClass) {\n              let Y = [E(x, b, L), L(\"superTypeParameters\")],\n                H = x.call(R => [\"extends \", a(R, Y, b)], \"superClass\");\n              $ ? q.push(i, v(H)) : q.push(\" \", H);\n            } else q.push(l(x, b, L, \"extends\"));\n            if (q.push(l(x, b, L, \"mixins\"), l(x, b, L, \"implements\")), $) {\n              let Y;\n              F(M) ? Y = [...V, m(q)] : Y = m([...V, q]), j.push(v(Y, {\n                id: C(M)\n              }));\n            } else j.push(...V, ...q);\n            return j.push(\" \", L(\"body\")), j;\n          }\n          var C = s(\"heritageGroup\");\n          function D(x) {\n            return d(o, \"\", {\n              groupId: C(x)\n            });\n          }\n          function g(x) {\n            return [\"superClass\", \"extends\", \"mixins\", \"implements\"].filter(b => Boolean(x[b])).length > 1;\n          }\n          function F(x) {\n            return x.typeParameters && !p(x.typeParameters, f.Trailing | f.Line) && !g(x);\n          }\n          function l(x, b, L, M) {\n            let j = x.getValue();\n            if (!t(j[M])) return \"\";\n            let $ = r(x, b, !0, V => {\n              let {\n                marker: q\n              } = V;\n              return q === M;\n            });\n            return [F(j) ? d(\" \", i, {\n              groupId: h(j.typeParameters)\n            }) : i, $, $ && o, M, v(m([i, u([\",\", i], x.map(L, M))]))];\n          }\n          function E(x, b, L) {\n            let M = L(\"superClass\");\n            return x.getParentNode().type === \"AssignmentExpression\" ? v(d([\"(\", m([c, M]), c, \")\"], M)) : M;\n          }\n          function y(x, b, L) {\n            let M = x.getValue(),\n              j = [];\n            return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + \" \"), M.readonly && j.push(\"readonly \"), M.declare && j.push(\"declare \"), M.static && j.push(\"static \"), (M.type === \"TSAbstractMethodDefinition\" || M.abstract) && j.push(\"abstract \"), M.override && j.push(\"override \"), j.push(w(x, b, L)), j;\n          }\n          function N(x, b, L) {\n            let M = x.getValue(),\n              j = [],\n              $ = b.semi ? \";\" : \"\";\n            return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + \" \"), M.declare && j.push(\"declare \"), M.static && j.push(\"static \"), (M.type === \"TSAbstractPropertyDefinition\" || M.abstract) && j.push(\"abstract \"), M.override && j.push(\"override \"), M.readonly && j.push(\"readonly \"), M.variance && j.push(L(\"variance\")), M.type === \"ClassAccessorProperty\" && j.push(\"accessor \"), j.push(B(x, b, L), T(x), S(x), A(x, b, L)), [I(x, b, L, j, \" =\", \"value\"), $];\n          }\n          n.exports = {\n            printClass: P,\n            printClassMethod: y,\n            printClassProperty: N,\n            printHardlineAfterHeritage: D\n          };\n        }\n      }),\n      lo = Z({\n        \"src/language-js/print/interface.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isNonEmptyArray: t\n            } = Ue(),\n            {\n              builders: {\n                join: s,\n                line: a,\n                group: r,\n                indent: u,\n                ifBreak: i\n              }\n            } = Oe(),\n            {\n              hasComment: o,\n              identity: c,\n              CommentCheckFlags: v\n            } = Ke(),\n            {\n              getTypeParametersGroupId: m\n            } = Ir(),\n            {\n              printTypeScriptModifiers: d\n            } = ct();\n          function p(f, h, w) {\n            let T = f.getValue(),\n              A = [];\n            T.declare && A.push(\"declare \"), T.type === \"TSInterfaceDeclaration\" && A.push(T.abstract ? \"abstract \" : \"\", d(f, h, w)), A.push(\"interface\");\n            let S = [],\n              B = [];\n            T.type !== \"InterfaceTypeAnnotation\" && S.push(\" \", w(\"id\"), w(\"typeParameters\"));\n            let I = T.typeParameters && !o(T.typeParameters, v.Trailing | v.Line);\n            return t(T.extends) && B.push(I ? i(\" \", a, {\n              groupId: m(T.typeParameters)\n            }) : a, \"extends \", (T.extends.length === 1 ? c : u)(s([\",\", a], f.map(w, \"extends\")))), T.id && o(T.id, v.Trailing) || t(T.extends) ? I ? A.push(r([...S, u(B)])) : A.push(r(u([...S, ...B]))) : A.push(...S, ...B), A.push(\" \", w(\"body\")), r(A);\n          }\n          n.exports = {\n            printInterface: p\n          };\n        }\n      }),\n      co = Z({\n        \"src/language-js/print/module.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isNonEmptyArray: t\n            } = Ue(),\n            {\n              builders: {\n                softline: s,\n                group: a,\n                indent: r,\n                join: u,\n                line: i,\n                ifBreak: o,\n                hardline: c\n              }\n            } = Oe(),\n            {\n              printDanglingComments: v\n            } = et(),\n            {\n              hasComment: m,\n              CommentCheckFlags: d,\n              shouldPrintComma: p,\n              needsHardlineAfterDanglingComment: f,\n              isStringLiteral: h,\n              rawText: w\n            } = Ke(),\n            {\n              locStart: T,\n              hasSameLoc: A\n            } = st(),\n            {\n              hasDecoratorsBeforeExport: S,\n              printDecoratorsBeforeExport: B\n            } = Un();\n          function I(N, x, b) {\n            let L = N.getValue(),\n              M = x.semi ? \";\" : \"\",\n              j = [],\n              {\n                importKind: $\n              } = L;\n            return j.push(\"import\"), $ && $ !== \"value\" && j.push(\" \", $), j.push(g(N, x, b), D(N, x, b), l(N, x, b), M), j;\n          }\n          function k(N, x, b) {\n            let L = N.getValue(),\n              M = [];\n            S(L) && M.push(B(N, x, b));\n            let {\n              type: j,\n              exportKind: $,\n              declaration: V\n            } = L;\n            return M.push(\"export\"), (L.default || j === \"ExportDefaultDeclaration\") && M.push(\" default\"), m(L, d.Dangling) && (M.push(\" \", v(N, x, !0)), f(L) && M.push(c)), V ? M.push(\" \", b(\"declaration\")) : M.push($ === \"type\" ? \" type\" : \"\", g(N, x, b), D(N, x, b), l(N, x, b)), C(L, x) && M.push(\";\"), M;\n          }\n          function P(N, x, b) {\n            let L = N.getValue(),\n              M = x.semi ? \";\" : \"\",\n              j = [],\n              {\n                exportKind: $,\n                exported: V\n              } = L;\n            return j.push(\"export\"), $ === \"type\" && j.push(\" type\"), j.push(\" *\"), V && j.push(\" as \", b(\"exported\")), j.push(D(N, x, b), l(N, x, b), M), j;\n          }\n          function C(N, x) {\n            if (!x.semi) return !1;\n            let {\n                type: b,\n                declaration: L\n              } = N,\n              M = N.default || b === \"ExportDefaultDeclaration\";\n            if (!L) return !0;\n            let {\n              type: j\n            } = L;\n            return !!(M && j !== \"ClassDeclaration\" && j !== \"FunctionDeclaration\" && j !== \"TSInterfaceDeclaration\" && j !== \"DeclareClass\" && j !== \"DeclareFunction\" && j !== \"TSDeclareFunction\" && j !== \"EnumDeclaration\");\n          }\n          function D(N, x, b) {\n            let L = N.getValue();\n            if (!L.source) return \"\";\n            let M = [];\n            return F(L, x) || M.push(\" from\"), M.push(\" \", b(\"source\")), M;\n          }\n          function g(N, x, b) {\n            let L = N.getValue();\n            if (F(L, x)) return \"\";\n            let M = [\" \"];\n            if (t(L.specifiers)) {\n              let j = [],\n                $ = [];\n              N.each(() => {\n                let V = N.getValue().type;\n                if (V === \"ExportNamespaceSpecifier\" || V === \"ExportDefaultSpecifier\" || V === \"ImportNamespaceSpecifier\" || V === \"ImportDefaultSpecifier\") j.push(b());else if (V === \"ExportSpecifier\" || V === \"ImportSpecifier\") $.push(b());else throw new Error(\"Unknown specifier type \".concat(JSON.stringify(V)));\n              }, \"specifiers\"), M.push(u(\", \", j)), $.length > 0 && (j.length > 0 && M.push(\", \"), $.length > 1 || j.length > 0 || L.specifiers.some(q => m(q)) ? M.push(a([\"{\", r([x.bracketSpacing ? i : s, u([\",\", i], $)]), o(p(x) ? \",\" : \"\"), x.bracketSpacing ? i : s, \"}\"])) : M.push([\"{\", x.bracketSpacing ? \" \" : \"\", ...$, x.bracketSpacing ? \" \" : \"\", \"}\"]));\n            } else M.push(\"{}\");\n            return M;\n          }\n          function F(N, x) {\n            let {\n              type: b,\n              importKind: L,\n              source: M,\n              specifiers: j\n            } = N;\n            return b !== \"ImportDeclaration\" || t(j) || L === \"type\" ? !1 : !/{\\s*}/.test(x.originalText.slice(T(N), T(M)));\n          }\n          function l(N, x, b) {\n            let L = N.getNode();\n            return t(L.assertions) ? [\" assert {\", x.bracketSpacing ? \" \" : \"\", u(\", \", N.map(b, \"assertions\")), x.bracketSpacing ? \" \" : \"\", \"}\"] : \"\";\n          }\n          function E(N, x, b) {\n            let L = N.getNode(),\n              {\n                type: M\n              } = L,\n              j = [],\n              $ = M === \"ImportSpecifier\" ? L.importKind : L.exportKind;\n            $ && $ !== \"value\" && j.push($, \" \");\n            let V = M.startsWith(\"Import\"),\n              q = V ? \"imported\" : \"local\",\n              Y = V ? \"local\" : \"exported\",\n              H = L[q],\n              R = L[Y],\n              Q = \"\",\n              ee = \"\";\n            return M === \"ExportNamespaceSpecifier\" || M === \"ImportNamespaceSpecifier\" ? Q = \"*\" : H && (Q = b(q)), R && !y(L) && (ee = b(Y)), j.push(Q, Q && ee ? \" as \" : \"\", ee), j;\n          }\n          function y(N) {\n            if (N.type !== \"ImportSpecifier\" && N.type !== \"ExportSpecifier\") return !1;\n            let {\n              local: x,\n              [N.type === \"ImportSpecifier\" ? \"imported\" : \"exported\"]: b\n            } = N;\n            if (x.type !== b.type || !A(x, b)) return !1;\n            if (h(x)) return x.value === b.value && w(x) === w(b);\n            switch (x.type) {\n              case \"Identifier\":\n                return x.name === b.name;\n              default:\n                return !1;\n            }\n          }\n          n.exports = {\n            printImportDeclaration: I,\n            printExportDeclaration: k,\n            printExportAllDeclaration: P,\n            printModuleSpecifier: E\n          };\n        }\n      }),\n      zn = Z({\n        \"src/language-js/print/object.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              builders: {\n                line: s,\n                softline: a,\n                group: r,\n                indent: u,\n                ifBreak: i,\n                hardline: o\n              }\n            } = Oe(),\n            {\n              getLast: c,\n              hasNewlineInRange: v,\n              hasNewline: m,\n              isNonEmptyArray: d\n            } = Ue(),\n            {\n              shouldPrintComma: p,\n              hasComment: f,\n              getComments: h,\n              CommentCheckFlags: w,\n              isNextLineEmpty: T\n            } = Ke(),\n            {\n              locStart: A,\n              locEnd: S\n            } = st(),\n            {\n              printOptionalToken: B,\n              printTypeAnnotation: I\n            } = ct(),\n            {\n              shouldHugFunctionParameters: k\n            } = Pr(),\n            {\n              shouldHugType: P\n            } = kr(),\n            {\n              printHardlineAfterHeritage: C\n            } = Zt();\n          function D(g, F, l) {\n            let E = F.semi ? \";\" : \"\",\n              y = g.getValue(),\n              N;\n            y.type === \"TSTypeLiteral\" ? N = \"members\" : y.type === \"TSInterfaceBody\" ? N = \"body\" : N = \"properties\";\n            let x = y.type === \"ObjectTypeAnnotation\",\n              b = [N];\n            x && b.push(\"indexers\", \"callProperties\", \"internalSlots\");\n            let L = b.map(W => y[W][0]).sort((W, X) => A(W) - A(X))[0],\n              M = g.getParentNode(0),\n              j = x && M && (M.type === \"InterfaceDeclaration\" || M.type === \"DeclareInterface\" || M.type === \"DeclareClass\") && g.getName() === \"body\",\n              $ = y.type === \"TSInterfaceBody\" || j || y.type === \"ObjectPattern\" && M.type !== \"FunctionDeclaration\" && M.type !== \"FunctionExpression\" && M.type !== \"ArrowFunctionExpression\" && M.type !== \"ObjectMethod\" && M.type !== \"ClassMethod\" && M.type !== \"ClassPrivateMethod\" && M.type !== \"AssignmentPattern\" && M.type !== \"CatchClause\" && y.properties.some(W => W.value && (W.value.type === \"ObjectPattern\" || W.value.type === \"ArrayPattern\")) || y.type !== \"ObjectPattern\" && L && v(F.originalText, A(y), A(L)),\n              V = j ? \";\" : y.type === \"TSInterfaceBody\" || y.type === \"TSTypeLiteral\" ? i(E, \";\") : \",\",\n              q = y.type === \"RecordExpression\" ? \"#{\" : y.exact ? \"{|\" : \"{\",\n              Y = y.exact ? \"|}\" : \"}\",\n              H = [];\n            for (let W of b) g.each(X => {\n              let ue = X.getValue();\n              H.push({\n                node: ue,\n                printed: l(),\n                loc: A(ue)\n              });\n            }, W);\n            b.length > 1 && H.sort((W, X) => W.loc - X.loc);\n            let R = [],\n              Q = H.map(W => {\n                let X = [...R, r(W.printed)];\n                return R = [V, s], (W.node.type === \"TSPropertySignature\" || W.node.type === \"TSMethodSignature\" || W.node.type === \"TSConstructSignatureDeclaration\") && f(W.node, w.PrettierIgnore) && R.shift(), T(W.node, F) && R.push(o), X;\n              });\n            if (y.inexact) {\n              let W;\n              if (f(y, w.Dangling)) {\n                let X = f(y, w.Line);\n                W = [t(g, F, !0), X || m(F.originalText, S(c(h(y)))) ? o : s, \"...\"];\n              } else W = [\"...\"];\n              Q.push([...R, ...W]);\n            }\n            let ee = c(y[N]),\n              te = !(y.inexact || ee && ee.type === \"RestElement\" || ee && (ee.type === \"TSPropertySignature\" || ee.type === \"TSCallSignatureDeclaration\" || ee.type === \"TSMethodSignature\" || ee.type === \"TSConstructSignatureDeclaration\") && f(ee, w.PrettierIgnore)),\n              oe;\n            if (Q.length === 0) {\n              if (!f(y, w.Dangling)) return [q, Y, I(g, F, l)];\n              oe = r([q, t(g, F), a, Y, B(g), I(g, F, l)]);\n            } else oe = [j && d(y.properties) ? C(M) : \"\", q, u([F.bracketSpacing ? s : a, ...Q]), i(te && (V !== \",\" || p(F)) ? V : \"\"), F.bracketSpacing ? s : a, Y, B(g), I(g, F, l)];\n            return g.match(W => W.type === \"ObjectPattern\" && !W.decorators, (W, X, ue) => k(W) && (X === \"params\" || X === \"parameters\" || X === \"this\" || X === \"rest\") && ue === 0) || g.match(P, (W, X) => X === \"typeAnnotation\", (W, X) => X === \"typeAnnotation\", (W, X, ue) => k(W) && (X === \"params\" || X === \"parameters\" || X === \"this\" || X === \"rest\") && ue === 0) || !$ && g.match(W => W.type === \"ObjectPattern\", W => W.type === \"AssignmentExpression\" || W.type === \"VariableDeclarator\") ? oe : r(oe, {\n              shouldBreak: $\n            });\n          }\n          n.exports = {\n            printObject: D\n          };\n        }\n      }),\n      Um = Z({\n        \"src/language-js/print/flow.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Xt(),\n            {\n              printDanglingComments: s\n            } = et(),\n            {\n              printString: a,\n              printNumber: r\n            } = Ue(),\n            {\n              builders: {\n                hardline: u,\n                softline: i,\n                group: o,\n                indent: c\n              }\n            } = Oe(),\n            {\n              getParentExportDeclaration: v,\n              isFunctionNotation: m,\n              isGetterOrSetter: d,\n              rawText: p,\n              shouldPrintComma: f\n            } = Ke(),\n            {\n              locStart: h,\n              locEnd: w\n            } = st(),\n            {\n              printClass: T\n            } = Zt(),\n            {\n              printOpaqueType: A,\n              printTypeAlias: S,\n              printIntersectionType: B,\n              printUnionType: I,\n              printFunctionType: k,\n              printTupleType: P,\n              printIndexedAccessType: C\n            } = kr(),\n            {\n              printInterface: D\n            } = lo(),\n            {\n              printTypeParameter: g,\n              printTypeParameters: F\n            } = Ir(),\n            {\n              printExportDeclaration: l,\n              printExportAllDeclaration: E\n            } = co(),\n            {\n              printArrayItems: y\n            } = Kt(),\n            {\n              printObject: N\n            } = zn(),\n            {\n              printPropertyKey: x\n            } = Qt(),\n            {\n              printOptionalToken: b,\n              printTypeAnnotation: L,\n              printRestSpread: M\n            } = ct();\n          function j(V, q, Y) {\n            let H = V.getValue(),\n              R = q.semi ? \";\" : \"\",\n              Q = [];\n            switch (H.type) {\n              case \"DeclareClass\":\n                return $(V, T(V, q, Y));\n              case \"DeclareFunction\":\n                return $(V, [\"function \", Y(\"id\"), H.predicate ? \" \" : \"\", Y(\"predicate\"), R]);\n              case \"DeclareModule\":\n                return $(V, [\"module \", Y(\"id\"), \" \", Y(\"body\")]);\n              case \"DeclareModuleExports\":\n                return $(V, [\"module.exports\", \": \", Y(\"typeAnnotation\"), R]);\n              case \"DeclareVariable\":\n                return $(V, [\"var \", Y(\"id\"), R]);\n              case \"DeclareOpaqueType\":\n                return $(V, A(V, q, Y));\n              case \"DeclareInterface\":\n                return $(V, D(V, q, Y));\n              case \"DeclareTypeAlias\":\n                return $(V, S(V, q, Y));\n              case \"DeclareExportDeclaration\":\n                return $(V, l(V, q, Y));\n              case \"DeclareExportAllDeclaration\":\n                return $(V, E(V, q, Y));\n              case \"OpaqueType\":\n                return A(V, q, Y);\n              case \"TypeAlias\":\n                return S(V, q, Y);\n              case \"IntersectionTypeAnnotation\":\n                return B(V, q, Y);\n              case \"UnionTypeAnnotation\":\n                return I(V, q, Y);\n              case \"FunctionTypeAnnotation\":\n                return k(V, q, Y);\n              case \"TupleTypeAnnotation\":\n                return P(V, q, Y);\n              case \"GenericTypeAnnotation\":\n                return [Y(\"id\"), F(V, q, Y, \"typeParameters\")];\n              case \"IndexedAccessType\":\n              case \"OptionalIndexedAccessType\":\n                return C(V, q, Y);\n              case \"TypeAnnotation\":\n                return Y(\"typeAnnotation\");\n              case \"TypeParameter\":\n                return g(V, q, Y);\n              case \"TypeofTypeAnnotation\":\n                return [\"typeof \", Y(\"argument\")];\n              case \"ExistsTypeAnnotation\":\n                return \"*\";\n              case \"EmptyTypeAnnotation\":\n                return \"empty\";\n              case \"MixedTypeAnnotation\":\n                return \"mixed\";\n              case \"ArrayTypeAnnotation\":\n                return [Y(\"elementType\"), \"[]\"];\n              case \"BooleanLiteralTypeAnnotation\":\n                return String(H.value);\n              case \"EnumDeclaration\":\n                return [\"enum \", Y(\"id\"), \" \", Y(\"body\")];\n              case \"EnumBooleanBody\":\n              case \"EnumNumberBody\":\n              case \"EnumStringBody\":\n              case \"EnumSymbolBody\":\n                {\n                  if (H.type === \"EnumSymbolBody\" || H.explicitType) {\n                    let ee = null;\n                    switch (H.type) {\n                      case \"EnumBooleanBody\":\n                        ee = \"boolean\";\n                        break;\n                      case \"EnumNumberBody\":\n                        ee = \"number\";\n                        break;\n                      case \"EnumStringBody\":\n                        ee = \"string\";\n                        break;\n                      case \"EnumSymbolBody\":\n                        ee = \"symbol\";\n                        break;\n                    }\n                    Q.push(\"of \", ee, \" \");\n                  }\n                  if (H.members.length === 0 && !H.hasUnknownMembers) Q.push(o([\"{\", s(V, q), i, \"}\"]));else {\n                    let ee = H.members.length > 0 ? [u, y(V, q, \"members\", Y), H.hasUnknownMembers || f(q) ? \",\" : \"\"] : [];\n                    Q.push(o([\"{\", c([...ee, ...(H.hasUnknownMembers ? [u, \"...\"] : [])]), s(V, q, !0), u, \"}\"]));\n                  }\n                  return Q;\n                }\n              case \"EnumBooleanMember\":\n              case \"EnumNumberMember\":\n              case \"EnumStringMember\":\n                return [Y(\"id\"), \" = \", typeof H.init == \"object\" ? Y(\"init\") : String(H.init)];\n              case \"EnumDefaultedMember\":\n                return Y(\"id\");\n              case \"FunctionTypeParam\":\n                {\n                  let ee = H.name ? Y(\"name\") : V.getParentNode().this === H ? \"this\" : \"\";\n                  return [ee, b(V), ee ? \": \" : \"\", Y(\"typeAnnotation\")];\n                }\n              case \"InterfaceDeclaration\":\n              case \"InterfaceTypeAnnotation\":\n                return D(V, q, Y);\n              case \"ClassImplements\":\n              case \"InterfaceExtends\":\n                return [Y(\"id\"), Y(\"typeParameters\")];\n              case \"NullableTypeAnnotation\":\n                return [\"?\", Y(\"typeAnnotation\")];\n              case \"Variance\":\n                {\n                  let {\n                    kind: ee\n                  } = H;\n                  return t.ok(ee === \"plus\" || ee === \"minus\"), ee === \"plus\" ? \"+\" : \"-\";\n                }\n              case \"ObjectTypeCallProperty\":\n                return H.static && Q.push(\"static \"), Q.push(Y(\"value\")), Q;\n              case \"ObjectTypeIndexer\":\n                return [H.static ? \"static \" : \"\", H.variance ? Y(\"variance\") : \"\", \"[\", Y(\"id\"), H.id ? \": \" : \"\", Y(\"key\"), \"]: \", Y(\"value\")];\n              case \"ObjectTypeProperty\":\n                {\n                  let ee = \"\";\n                  return H.proto ? ee = \"proto \" : H.static && (ee = \"static \"), [ee, d(H) ? H.kind + \" \" : \"\", H.variance ? Y(\"variance\") : \"\", x(V, q, Y), b(V), m(H) ? \"\" : \": \", Y(\"value\")];\n                }\n              case \"ObjectTypeAnnotation\":\n                return N(V, q, Y);\n              case \"ObjectTypeInternalSlot\":\n                return [H.static ? \"static \" : \"\", \"[[\", Y(\"id\"), \"]]\", b(V), H.method ? \"\" : \": \", Y(\"value\")];\n              case \"ObjectTypeSpreadProperty\":\n                return M(V, q, Y);\n              case \"QualifiedTypeofIdentifier\":\n              case \"QualifiedTypeIdentifier\":\n                return [Y(\"qualification\"), \".\", Y(\"id\")];\n              case \"StringLiteralTypeAnnotation\":\n                return a(p(H), q);\n              case \"NumberLiteralTypeAnnotation\":\n                t.strictEqual(typeof H.value, \"number\");\n              case \"BigIntLiteralTypeAnnotation\":\n                return H.extra ? r(H.extra.raw) : r(H.raw);\n              case \"TypeCastExpression\":\n                return [\"(\", Y(\"expression\"), L(V, q, Y), \")\"];\n              case \"TypeParameterDeclaration\":\n              case \"TypeParameterInstantiation\":\n                {\n                  let ee = F(V, q, Y, \"params\");\n                  if (q.parser === \"flow\") {\n                    let te = h(H),\n                      oe = w(H),\n                      W = q.originalText.lastIndexOf(\"/*\", te),\n                      X = q.originalText.indexOf(\"*/\", oe);\n                    if (W !== -1 && X !== -1) {\n                      let ue = q.originalText.slice(W + 2, X).trim();\n                      if (ue.startsWith(\"::\") && !ue.includes(\"/*\") && !ue.includes(\"*/\")) return [\"/*:: \", ee, \" */\"];\n                    }\n                  }\n                  return ee;\n                }\n              case \"InferredPredicate\":\n                return \"%checks\";\n              case \"DeclaredPredicate\":\n                return [\"%checks(\", Y(\"value\"), \")\"];\n              case \"AnyTypeAnnotation\":\n                return \"any\";\n              case \"BooleanTypeAnnotation\":\n                return \"boolean\";\n              case \"BigIntTypeAnnotation\":\n                return \"bigint\";\n              case \"NullLiteralTypeAnnotation\":\n                return \"null\";\n              case \"NumberTypeAnnotation\":\n                return \"number\";\n              case \"SymbolTypeAnnotation\":\n                return \"symbol\";\n              case \"StringTypeAnnotation\":\n                return \"string\";\n              case \"VoidTypeAnnotation\":\n                return \"void\";\n              case \"ThisTypeAnnotation\":\n                return \"this\";\n              case \"Node\":\n              case \"Printable\":\n              case \"SourceLocation\":\n              case \"Position\":\n              case \"Statement\":\n              case \"Function\":\n              case \"Pattern\":\n              case \"Expression\":\n              case \"Declaration\":\n              case \"Specifier\":\n              case \"NamedSpecifier\":\n              case \"Comment\":\n              case \"MemberTypeAnnotation\":\n              case \"Type\":\n                throw new Error(\"unprintable type: \" + JSON.stringify(H.type));\n            }\n          }\n          function $(V, q) {\n            let Y = v(V);\n            return Y ? (t.strictEqual(Y.type, \"DeclareExportDeclaration\"), q) : [\"declare \", q];\n          }\n          n.exports = {\n            printFlow: j\n          };\n        }\n      }),\n      zm = Z({\n        \"src/language-js/utils/is-ts-keyword-type.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s) {\n            let {\n              type: a\n            } = s;\n            return a.startsWith(\"TS\") && a.endsWith(\"Keyword\");\n          }\n          n.exports = t;\n        }\n      }),\n      po = Z({\n        \"src/language-js/print/ternary.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              hasNewlineInRange: t\n            } = Ue(),\n            {\n              isJsxNode: s,\n              getComments: a,\n              isCallExpression: r,\n              isMemberExpression: u\n            } = Ke(),\n            {\n              locStart: i,\n              locEnd: o\n            } = st(),\n            c = It(),\n            {\n              builders: {\n                line: v,\n                softline: m,\n                group: d,\n                indent: p,\n                align: f,\n                ifBreak: h,\n                dedent: w,\n                breakParent: T\n              }\n            } = Oe();\n          function A(P) {\n            let C = [P];\n            for (let D = 0; D < C.length; D++) {\n              let g = C[D];\n              for (let F of [\"test\", \"consequent\", \"alternate\"]) {\n                let l = g[F];\n                if (s(l)) return !0;\n                l.type === \"ConditionalExpression\" && C.push(l);\n              }\n            }\n            return !1;\n          }\n          function S(P, C, D) {\n            let g = P.getValue(),\n              F = g.type === \"ConditionalExpression\",\n              l = F ? \"alternate\" : \"falseType\",\n              E = P.getParentNode(),\n              y = F ? D(\"test\") : [D(\"checkType\"), \" \", \"extends\", \" \", D(\"extendsType\")];\n            return E.type === g.type && E[l] === g ? f(2, y) : y;\n          }\n          var B = new Map([[\"AssignmentExpression\", \"right\"], [\"VariableDeclarator\", \"init\"], [\"ReturnStatement\", \"argument\"], [\"ThrowStatement\", \"argument\"], [\"UnaryExpression\", \"argument\"], [\"YieldExpression\", \"argument\"]]);\n          function I(P) {\n            let C = P.getValue();\n            if (C.type !== \"ConditionalExpression\") return !1;\n            let D,\n              g = C;\n            for (let F = 0; !D; F++) {\n              let l = P.getParentNode(F);\n              if (r(l) && l.callee === g || u(l) && l.object === g || l.type === \"TSNonNullExpression\" && l.expression === g) {\n                g = l;\n                continue;\n              }\n              l.type === \"NewExpression\" && l.callee === g || l.type === \"TSAsExpression\" && l.expression === g ? (D = P.getParentNode(F + 1), g = l) : D = l;\n            }\n            return g === C ? !1 : D[B.get(D.type)] === g;\n          }\n          function k(P, C, D) {\n            let g = P.getValue(),\n              F = g.type === \"ConditionalExpression\",\n              l = F ? \"consequent\" : \"trueType\",\n              E = F ? \"alternate\" : \"falseType\",\n              y = F ? [\"test\"] : [\"checkType\", \"extendsType\"],\n              N = g[l],\n              x = g[E],\n              b = [],\n              L = !1,\n              M = P.getParentNode(),\n              j = M.type === g.type && y.some(ue => M[ue] === g),\n              $ = M.type === g.type && !j,\n              V,\n              q,\n              Y = 0;\n            do q = V || g, V = P.getParentNode(Y), Y++; while (V && V.type === g.type && y.every(ue => V[ue] !== q));\n            let H = V || M,\n              R = q;\n            if (F && (s(g[y[0]]) || s(N) || s(x) || A(R))) {\n              L = !0, $ = !0;\n              let ue = ie => [h(\"(\"), p([m, ie]), m, h(\")\")],\n                De = ie => ie.type === \"NullLiteral\" || ie.type === \"Literal\" && ie.value === null || ie.type === \"Identifier\" && ie.name === \"undefined\";\n              b.push(\" ? \", De(N) ? D(l) : ue(D(l)), \" : \", x.type === g.type || De(x) ? D(E) : ue(D(E)));\n            } else {\n              let ue = [v, \"? \", N.type === g.type ? h(\"\", \"(\") : \"\", f(2, D(l)), N.type === g.type ? h(\"\", \")\") : \"\", v, \": \", x.type === g.type ? D(E) : f(2, D(E))];\n              b.push(M.type !== g.type || M[E] === g || j ? ue : C.useTabs ? w(p(ue)) : f(Math.max(0, C.tabWidth - 2), ue));\n            }\n            let ee = [...y.map(ue => a(g[ue])), a(N), a(x)].flat().some(ue => c(ue) && t(C.originalText, i(ue), o(ue))),\n              te = ue => M === H ? d(ue, {\n                shouldBreak: ee\n              }) : ee ? [ue, T] : ue,\n              oe = !L && (u(M) || M.type === \"NGPipeExpression\" && M.left === g) && !M.computed,\n              W = I(P),\n              X = te([S(P, C, D), $ ? b : p(b), F && oe && !W ? m : \"\"]);\n            return j || W ? d([p([m, X]), m]) : X;\n          }\n          n.exports = {\n            printTernary: k\n          };\n        }\n      }),\n      fo = Z({\n        \"src/language-js/print/statement.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                hardline: t\n              }\n            } = Oe(),\n            s = jt(),\n            {\n              getLeftSidePathName: a,\n              hasNakedLeftSide: r,\n              isJsxNode: u,\n              isTheOnlyJsxElementInMarkdown: i,\n              hasComment: o,\n              CommentCheckFlags: c,\n              isNextLineEmpty: v\n            } = Ke(),\n            {\n              shouldPrintParamsWithoutParens: m\n            } = Lr();\n          function d(B, I, k, P) {\n            let C = B.getValue(),\n              D = [],\n              g = C.type === \"ClassBody\",\n              F = p(C[P]);\n            return B.each((l, E, y) => {\n              let N = l.getValue();\n              if (N.type === \"EmptyStatement\") return;\n              let x = k();\n              !I.semi && !g && !i(I, l) && f(l, I) ? o(N, c.Leading) ? D.push(k([], {\n                needsSemi: !0\n              })) : D.push(\";\", x) : D.push(x), !I.semi && g && A(N) && S(N, y[E + 1]) && D.push(\";\"), N !== F && (D.push(t), v(N, I) && D.push(t));\n            }, P), D;\n          }\n          function p(B) {\n            for (let I = B.length - 1; I >= 0; I--) {\n              let k = B[I];\n              if (k.type !== \"EmptyStatement\") return k;\n            }\n          }\n          function f(B, I) {\n            return B.getNode().type !== \"ExpressionStatement\" ? !1 : B.call(P => h(P, I), \"expression\");\n          }\n          function h(B, I) {\n            let k = B.getValue();\n            switch (k.type) {\n              case \"ParenthesizedExpression\":\n              case \"TypeCastExpression\":\n              case \"ArrayExpression\":\n              case \"ArrayPattern\":\n              case \"TemplateLiteral\":\n              case \"TemplateElement\":\n              case \"RegExpLiteral\":\n                return !0;\n              case \"ArrowFunctionExpression\":\n                {\n                  if (!m(B, I)) return !0;\n                  break;\n                }\n              case \"UnaryExpression\":\n                {\n                  let {\n                    prefix: P,\n                    operator: C\n                  } = k;\n                  if (P && (C === \"+\" || C === \"-\")) return !0;\n                  break;\n                }\n              case \"BindExpression\":\n                {\n                  if (!k.object) return !0;\n                  break;\n                }\n              case \"Literal\":\n                {\n                  if (k.regex) return !0;\n                  break;\n                }\n              default:\n                if (u(k)) return !0;\n            }\n            return s(B, I) ? !0 : r(k) ? B.call(P => h(P, I), ...a(B, k)) : !1;\n          }\n          function w(B, I, k) {\n            return d(B, I, k, \"body\");\n          }\n          function T(B, I, k) {\n            return d(B, I, k, \"consequent\");\n          }\n          var A = B => {\n            let {\n              type: I\n            } = B;\n            return I === \"ClassProperty\" || I === \"PropertyDefinition\" || I === \"ClassPrivateProperty\" || I === \"ClassAccessorProperty\";\n          };\n          function S(B, I) {\n            let k = B.key && B.key.name;\n            if ((k === \"static\" || k === \"get\" || k === \"set\") && !B.value && !B.typeAnnotation) return !0;\n            if (!I || I.static || I.accessibility) return !1;\n            if (!I.computed) {\n              let P = I.key && I.key.name;\n              if (P === \"in\" || P === \"instanceof\") return !0;\n            }\n            if (A(I) && I.variance && !I.static && !I.declare) return !0;\n            switch (I.type) {\n              case \"ClassProperty\":\n              case \"PropertyDefinition\":\n              case \"TSAbstractPropertyDefinition\":\n                return I.computed;\n              case \"MethodDefinition\":\n              case \"TSAbstractMethodDefinition\":\n              case \"ClassMethod\":\n              case \"ClassPrivateMethod\":\n                {\n                  if ((I.value ? I.value.async : I.async) || I.kind === \"get\" || I.kind === \"set\") return !1;\n                  let C = I.value ? I.value.generator : I.generator;\n                  return !!(I.computed || C);\n                }\n              case \"TSIndexSignature\":\n                return !0;\n            }\n            return !1;\n          }\n          n.exports = {\n            printBody: w,\n            printSwitchCaseConsequent: T\n          };\n        }\n      }),\n      Do = Z({\n        \"src/language-js/print/block.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              isNonEmptyArray: s\n            } = Ue(),\n            {\n              builders: {\n                hardline: a,\n                indent: r\n              }\n            } = Oe(),\n            {\n              hasComment: u,\n              CommentCheckFlags: i,\n              isNextLineEmpty: o\n            } = Ke(),\n            {\n              printHardlineAfterHeritage: c\n            } = Zt(),\n            {\n              printBody: v\n            } = fo();\n          function m(p, f, h) {\n            let w = p.getValue(),\n              T = [];\n            if (w.type === \"StaticBlock\" && T.push(\"static \"), w.type === \"ClassBody\" && s(w.body)) {\n              let S = p.getParentNode();\n              T.push(c(S));\n            }\n            T.push(\"{\");\n            let A = d(p, f, h);\n            if (A) T.push(r([a, A]), a);else {\n              let S = p.getParentNode(),\n                B = p.getParentNode(1);\n              S.type === \"ArrowFunctionExpression\" || S.type === \"FunctionExpression\" || S.type === \"FunctionDeclaration\" || S.type === \"ObjectMethod\" || S.type === \"ClassMethod\" || S.type === \"ClassPrivateMethod\" || S.type === \"ForStatement\" || S.type === \"WhileStatement\" || S.type === \"DoWhileStatement\" || S.type === \"DoExpression\" || S.type === \"CatchClause\" && !B.finalizer || S.type === \"TSModuleDeclaration\" || S.type === \"TSDeclareFunction\" || w.type === \"StaticBlock\" || w.type === \"ClassBody\" || T.push(a);\n            }\n            return T.push(\"}\"), T;\n          }\n          function d(p, f, h) {\n            let w = p.getValue(),\n              T = s(w.directives),\n              A = w.body.some(I => I.type !== \"EmptyStatement\"),\n              S = u(w, i.Dangling);\n            if (!T && !A && !S) return \"\";\n            let B = [];\n            if (T && p.each((I, k, P) => {\n              B.push(h()), (k < P.length - 1 || A || S) && (B.push(a), o(I.getValue(), f) && B.push(a));\n            }, \"directives\"), A && B.push(v(p, f, h)), S && B.push(t(p, f, !0)), w.type === \"Program\") {\n              let I = p.getParentNode();\n              (!I || I.type !== \"ModuleExpression\") && B.push(a);\n            }\n            return B;\n          }\n          n.exports = {\n            printBlock: m,\n            printBlockBody: d\n          };\n        }\n      }),\n      Xm = Z({\n        \"src/language-js/print/typescript.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              hasNewlineInRange: s\n            } = Ue(),\n            {\n              builders: {\n                join: a,\n                line: r,\n                hardline: u,\n                softline: i,\n                group: o,\n                indent: c,\n                conditionalGroup: v,\n                ifBreak: m\n              }\n            } = Oe(),\n            {\n              isLiteral: d,\n              getTypeScriptMappedTypeModifier: p,\n              shouldPrintComma: f,\n              isCallExpression: h,\n              isMemberExpression: w\n            } = Ke(),\n            T = zm(),\n            {\n              locStart: A,\n              locEnd: S\n            } = st(),\n            {\n              printOptionalToken: B,\n              printTypeScriptModifiers: I\n            } = ct(),\n            {\n              printTernary: k\n            } = po(),\n            {\n              printFunctionParameters: P,\n              shouldGroupFunctionParameters: C\n            } = Pr(),\n            {\n              printTemplateLiteral: D\n            } = Lt(),\n            {\n              printArrayItems: g\n            } = Kt(),\n            {\n              printObject: F\n            } = zn(),\n            {\n              printClassProperty: l,\n              printClassMethod: E\n            } = Zt(),\n            {\n              printTypeParameter: y,\n              printTypeParameters: N\n            } = Ir(),\n            {\n              printPropertyKey: x\n            } = Qt(),\n            {\n              printFunction: b,\n              printMethodInternal: L\n            } = Lr(),\n            {\n              printInterface: M\n            } = lo(),\n            {\n              printBlock: j\n            } = Do(),\n            {\n              printTypeAlias: $,\n              printIntersectionType: V,\n              printUnionType: q,\n              printFunctionType: Y,\n              printTupleType: H,\n              printIndexedAccessType: R,\n              printJSDocType: Q\n            } = kr();\n          function ee(te, oe, W) {\n            let X = te.getValue();\n            if (!X.type.startsWith(\"TS\")) return;\n            if (T(X)) return X.type.slice(2, -7).toLowerCase();\n            let ue = oe.semi ? \";\" : \"\",\n              De = [];\n            switch (X.type) {\n              case \"TSThisType\":\n                return \"this\";\n              case \"TSTypeAssertion\":\n                {\n                  let ie = !(X.expression.type === \"ArrayExpression\" || X.expression.type === \"ObjectExpression\"),\n                    G = o([\"<\", c([i, W(\"typeAnnotation\")]), i, \">\"]),\n                    z = [m(\"(\"), c([i, W(\"expression\")]), i, m(\")\")];\n                  return ie ? v([[G, W(\"expression\")], [G, o(z, {\n                    shouldBreak: !0\n                  })], [G, W(\"expression\")]]) : o([G, W(\"expression\")]);\n                }\n              case \"TSDeclareFunction\":\n                return b(te, W, oe);\n              case \"TSExportAssignment\":\n                return [\"export = \", W(\"expression\"), ue];\n              case \"TSModuleBlock\":\n                return j(te, oe, W);\n              case \"TSInterfaceBody\":\n              case \"TSTypeLiteral\":\n                return F(te, oe, W);\n              case \"TSTypeAliasDeclaration\":\n                return $(te, oe, W);\n              case \"TSQualifiedName\":\n                return a(\".\", [W(\"left\"), W(\"right\")]);\n              case \"TSAbstractMethodDefinition\":\n              case \"TSDeclareMethod\":\n                return E(te, oe, W);\n              case \"TSAbstractPropertyDefinition\":\n                return l(te, oe, W);\n              case \"TSInterfaceHeritage\":\n              case \"TSExpressionWithTypeArguments\":\n                return De.push(W(\"expression\")), X.typeParameters && De.push(W(\"typeParameters\")), De;\n              case \"TSTemplateLiteralType\":\n                return D(te, W, oe);\n              case \"TSNamedTupleMember\":\n                return [W(\"label\"), X.optional ? \"?\" : \"\", \": \", W(\"elementType\")];\n              case \"TSRestType\":\n                return [\"...\", W(\"typeAnnotation\")];\n              case \"TSOptionalType\":\n                return [W(\"typeAnnotation\"), \"?\"];\n              case \"TSInterfaceDeclaration\":\n                return M(te, oe, W);\n              case \"TSClassImplements\":\n                return [W(\"expression\"), W(\"typeParameters\")];\n              case \"TSTypeParameterDeclaration\":\n              case \"TSTypeParameterInstantiation\":\n                return N(te, oe, W, \"params\");\n              case \"TSTypeParameter\":\n                return y(te, oe, W);\n              case \"TSAsExpression\":\n                {\n                  De.push(W(\"expression\"), \" as \", W(\"typeAnnotation\"));\n                  let ie = te.getParentNode();\n                  return h(ie) && ie.callee === X || w(ie) && ie.object === X ? o([c([i, ...De]), i]) : De;\n                }\n              case \"TSArrayType\":\n                return [W(\"elementType\"), \"[]\"];\n              case \"TSPropertySignature\":\n                return X.readonly && De.push(\"readonly \"), De.push(x(te, oe, W), B(te)), X.typeAnnotation && De.push(\": \", W(\"typeAnnotation\")), X.initializer && De.push(\" = \", W(\"initializer\")), De;\n              case \"TSParameterProperty\":\n                return X.accessibility && De.push(X.accessibility + \" \"), X.export && De.push(\"export \"), X.static && De.push(\"static \"), X.override && De.push(\"override \"), X.readonly && De.push(\"readonly \"), De.push(W(\"parameter\")), De;\n              case \"TSTypeQuery\":\n                return [\"typeof \", W(\"exprName\"), W(\"typeParameters\")];\n              case \"TSIndexSignature\":\n                {\n                  let ie = te.getParentNode(),\n                    G = X.parameters.length > 1 ? m(f(oe) ? \",\" : \"\") : \"\",\n                    z = o([c([i, a([\", \", i], te.map(W, \"parameters\"))]), G, i]);\n                  return [X.export ? \"export \" : \"\", X.accessibility ? [X.accessibility, \" \"] : \"\", X.static ? \"static \" : \"\", X.readonly ? \"readonly \" : \"\", X.declare ? \"declare \" : \"\", \"[\", X.parameters ? z : \"\", X.typeAnnotation ? \"]: \" : \"]\", X.typeAnnotation ? W(\"typeAnnotation\") : \"\", ie.type === \"ClassBody\" ? ue : \"\"];\n                }\n              case \"TSTypePredicate\":\n                return [X.asserts ? \"asserts \" : \"\", W(\"parameterName\"), X.typeAnnotation ? [\" is \", W(\"typeAnnotation\")] : \"\"];\n              case \"TSNonNullExpression\":\n                return [W(\"expression\"), \"!\"];\n              case \"TSImportType\":\n                return [X.isTypeOf ? \"typeof \" : \"\", \"import(\", W(X.parameter ? \"parameter\" : \"argument\"), \")\", X.qualifier ? [\".\", W(\"qualifier\")] : \"\", N(te, oe, W, \"typeParameters\")];\n              case \"TSLiteralType\":\n                return W(\"literal\");\n              case \"TSIndexedAccessType\":\n                return R(te, oe, W);\n              case \"TSConstructSignatureDeclaration\":\n              case \"TSCallSignatureDeclaration\":\n              case \"TSConstructorType\":\n                {\n                  if (X.type === \"TSConstructorType\" && X.abstract && De.push(\"abstract \"), X.type !== \"TSCallSignatureDeclaration\" && De.push(\"new \"), De.push(o(P(te, W, oe, !1, !0))), X.returnType || X.typeAnnotation) {\n                    let ie = X.type === \"TSConstructorType\";\n                    De.push(ie ? \" => \" : \": \", W(\"returnType\"), W(\"typeAnnotation\"));\n                  }\n                  return De;\n                }\n              case \"TSTypeOperator\":\n                return [X.operator, \" \", W(\"typeAnnotation\")];\n              case \"TSMappedType\":\n                {\n                  let ie = s(oe.originalText, A(X), S(X));\n                  return o([\"{\", c([oe.bracketSpacing ? r : i, X.readonly ? [p(X.readonly, \"readonly\"), \" \"] : \"\", I(te, oe, W), W(\"typeParameter\"), X.optional ? p(X.optional, \"?\") : \"\", X.typeAnnotation ? \": \" : \"\", W(\"typeAnnotation\"), m(ue)]), t(te, oe, !0), oe.bracketSpacing ? r : i, \"}\"], {\n                    shouldBreak: ie\n                  });\n                }\n              case \"TSMethodSignature\":\n                {\n                  let ie = X.kind && X.kind !== \"method\" ? \"\".concat(X.kind, \" \") : \"\";\n                  De.push(X.accessibility ? [X.accessibility, \" \"] : \"\", ie, X.export ? \"export \" : \"\", X.static ? \"static \" : \"\", X.readonly ? \"readonly \" : \"\", X.abstract ? \"abstract \" : \"\", X.declare ? \"declare \" : \"\", X.computed ? \"[\" : \"\", W(\"key\"), X.computed ? \"]\" : \"\", B(te));\n                  let G = P(te, W, oe, !1, !0),\n                    z = X.returnType ? \"returnType\" : \"typeAnnotation\",\n                    U = X[z],\n                    le = U ? W(z) : \"\",\n                    ge = C(X, le);\n                  return De.push(ge ? o(G) : G), U && De.push(\": \", o(le)), o(De);\n                }\n              case \"TSNamespaceExportDeclaration\":\n                return De.push(\"export as namespace \", W(\"id\")), oe.semi && De.push(\";\"), o(De);\n              case \"TSEnumDeclaration\":\n                return X.declare && De.push(\"declare \"), X.modifiers && De.push(I(te, oe, W)), X.const && De.push(\"const \"), De.push(\"enum \", W(\"id\"), \" \"), X.members.length === 0 ? De.push(o([\"{\", t(te, oe), i, \"}\"])) : De.push(o([\"{\", c([u, g(te, oe, \"members\", W), f(oe, \"es5\") ? \",\" : \"\"]), t(te, oe, !0), u, \"}\"])), De;\n              case \"TSEnumMember\":\n                return X.computed ? De.push(\"[\", W(\"id\"), \"]\") : De.push(W(\"id\")), X.initializer && De.push(\" = \", W(\"initializer\")), De;\n              case \"TSImportEqualsDeclaration\":\n                return X.isExport && De.push(\"export \"), De.push(\"import \"), X.importKind && X.importKind !== \"value\" && De.push(X.importKind, \" \"), De.push(W(\"id\"), \" = \", W(\"moduleReference\")), oe.semi && De.push(\";\"), o(De);\n              case \"TSExternalModuleReference\":\n                return [\"require(\", W(\"expression\"), \")\"];\n              case \"TSModuleDeclaration\":\n                {\n                  let ie = te.getParentNode(),\n                    G = d(X.id),\n                    z = ie.type === \"TSModuleDeclaration\",\n                    U = X.body && X.body.type === \"TSModuleDeclaration\";\n                  if (z) De.push(\".\");else {\n                    X.declare && De.push(\"declare \"), De.push(I(te, oe, W));\n                    let le = oe.originalText.slice(A(X), A(X.id));\n                    X.id.type === \"Identifier\" && X.id.name === \"global\" && !/namespace|module/.test(le) || De.push(G || /(?:^|\\s)module(?:\\s|$)/.test(le) ? \"module \" : \"namespace \");\n                  }\n                  return De.push(W(\"id\")), U ? De.push(W(\"body\")) : X.body ? De.push(\" \", o(W(\"body\"))) : De.push(ue), De;\n                }\n              case \"TSConditionalType\":\n                return k(te, oe, W);\n              case \"TSInferType\":\n                return [\"infer\", \" \", W(\"typeParameter\")];\n              case \"TSIntersectionType\":\n                return V(te, oe, W);\n              case \"TSUnionType\":\n                return q(te, oe, W);\n              case \"TSFunctionType\":\n                return Y(te, oe, W);\n              case \"TSTupleType\":\n                return H(te, oe, W);\n              case \"TSTypeReference\":\n                return [W(\"typeName\"), N(te, oe, W, \"typeParameters\")];\n              case \"TSTypeAnnotation\":\n                return W(\"typeAnnotation\");\n              case \"TSEmptyBodyFunctionExpression\":\n                return L(te, oe, W);\n              case \"TSJSDocAllType\":\n                return \"*\";\n              case \"TSJSDocUnknownType\":\n                return \"?\";\n              case \"TSJSDocNullableType\":\n                return Q(te, W, \"?\");\n              case \"TSJSDocNonNullableType\":\n                return Q(te, W, \"!\");\n              case \"TSInstantiationExpression\":\n                return [W(\"expression\"), W(\"typeParameters\")];\n              default:\n                throw new Error(\"Unknown TypeScript node type: \".concat(JSON.stringify(X.type), \".\"));\n            }\n          }\n          n.exports = {\n            printTypescript: ee\n          };\n        }\n      }),\n      Km = Z({\n        \"src/language-js/print/comment.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              hasNewline: t\n            } = Ue(),\n            {\n              builders: {\n                join: s,\n                hardline: a\n              },\n              utils: {\n                replaceTextEndOfLine: r\n              }\n            } = Oe(),\n            {\n              isLineComment: u\n            } = Ke(),\n            {\n              locStart: i,\n              locEnd: o\n            } = st(),\n            c = It();\n          function v(p, f) {\n            let h = p.getValue();\n            if (u(h)) return f.originalText.slice(i(h), o(h)).trimEnd();\n            if (c(h)) {\n              if (m(h)) {\n                let A = d(h);\n                return h.trailing && !t(f.originalText, i(h), {\n                  backwards: !0\n                }) ? [a, A] : A;\n              }\n              let w = o(h),\n                T = f.originalText.slice(w - 3, w) === \"*-/\";\n              return [\"/*\", r(h.value), T ? \"*-/\" : \"*/\"];\n            }\n            throw new Error(\"Not a comment: \" + JSON.stringify(h));\n          }\n          function m(p) {\n            let f = \"*\".concat(p.value, \"*\").split(`\n`);\n            return f.length > 1 && f.every(h => h.trim()[0] === \"*\");\n          }\n          function d(p) {\n            let f = p.value.split(`\n`);\n            return [\"/*\", s(a, f.map((h, w) => w === 0 ? h.trimEnd() : \" \" + (w < f.length - 1 ? h.trim() : h.trimStart()))), \"*/\"];\n          }\n          n.exports = {\n            printComment: v\n          };\n        }\n      }),\n      Ym = Z({\n        \"src/language-js/print/literal.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            printString: t,\n            printNumber: s\n          } = Ue();\n          function a(i, o) {\n            let c = i.getNode();\n            switch (c.type) {\n              case \"RegExpLiteral\":\n                return u(c);\n              case \"BigIntLiteral\":\n                return r(c.bigint || c.extra.raw);\n              case \"NumericLiteral\":\n                return s(c.extra.raw);\n              case \"StringLiteral\":\n                return t(c.extra.raw, o);\n              case \"NullLiteral\":\n                return \"null\";\n              case \"BooleanLiteral\":\n                return String(c.value);\n              case \"DecimalLiteral\":\n                return s(c.value) + \"m\";\n              case \"Literal\":\n                {\n                  if (c.regex) return u(c.regex);\n                  if (c.bigint) return r(c.raw);\n                  if (c.decimal) return s(c.decimal) + \"m\";\n                  let {\n                    value: v\n                  } = c;\n                  return typeof v == \"number\" ? s(c.raw) : typeof v == \"string\" ? t(c.raw, o) : String(v);\n                }\n            }\n          }\n          function r(i) {\n            return i.toLowerCase();\n          }\n          function u(i) {\n            let {\n              pattern: o,\n              flags: c\n            } = i;\n            return c = [...c].sort().join(\"\"), \"/\".concat(o, \"/\").concat(c);\n          }\n          n.exports = {\n            printLiteral: a\n          };\n        }\n      }),\n      Qm = Z({\n        \"src/language-js/printer-estree.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              printDanglingComments: t\n            } = et(),\n            {\n              hasNewline: s\n            } = Ue(),\n            {\n              builders: {\n                join: a,\n                line: r,\n                hardline: u,\n                softline: i,\n                group: o,\n                indent: c\n              },\n              utils: {\n                replaceTextEndOfLine: v\n              }\n            } = Oe(),\n            m = Im(),\n            d = Lm(),\n            {\n              insertPragma: p\n            } = no(),\n            f = uo(),\n            h = jt(),\n            w = so(),\n            {\n              hasFlowShorthandAnnotationComment: T,\n              hasComment: A,\n              CommentCheckFlags: S,\n              isTheOnlyJsxElementInMarkdown: B,\n              isLineComment: I,\n              isNextLineEmpty: k,\n              needsHardlineAfterDanglingComment: P,\n              rawText: C,\n              hasIgnoreComment: D,\n              isCallExpression: g,\n              isMemberExpression: F,\n              markerForIfWithoutBlockAndSameLineComment: l\n            } = Ke(),\n            {\n              locStart: E,\n              locEnd: y\n            } = st(),\n            N = It(),\n            {\n              printHtmlBinding: x,\n              isVueEventBindingExpression: b\n            } = $m(),\n            {\n              printAngular: L\n            } = Hm(),\n            {\n              printJsx: M,\n              hasJsxIgnoreComment: j\n            } = Gm(),\n            {\n              printFlow: $\n            } = Um(),\n            {\n              printTypescript: V\n            } = Xm(),\n            {\n              printOptionalToken: q,\n              printBindExpressionCallee: Y,\n              printTypeAnnotation: H,\n              adjustClause: R,\n              printRestSpread: Q,\n              printDefiniteToken: ee\n            } = ct(),\n            {\n              printImportDeclaration: te,\n              printExportDeclaration: oe,\n              printExportAllDeclaration: W,\n              printModuleSpecifier: X\n            } = co(),\n            {\n              printTernary: ue\n            } = po(),\n            {\n              printTemplateLiteral: De\n            } = Lt(),\n            {\n              printArray: ie\n            } = Kt(),\n            {\n              printObject: G\n            } = zn(),\n            {\n              printClass: z,\n              printClassMethod: U,\n              printClassProperty: le\n            } = Zt(),\n            {\n              printProperty: ge\n            } = Qt(),\n            {\n              printFunction: Ae,\n              printArrowFunction: Ne,\n              printMethod: ke,\n              printReturnStatement: ce,\n              printThrowStatement: pe\n            } = Lr(),\n            {\n              printCallExpression: de\n            } = oo(),\n            {\n              printVariableDeclarator: ae,\n              printAssignmentExpression: ve\n            } = Yt(),\n            {\n              printBinaryishExpression: K\n            } = Jn(),\n            {\n              printSwitchCaseConsequent: he\n            } = fo(),\n            {\n              printMemberExpression: ye\n            } = ao(),\n            {\n              printBlock: Ce,\n              printBlockBody: Ie\n            } = Do(),\n            {\n              printComment: Fe\n            } = Km(),\n            {\n              printLiteral: me\n            } = Ym(),\n            {\n              printDecorators: _\n            } = Un();\n          function J(Be, Pe, Se, Qe) {\n            let xe = ne(Be, Pe, Se, Qe);\n            if (!xe) return \"\";\n            let Xe = Be.getValue(),\n              {\n                type: _e\n              } = Xe;\n            if (_e === \"ClassMethod\" || _e === \"ClassPrivateMethod\" || _e === \"ClassProperty\" || _e === \"ClassAccessorProperty\" || _e === \"PropertyDefinition\" || _e === \"TSAbstractPropertyDefinition\" || _e === \"ClassPrivateProperty\" || _e === \"MethodDefinition\" || _e === \"TSAbstractMethodDefinition\" || _e === \"TSDeclareMethod\") return xe;\n            let je = [xe],\n              Re = _(Be, Pe, Se),\n              be = Xe.type === \"ClassExpression\" && Re;\n            if (Re && (je = [...Re, xe], !be)) return o(je);\n            if (!h(Be, Pe)) return Qe && Qe.needsSemi && je.unshift(\";\"), je.length === 1 && je[0] === xe ? xe : je;\n            if (be && (je = [c([r, ...je])]), je.unshift(\"(\"), Qe && Qe.needsSemi && je.unshift(\";\"), T(Xe)) {\n              let [qe] = Xe.trailingComments;\n              je.push(\" /*\", qe.value.trimStart(), \"*/\"), qe.printed = !0;\n            }\n            return be && je.push(r), je.push(\")\"), je;\n          }\n          function ne(Be, Pe, Se, Qe) {\n            let xe = Be.getValue(),\n              Xe = Pe.semi ? \";\" : \"\";\n            if (!xe) return \"\";\n            if (typeof xe == \"string\") return xe;\n            for (let je of [me, x, L, M, $, V]) {\n              let Re = je(Be, Pe, Se);\n              if (typeof Re < \"u\") return Re;\n            }\n            let _e = [];\n            switch (xe.type) {\n              case \"JsExpressionRoot\":\n                return Se(\"node\");\n              case \"JsonRoot\":\n                return [Se(\"node\"), u];\n              case \"File\":\n                return xe.program && xe.program.interpreter && _e.push(Se([\"program\", \"interpreter\"])), _e.push(Se(\"program\")), _e;\n              case \"Program\":\n                return Ie(Be, Pe, Se);\n              case \"EmptyStatement\":\n                return \"\";\n              case \"ExpressionStatement\":\n                {\n                  if (xe.directive) return [Ee(xe.expression, Pe), Xe];\n                  if (Pe.parser === \"__vue_event_binding\" || Pe.parser === \"__vue_ts_event_binding\") {\n                    let Re = Be.getParentNode();\n                    if (Re.type === \"Program\" && Re.body.length === 1 && Re.body[0] === xe) return [Se(\"expression\"), b(xe.expression) ? \";\" : \"\"];\n                  }\n                  let je = t(Be, Pe, !0, Re => {\n                    let {\n                      marker: be\n                    } = Re;\n                    return be === l;\n                  });\n                  return [Se(\"expression\"), B(Pe, Be) ? \"\" : Xe, je ? [\" \", je] : \"\"];\n                }\n              case \"ParenthesizedExpression\":\n                return !A(xe.expression) && (xe.expression.type === \"ObjectExpression\" || xe.expression.type === \"ArrayExpression\") ? [\"(\", Se(\"expression\"), \")\"] : o([\"(\", c([i, Se(\"expression\")]), i, \")\"]);\n              case \"AssignmentExpression\":\n                return ve(Be, Pe, Se);\n              case \"VariableDeclarator\":\n                return ae(Be, Pe, Se);\n              case \"BinaryExpression\":\n              case \"LogicalExpression\":\n                return K(Be, Pe, Se);\n              case \"AssignmentPattern\":\n                return [Se(\"left\"), \" = \", Se(\"right\")];\n              case \"OptionalMemberExpression\":\n              case \"MemberExpression\":\n                return ye(Be, Pe, Se);\n              case \"MetaProperty\":\n                return [Se(\"meta\"), \".\", Se(\"property\")];\n              case \"BindExpression\":\n                return xe.object && _e.push(Se(\"object\")), _e.push(o(c([i, Y(Be, Pe, Se)]))), _e;\n              case \"Identifier\":\n                return [xe.name, q(Be), ee(Be), H(Be, Pe, Se)];\n              case \"V8IntrinsicIdentifier\":\n                return [\"%\", xe.name];\n              case \"SpreadElement\":\n              case \"SpreadElementPattern\":\n              case \"SpreadProperty\":\n              case \"SpreadPropertyPattern\":\n              case \"RestElement\":\n                return Q(Be, Pe, Se);\n              case \"FunctionDeclaration\":\n              case \"FunctionExpression\":\n                return Ae(Be, Se, Pe, Qe);\n              case \"ArrowFunctionExpression\":\n                return Ne(Be, Pe, Se, Qe);\n              case \"YieldExpression\":\n                return _e.push(\"yield\"), xe.delegate && _e.push(\"*\"), xe.argument && _e.push(\" \", Se(\"argument\")), _e;\n              case \"AwaitExpression\":\n                {\n                  if (_e.push(\"await\"), xe.argument) {\n                    _e.push(\" \", Se(\"argument\"));\n                    let je = Be.getParentNode();\n                    if (g(je) && je.callee === xe || F(je) && je.object === xe) {\n                      _e = [c([i, ..._e]), i];\n                      let Re = Be.findAncestor(be => be.type === \"AwaitExpression\" || be.type === \"BlockStatement\");\n                      if (!Re || Re.type !== \"AwaitExpression\") return o(_e);\n                    }\n                  }\n                  return _e;\n                }\n              case \"ExportDefaultDeclaration\":\n              case \"ExportNamedDeclaration\":\n                return oe(Be, Pe, Se);\n              case \"ExportAllDeclaration\":\n                return W(Be, Pe, Se);\n              case \"ImportDeclaration\":\n                return te(Be, Pe, Se);\n              case \"ImportSpecifier\":\n              case \"ExportSpecifier\":\n              case \"ImportNamespaceSpecifier\":\n              case \"ExportNamespaceSpecifier\":\n              case \"ImportDefaultSpecifier\":\n              case \"ExportDefaultSpecifier\":\n                return X(Be, Pe, Se);\n              case \"ImportAttribute\":\n                return [Se(\"key\"), \": \", Se(\"value\")];\n              case \"Import\":\n                return \"import\";\n              case \"BlockStatement\":\n              case \"StaticBlock\":\n              case \"ClassBody\":\n                return Ce(Be, Pe, Se);\n              case \"ThrowStatement\":\n                return pe(Be, Pe, Se);\n              case \"ReturnStatement\":\n                return ce(Be, Pe, Se);\n              case \"NewExpression\":\n              case \"ImportExpression\":\n              case \"OptionalCallExpression\":\n              case \"CallExpression\":\n                return de(Be, Pe, Se);\n              case \"ObjectExpression\":\n              case \"ObjectPattern\":\n              case \"RecordExpression\":\n                return G(Be, Pe, Se);\n              case \"ObjectProperty\":\n              case \"Property\":\n                return xe.method || xe.kind === \"get\" || xe.kind === \"set\" ? ke(Be, Pe, Se) : ge(Be, Pe, Se);\n              case \"ObjectMethod\":\n                return ke(Be, Pe, Se);\n              case \"Decorator\":\n                return [\"@\", Se(\"expression\")];\n              case \"ArrayExpression\":\n              case \"ArrayPattern\":\n              case \"TupleExpression\":\n                return ie(Be, Pe, Se);\n              case \"SequenceExpression\":\n                {\n                  let je = Be.getParentNode(0);\n                  if (je.type === \"ExpressionStatement\" || je.type === \"ForStatement\") {\n                    let Re = [];\n                    return Be.each((be, Le) => {\n                      Le === 0 ? Re.push(Se()) : Re.push(\",\", c([r, Se()]));\n                    }, \"expressions\"), o(Re);\n                  }\n                  return o(a([\",\", r], Be.map(Se, \"expressions\")));\n                }\n              case \"ThisExpression\":\n                return \"this\";\n              case \"Super\":\n                return \"super\";\n              case \"Directive\":\n                return [Se(\"value\"), Xe];\n              case \"DirectiveLiteral\":\n                return Ee(xe, Pe);\n              case \"UnaryExpression\":\n                return _e.push(xe.operator), /[a-z]$/.test(xe.operator) && _e.push(\" \"), A(xe.argument) ? _e.push(o([\"(\", c([i, Se(\"argument\")]), i, \")\"])) : _e.push(Se(\"argument\")), _e;\n              case \"UpdateExpression\":\n                return _e.push(Se(\"argument\"), xe.operator), xe.prefix && _e.reverse(), _e;\n              case \"ConditionalExpression\":\n                return ue(Be, Pe, Se);\n              case \"VariableDeclaration\":\n                {\n                  let je = Be.map(Se, \"declarations\"),\n                    Re = Be.getParentNode(),\n                    be = Re.type === \"ForStatement\" || Re.type === \"ForInStatement\" || Re.type === \"ForOfStatement\",\n                    Le = xe.declarations.some(se => se.init),\n                    qe;\n                  return je.length === 1 && !A(xe.declarations[0]) ? qe = je[0] : je.length > 0 && (qe = c(je[0])), _e = [xe.declare ? \"declare \" : \"\", xe.kind, qe ? [\" \", qe] : \"\", c(je.slice(1).map(se => [\",\", Le && !be ? u : r, se]))], be && Re.body !== xe || _e.push(Xe), o(_e);\n                }\n              case \"WithStatement\":\n                return o([\"with (\", Se(\"object\"), \")\", R(xe.body, Se(\"body\"))]);\n              case \"IfStatement\":\n                {\n                  let je = R(xe.consequent, Se(\"consequent\")),\n                    Re = o([\"if (\", o([c([i, Se(\"test\")]), i]), \")\", je]);\n                  if (_e.push(Re), xe.alternate) {\n                    let be = A(xe.consequent, S.Trailing | S.Line) || P(xe),\n                      Le = xe.consequent.type === \"BlockStatement\" && !be;\n                    _e.push(Le ? \" \" : u), A(xe, S.Dangling) && _e.push(t(Be, Pe, !0), be ? u : \" \"), _e.push(\"else\", o(R(xe.alternate, Se(\"alternate\"), xe.alternate.type === \"IfStatement\")));\n                  }\n                  return _e;\n                }\n              case \"ForStatement\":\n                {\n                  let je = R(xe.body, Se(\"body\")),\n                    Re = t(Be, Pe, !0),\n                    be = Re ? [Re, i] : \"\";\n                  return !xe.init && !xe.test && !xe.update ? [be, o([\"for (;;)\", je])] : [be, o([\"for (\", o([c([i, Se(\"init\"), \";\", r, Se(\"test\"), \";\", r, Se(\"update\")]), i]), \")\", je])];\n                }\n              case \"WhileStatement\":\n                return o([\"while (\", o([c([i, Se(\"test\")]), i]), \")\", R(xe.body, Se(\"body\"))]);\n              case \"ForInStatement\":\n                return o([\"for (\", Se(\"left\"), \" in \", Se(\"right\"), \")\", R(xe.body, Se(\"body\"))]);\n              case \"ForOfStatement\":\n                return o([\"for\", xe.await ? \" await\" : \"\", \" (\", Se(\"left\"), \" of \", Se(\"right\"), \")\", R(xe.body, Se(\"body\"))]);\n              case \"DoWhileStatement\":\n                {\n                  let je = R(xe.body, Se(\"body\"));\n                  return _e = [o([\"do\", je])], xe.body.type === \"BlockStatement\" ? _e.push(\" \") : _e.push(u), _e.push(\"while (\", o([c([i, Se(\"test\")]), i]), \")\", Xe), _e;\n                }\n              case \"DoExpression\":\n                return [xe.async ? \"async \" : \"\", \"do \", Se(\"body\")];\n              case \"BreakStatement\":\n                return _e.push(\"break\"), xe.label && _e.push(\" \", Se(\"label\")), _e.push(Xe), _e;\n              case \"ContinueStatement\":\n                return _e.push(\"continue\"), xe.label && _e.push(\" \", Se(\"label\")), _e.push(Xe), _e;\n              case \"LabeledStatement\":\n                return xe.body.type === \"EmptyStatement\" ? [Se(\"label\"), \":;\"] : [Se(\"label\"), \": \", Se(\"body\")];\n              case \"TryStatement\":\n                return [\"try \", Se(\"block\"), xe.handler ? [\" \", Se(\"handler\")] : \"\", xe.finalizer ? [\" finally \", Se(\"finalizer\")] : \"\"];\n              case \"CatchClause\":\n                if (xe.param) {\n                  let je = A(xe.param, be => !N(be) || be.leading && s(Pe.originalText, y(be)) || be.trailing && s(Pe.originalText, E(be), {\n                      backwards: !0\n                    })),\n                    Re = Se(\"param\");\n                  return [\"catch \", je ? [\"(\", c([i, Re]), i, \") \"] : [\"(\", Re, \") \"], Se(\"body\")];\n                }\n                return [\"catch \", Se(\"body\")];\n              case \"SwitchStatement\":\n                return [o([\"switch (\", c([i, Se(\"discriminant\")]), i, \")\"]), \" {\", xe.cases.length > 0 ? c([u, a(u, Be.map((je, Re, be) => {\n                  let Le = je.getValue();\n                  return [Se(), Re !== be.length - 1 && k(Le, Pe) ? u : \"\"];\n                }, \"cases\"))]) : \"\", u, \"}\"];\n              case \"SwitchCase\":\n                {\n                  xe.test ? _e.push(\"case \", Se(\"test\"), \":\") : _e.push(\"default:\"), A(xe, S.Dangling) && _e.push(\" \", t(Be, Pe, !0));\n                  let je = xe.consequent.filter(Re => Re.type !== \"EmptyStatement\");\n                  if (je.length > 0) {\n                    let Re = he(Be, Pe, Se);\n                    _e.push(je.length === 1 && je[0].type === \"BlockStatement\" ? [\" \", Re] : c([u, Re]));\n                  }\n                  return _e;\n                }\n              case \"DebuggerStatement\":\n                return [\"debugger\", Xe];\n              case \"ClassDeclaration\":\n              case \"ClassExpression\":\n                return z(Be, Pe, Se);\n              case \"ClassMethod\":\n              case \"ClassPrivateMethod\":\n              case \"MethodDefinition\":\n                return U(Be, Pe, Se);\n              case \"ClassProperty\":\n              case \"PropertyDefinition\":\n              case \"ClassPrivateProperty\":\n              case \"ClassAccessorProperty\":\n                return le(Be, Pe, Se);\n              case \"TemplateElement\":\n                return v(xe.value.raw);\n              case \"TemplateLiteral\":\n                return De(Be, Se, Pe);\n              case \"TaggedTemplateExpression\":\n                return [Se(\"tag\"), Se(\"typeParameters\"), Se(\"quasi\")];\n              case \"PrivateIdentifier\":\n                return [\"#\", Se(\"name\")];\n              case \"PrivateName\":\n                return [\"#\", Se(\"id\")];\n              case \"InterpreterDirective\":\n                return _e.push(\"#!\", xe.value, u), k(xe, Pe) && _e.push(u), _e;\n              case \"TopicReference\":\n                return \"%\";\n              case \"ArgumentPlaceholder\":\n                return \"?\";\n              case \"ModuleExpression\":\n                {\n                  _e.push(\"module {\");\n                  let je = Se(\"body\");\n                  return je && _e.push(c([u, je]), u), _e.push(\"}\"), _e;\n                }\n              default:\n                throw new Error(\"unknown type: \" + JSON.stringify(xe.type));\n            }\n          }\n          function Ee(Be, Pe) {\n            let Se = C(Be),\n              Qe = Se.slice(1, -1);\n            if (Qe.includes('\"') || Qe.includes(\"'\")) return Se;\n            let xe = Pe.singleQuote ? \"'\" : '\"';\n            return xe + Qe + xe;\n          }\n          function We(Be) {\n            return Be.type && !N(Be) && !I(Be) && Be.type !== \"EmptyStatement\" && Be.type !== \"TemplateElement\" && Be.type !== \"Import\" && Be.type !== \"TSEmptyBodyFunctionExpression\";\n          }\n          n.exports = {\n            preprocess: w,\n            print: J,\n            embed: m,\n            insertPragma: p,\n            massageAstNode: d,\n            hasPrettierIgnore(Be) {\n              return D(Be) || j(Be);\n            },\n            willPrintOwnComments: f.willPrintOwnComments,\n            canAttachComment: We,\n            printComment: Fe,\n            isBlockComment: N,\n            handleComments: {\n              avoidAstMutation: !0,\n              ownLine: f.handleOwnLineComment,\n              endOfLine: f.handleEndOfLineComment,\n              remaining: f.handleRemainingComment\n            },\n            getCommentChildNodes: f.getCommentChildNodes\n          };\n        }\n      }),\n      Zm = Z({\n        \"src/language-js/printer-estree-json.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                hardline: t,\n                indent: s,\n                join: a\n              }\n            } = Oe(),\n            r = so();\n          function u(c, v, m) {\n            let d = c.getValue();\n            switch (d.type) {\n              case \"JsonRoot\":\n                return [m(\"node\"), t];\n              case \"ArrayExpression\":\n                {\n                  if (d.elements.length === 0) return \"[]\";\n                  let p = c.map(() => c.getValue() === null ? \"null\" : m(), \"elements\");\n                  return [\"[\", s([t, a([\",\", t], p)]), t, \"]\"];\n                }\n              case \"ObjectExpression\":\n                return d.properties.length === 0 ? \"{}\" : [\"{\", s([t, a([\",\", t], c.map(m, \"properties\"))]), t, \"}\"];\n              case \"ObjectProperty\":\n                return [m(\"key\"), \": \", m(\"value\")];\n              case \"UnaryExpression\":\n                return [d.operator === \"+\" ? \"\" : d.operator, m(\"argument\")];\n              case \"NullLiteral\":\n                return \"null\";\n              case \"BooleanLiteral\":\n                return d.value ? \"true\" : \"false\";\n              case \"StringLiteral\":\n              case \"NumericLiteral\":\n                return JSON.stringify(d.value);\n              case \"Identifier\":\n                {\n                  let p = c.getParentNode();\n                  return p && p.type === \"ObjectProperty\" && p.key === d ? JSON.stringify(d.name) : d.name;\n                }\n              case \"TemplateLiteral\":\n                return m([\"quasis\", 0]);\n              case \"TemplateElement\":\n                return JSON.stringify(d.value.cooked);\n              default:\n                throw new Error(\"unknown type: \" + JSON.stringify(d.type));\n            }\n          }\n          var i = new Set([\"start\", \"end\", \"extra\", \"loc\", \"comments\", \"leadingComments\", \"trailingComments\", \"innerComments\", \"errors\", \"range\", \"tokens\"]);\n          function o(c, v) {\n            let {\n              type: m\n            } = c;\n            if (m === \"ObjectProperty\" && c.key.type === \"Identifier\") {\n              v.key = {\n                type: \"StringLiteral\",\n                value: c.key.name\n              };\n              return;\n            }\n            if (m === \"UnaryExpression\" && c.operator === \"+\") return v.argument;\n            if (m === \"ArrayExpression\") {\n              for (let [d, p] of c.elements.entries()) p === null && v.elements.splice(d, 0, {\n                type: \"NullLiteral\"\n              });\n              return;\n            }\n            if (m === \"TemplateLiteral\") return {\n              type: \"StringLiteral\",\n              value: c.quasis[0].value.cooked\n            };\n          }\n          o.ignoredProperties = i, n.exports = {\n            preprocess: r,\n            print: u,\n            massageAstNode: o\n          };\n        }\n      }),\n      Ot = Z({\n        \"src/common/common-options.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = \"Common\";\n          n.exports = {\n            bracketSpacing: {\n              since: \"0.0.0\",\n              category: t,\n              type: \"boolean\",\n              default: !0,\n              description: \"Print spaces between brackets.\",\n              oppositeDescription: \"Do not print spaces between brackets.\"\n            },\n            singleQuote: {\n              since: \"0.0.0\",\n              category: t,\n              type: \"boolean\",\n              default: !1,\n              description: \"Use single quotes instead of double quotes.\"\n            },\n            proseWrap: {\n              since: \"1.8.2\",\n              category: t,\n              type: \"choice\",\n              default: [{\n                since: \"1.8.2\",\n                value: !0\n              }, {\n                since: \"1.9.0\",\n                value: \"preserve\"\n              }],\n              description: \"How to wrap prose.\",\n              choices: [{\n                since: \"1.9.0\",\n                value: \"always\",\n                description: \"Wrap prose if it exceeds the print width.\"\n              }, {\n                since: \"1.9.0\",\n                value: \"never\",\n                description: \"Do not wrap prose.\"\n              }, {\n                since: \"1.9.0\",\n                value: \"preserve\",\n                description: \"Wrap prose as-is.\"\n              }]\n            },\n            bracketSameLine: {\n              since: \"2.4.0\",\n              category: t,\n              type: \"boolean\",\n              default: !1,\n              description: \"Put > of opening tags on the last line instead of on a new line.\"\n            },\n            singleAttributePerLine: {\n              since: \"2.6.0\",\n              category: t,\n              type: \"boolean\",\n              default: !1,\n              description: \"Enforce single attribute per line in HTML, Vue and JSX.\"\n            }\n          };\n        }\n      }),\n      ed = Z({\n        \"src/language-js/options.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Ot(),\n            s = \"JavaScript\";\n          n.exports = {\n            arrowParens: {\n              since: \"1.9.0\",\n              category: s,\n              type: \"choice\",\n              default: [{\n                since: \"1.9.0\",\n                value: \"avoid\"\n              }, {\n                since: \"2.0.0\",\n                value: \"always\"\n              }],\n              description: \"Include parentheses around a sole arrow function parameter.\",\n              choices: [{\n                value: \"always\",\n                description: \"Always include parens. Example: `(x) => x`\"\n              }, {\n                value: \"avoid\",\n                description: \"Omit parens when possible. Example: `x => x`\"\n              }]\n            },\n            bracketSameLine: t.bracketSameLine,\n            bracketSpacing: t.bracketSpacing,\n            jsxBracketSameLine: {\n              since: \"0.17.0\",\n              category: s,\n              type: \"boolean\",\n              description: \"Put > on the last line instead of at a new line.\",\n              deprecated: \"2.4.0\"\n            },\n            semi: {\n              since: \"1.0.0\",\n              category: s,\n              type: \"boolean\",\n              default: !0,\n              description: \"Print semicolons.\",\n              oppositeDescription: \"Do not print semicolons, except at the beginning of lines which may need them.\"\n            },\n            singleQuote: t.singleQuote,\n            jsxSingleQuote: {\n              since: \"1.15.0\",\n              category: s,\n              type: \"boolean\",\n              default: !1,\n              description: \"Use single quotes in JSX.\"\n            },\n            quoteProps: {\n              since: \"1.17.0\",\n              category: s,\n              type: \"choice\",\n              default: \"as-needed\",\n              description: \"Change when properties in objects are quoted.\",\n              choices: [{\n                value: \"as-needed\",\n                description: \"Only add quotes around object properties where required.\"\n              }, {\n                value: \"consistent\",\n                description: \"If at least one property in an object requires quotes, quote all properties.\"\n              }, {\n                value: \"preserve\",\n                description: \"Respect the input use of quotes in object properties.\"\n              }]\n            },\n            trailingComma: {\n              since: \"0.0.0\",\n              category: s,\n              type: \"choice\",\n              default: [{\n                since: \"0.0.0\",\n                value: !1\n              }, {\n                since: \"0.19.0\",\n                value: \"none\"\n              }, {\n                since: \"2.0.0\",\n                value: \"es5\"\n              }],\n              description: \"Print trailing commas wherever possible when multi-line.\",\n              choices: [{\n                value: \"es5\",\n                description: \"Trailing commas where valid in ES5 (objects, arrays, etc.)\"\n              }, {\n                value: \"none\",\n                description: \"No trailing commas.\"\n              }, {\n                value: \"all\",\n                description: \"Trailing commas wherever possible (including function arguments).\"\n              }]\n            },\n            singleAttributePerLine: t.singleAttributePerLine\n          };\n        }\n      }),\n      td = Z({\n        \"src/language-js/parse/parsers.js\"() {\n          re();\n        }\n      }),\n      Sn = Z({\n        \"node_modules/linguist-languages/data/JavaScript.json\"(e, n) {\n          n.exports = {\n            name: \"JavaScript\",\n            type: \"programming\",\n            tmScope: \"source.js\",\n            aceMode: \"javascript\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"text/javascript\",\n            color: \"#f1e05a\",\n            aliases: [\"js\", \"node\"],\n            extensions: [\".js\", \"._js\", \".bones\", \".cjs\", \".es\", \".es6\", \".frag\", \".gs\", \".jake\", \".javascript\", \".jsb\", \".jscad\", \".jsfl\", \".jslib\", \".jsm\", \".jspre\", \".jss\", \".jsx\", \".mjs\", \".njs\", \".pac\", \".sjs\", \".ssjs\", \".xsjs\", \".xsjslib\"],\n            filenames: [\"Jakefile\"],\n            interpreters: [\"chakra\", \"d8\", \"gjs\", \"js\", \"node\", \"nodejs\", \"qjs\", \"rhino\", \"v8\", \"v8-shell\"],\n            languageId: 183\n          };\n        }\n      }),\n      rd = Z({\n        \"node_modules/linguist-languages/data/TypeScript.json\"(e, n) {\n          n.exports = {\n            name: \"TypeScript\",\n            type: \"programming\",\n            color: \"#3178c6\",\n            aliases: [\"ts\"],\n            interpreters: [\"deno\", \"ts-node\"],\n            extensions: [\".ts\", \".cts\", \".mts\"],\n            tmScope: \"source.ts\",\n            aceMode: \"typescript\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"application/typescript\",\n            languageId: 378\n          };\n        }\n      }),\n      nd = Z({\n        \"node_modules/linguist-languages/data/TSX.json\"(e, n) {\n          n.exports = {\n            name: \"TSX\",\n            type: \"programming\",\n            color: \"#3178c6\",\n            group: \"TypeScript\",\n            extensions: [\".tsx\"],\n            tmScope: \"source.tsx\",\n            aceMode: \"javascript\",\n            codemirrorMode: \"jsx\",\n            codemirrorMimeType: \"text/jsx\",\n            languageId: 94901924\n          };\n        }\n      }),\n      ma = Z({\n        \"node_modules/linguist-languages/data/JSON.json\"(e, n) {\n          n.exports = {\n            name: \"JSON\",\n            type: \"data\",\n            color: \"#292929\",\n            tmScope: \"source.json\",\n            aceMode: \"json\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"application/json\",\n            aliases: [\"geojson\", \"jsonl\", \"topojson\"],\n            extensions: [\".json\", \".4DForm\", \".4DProject\", \".avsc\", \".geojson\", \".gltf\", \".har\", \".ice\", \".JSON-tmLanguage\", \".jsonl\", \".mcmeta\", \".tfstate\", \".tfstate.backup\", \".topojson\", \".webapp\", \".webmanifest\", \".yy\", \".yyp\"],\n            filenames: [\".arcconfig\", \".auto-changelog\", \".c8rc\", \".htmlhintrc\", \".imgbotconfig\", \".nycrc\", \".tern-config\", \".tern-project\", \".watchmanconfig\", \"Pipfile.lock\", \"composer.lock\", \"mcmod.info\"],\n            languageId: 174\n          };\n        }\n      }),\n      ud = Z({\n        \"node_modules/linguist-languages/data/JSON with Comments.json\"(e, n) {\n          n.exports = {\n            name: \"JSON with Comments\",\n            type: \"data\",\n            color: \"#292929\",\n            group: \"JSON\",\n            tmScope: \"source.js\",\n            aceMode: \"javascript\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"text/javascript\",\n            aliases: [\"jsonc\"],\n            extensions: [\".jsonc\", \".code-snippets\", \".sublime-build\", \".sublime-commands\", \".sublime-completions\", \".sublime-keymap\", \".sublime-macro\", \".sublime-menu\", \".sublime-mousemap\", \".sublime-project\", \".sublime-settings\", \".sublime-theme\", \".sublime-workspace\", \".sublime_metrics\", \".sublime_session\"],\n            filenames: [\".babelrc\", \".devcontainer.json\", \".eslintrc.json\", \".jscsrc\", \".jshintrc\", \".jslintrc\", \"api-extractor.json\", \"devcontainer.json\", \"jsconfig.json\", \"language-configuration.json\", \"tsconfig.json\", \"tslint.json\"],\n            languageId: 423\n          };\n        }\n      }),\n      sd = Z({\n        \"node_modules/linguist-languages/data/JSON5.json\"(e, n) {\n          n.exports = {\n            name: \"JSON5\",\n            type: \"data\",\n            color: \"#267CB9\",\n            extensions: [\".json5\"],\n            tmScope: \"source.js\",\n            aceMode: \"javascript\",\n            codemirrorMode: \"javascript\",\n            codemirrorMimeType: \"application/json\",\n            languageId: 175\n          };\n        }\n      }),\n      id = Z({\n        \"src/language-js/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Bt(),\n            s = Qm(),\n            a = Zm(),\n            r = ed(),\n            u = td(),\n            i = [t(Sn(), c => ({\n              since: \"0.0.0\",\n              parsers: [\"babel\", \"acorn\", \"espree\", \"meriyah\", \"babel-flow\", \"babel-ts\", \"flow\", \"typescript\"],\n              vscodeLanguageIds: [\"javascript\", \"mongo\"],\n              interpreters: [...c.interpreters, \"zx\"],\n              extensions: [...c.extensions.filter(v => v !== \".jsx\"), \".wxs\"]\n            })), t(Sn(), () => ({\n              name: \"Flow\",\n              since: \"0.0.0\",\n              parsers: [\"flow\", \"babel-flow\"],\n              vscodeLanguageIds: [\"javascript\"],\n              aliases: [],\n              filenames: [],\n              extensions: [\".js.flow\"]\n            })), t(Sn(), () => ({\n              name: \"JSX\",\n              since: \"0.0.0\",\n              parsers: [\"babel\", \"babel-flow\", \"babel-ts\", \"flow\", \"typescript\", \"espree\", \"meriyah\"],\n              vscodeLanguageIds: [\"javascriptreact\"],\n              aliases: void 0,\n              filenames: void 0,\n              extensions: [\".jsx\"],\n              group: \"JavaScript\",\n              interpreters: void 0,\n              tmScope: \"source.js.jsx\",\n              aceMode: \"javascript\",\n              codemirrorMode: \"jsx\",\n              codemirrorMimeType: \"text/jsx\",\n              color: void 0\n            })), t(rd(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"typescript\", \"babel-ts\"],\n              vscodeLanguageIds: [\"typescript\"]\n            })), t(nd(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"typescript\", \"babel-ts\"],\n              vscodeLanguageIds: [\"typescriptreact\"]\n            })), t(ma(), () => ({\n              name: \"JSON.stringify\",\n              since: \"1.13.0\",\n              parsers: [\"json-stringify\"],\n              vscodeLanguageIds: [\"json\"],\n              extensions: [\".importmap\"],\n              filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"]\n            })), t(ma(), c => ({\n              since: \"1.5.0\",\n              parsers: [\"json\"],\n              vscodeLanguageIds: [\"json\"],\n              extensions: c.extensions.filter(v => v !== \".jsonl\")\n            })), t(ud(), c => ({\n              since: \"1.5.0\",\n              parsers: [\"json\"],\n              vscodeLanguageIds: [\"jsonc\"],\n              filenames: [...c.filenames, \".eslintrc\", \".swcrc\"]\n            })), t(sd(), () => ({\n              since: \"1.13.0\",\n              parsers: [\"json5\"],\n              vscodeLanguageIds: [\"json5\"]\n            }))],\n            o = {\n              estree: s,\n              \"estree-json\": a\n            };\n          n.exports = {\n            languages: i,\n            options: r,\n            printers: o,\n            parsers: u\n          };\n        }\n      }),\n      ad = Z({\n        \"src/language-css/clean.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isFrontMatterNode: t\n            } = Ue(),\n            s = it(),\n            a = new Set([\"raw\", \"raws\", \"sourceIndex\", \"source\", \"before\", \"after\", \"trailingComma\"]);\n          function r(i, o, c) {\n            if (t(i) && i.lang === \"yaml\" && delete o.value, i.type === \"css-comment\" && c.type === \"css-root\" && c.nodes.length > 0 && ((c.nodes[0] === i || t(c.nodes[0]) && c.nodes[1] === i) && (delete o.text, /^\\*\\s*@(?:format|prettier)\\s*$/.test(i.text)) || c.type === \"css-root\" && s(c.nodes) === i)) return null;\n            if (i.type === \"value-root\" && delete o.text, (i.type === \"media-query\" || i.type === \"media-query-list\" || i.type === \"media-feature-expression\") && delete o.value, i.type === \"css-rule\" && delete o.params, i.type === \"selector-combinator\" && (o.value = o.value.replace(/\\s+/g, \" \")), i.type === \"media-feature\" && (o.value = o.value.replace(/ /g, \"\")), (i.type === \"value-word\" && (i.isColor && i.isHex || [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(o.value.replace().toLowerCase())) || i.type === \"media-feature\" || i.type === \"selector-root-invalid\" || i.type === \"selector-pseudo\") && (o.value = o.value.toLowerCase()), i.type === \"css-decl\" && (o.prop = o.prop.toLowerCase()), (i.type === \"css-atrule\" || i.type === \"css-import\") && (o.name = o.name.toLowerCase()), i.type === \"value-number\" && (o.unit = o.unit.toLowerCase()), (i.type === \"media-feature\" || i.type === \"media-keyword\" || i.type === \"media-type\" || i.type === \"media-unknown\" || i.type === \"media-url\" || i.type === \"media-value\" || i.type === \"selector-attribute\" || i.type === \"selector-string\" || i.type === \"selector-class\" || i.type === \"selector-combinator\" || i.type === \"value-string\") && o.value && (o.value = u(o.value)), i.type === \"selector-attribute\" && (o.attribute = o.attribute.trim(), o.namespace && typeof o.namespace == \"string\" && (o.namespace = o.namespace.trim(), o.namespace.length === 0 && (o.namespace = !0)), o.value && (o.value = o.value.trim().replace(/^[\"']|[\"']$/g, \"\"), delete o.quoted)), (i.type === \"media-value\" || i.type === \"media-type\" || i.type === \"value-number\" || i.type === \"selector-root-invalid\" || i.type === \"selector-class\" || i.type === \"selector-combinator\" || i.type === \"selector-tag\") && o.value && (o.value = o.value.replace(/([\\d+.Ee-]+)([A-Za-z]*)/g, (v, m, d) => {\n              let p = Number(m);\n              return Number.isNaN(p) ? v : p + d.toLowerCase();\n            })), i.type === \"selector-tag\") {\n              let v = i.value.toLowerCase();\n              [\"from\", \"to\"].includes(v) && (o.value = v);\n            }\n            if (i.type === \"css-atrule\" && i.name.toLowerCase() === \"supports\" && delete o.value, i.type === \"selector-unknown\" && delete o.value, i.type === \"value-comma_group\") {\n              let v = i.groups.findIndex(m => m.type === \"value-number\" && m.unit === \"...\");\n              v !== -1 && (o.groups[v].unit = \"\", o.groups.splice(v + 1, 0, {\n                type: \"value-word\",\n                value: \"...\",\n                isColor: !1,\n                isHex: !1\n              }));\n            }\n          }\n          r.ignoredProperties = a;\n          function u(i) {\n            return i.replace(/'/g, '\"').replace(/\\\\([^\\dA-Fa-f])/g, \"$1\");\n          }\n          n.exports = r;\n        }\n      }),\n      Xn = Z({\n        \"src/utils/front-matter/print.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            builders: {\n              hardline: t,\n              markAsRoot: s\n            }\n          } = Oe();\n          function a(r, u) {\n            if (r.lang === \"yaml\") {\n              let i = r.value.trim(),\n                o = i ? u(i, {\n                  parser: \"yaml\"\n                }, {\n                  stripTrailingHardline: !0\n                }) : \"\";\n              return s([r.startDelimiter, t, o, o ? t : \"\", r.endDelimiter]);\n            }\n          }\n          n.exports = a;\n        }\n      }),\n      od = Z({\n        \"src/language-css/embed.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                hardline: t\n              }\n            } = Oe(),\n            s = Xn();\n          function a(r, u, i) {\n            let o = r.getValue();\n            if (o.type === \"front-matter\") {\n              let c = s(o, i);\n              return c ? [c, t] : \"\";\n            }\n          }\n          n.exports = a;\n        }\n      }),\n      mo = Z({\n        \"src/utils/front-matter/parse.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = new RegExp(\"^(?<startDelimiter>-{3}|\\\\+{3})(?<language>[^\\\\n]*)\\\\n(?:|(?<value>.*?)\\\\n)(?<endDelimiter>\\\\k<startDelimiter>|\\\\.{3})[^\\\\S\\\\n]*(?:\\\\n|$)\", \"s\");\n          function s(a) {\n            let r = a.match(t);\n            if (!r) return {\n              content: a\n            };\n            let {\n                startDelimiter: u,\n                language: i,\n                value: o = \"\",\n                endDelimiter: c\n              } = r.groups,\n              v = i.trim() || \"yaml\";\n            if (u === \"+++\" && (v = \"toml\"), v !== \"yaml\" && u !== c) return {\n              content: a\n            };\n            let [m] = r;\n            return {\n              frontMatter: {\n                type: \"front-matter\",\n                lang: v,\n                value: o,\n                startDelimiter: u,\n                endDelimiter: c,\n                raw: m.replace(/\\n$/, \"\")\n              },\n              content: m.replace(/[^\\n]/g, \" \") + a.slice(m.length)\n            };\n          }\n          n.exports = s;\n        }\n      }),\n      ld = Z({\n        \"src/language-css/pragma.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = no(),\n            s = mo();\n          function a(u) {\n            return t.hasPragma(s(u).content);\n          }\n          function r(u) {\n            let {\n              frontMatter: i,\n              content: o\n            } = s(u);\n            return (i ? i.raw + `\n\n` : \"\") + t.insertPragma(o);\n          }\n          n.exports = {\n            hasPragma: a,\n            insertPragma: r\n          };\n        }\n      }),\n      cd = Z({\n        \"src/language-css/utils/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = new Set([\"red\", \"green\", \"blue\", \"alpha\", \"a\", \"rgb\", \"hue\", \"h\", \"saturation\", \"s\", \"lightness\", \"l\", \"whiteness\", \"w\", \"blackness\", \"b\", \"tint\", \"shade\", \"blend\", \"blenda\", \"contrast\", \"hsl\", \"hsla\", \"hwb\", \"hwba\"]);\n          function s(G, z) {\n            let U = Array.isArray(z) ? z : [z],\n              le = -1,\n              ge;\n            for (; ge = G.getParentNode(++le);) if (U.includes(ge.type)) return le;\n            return -1;\n          }\n          function a(G, z) {\n            let U = s(G, z);\n            return U === -1 ? null : G.getParentNode(U);\n          }\n          function r(G) {\n            var z;\n            let U = a(G, \"css-decl\");\n            return U == null || (z = U.prop) === null || z === void 0 ? void 0 : z.toLowerCase();\n          }\n          var u = new Set([\"initial\", \"inherit\", \"unset\", \"revert\"]);\n          function i(G) {\n            return u.has(G.toLowerCase());\n          }\n          function o(G, z) {\n            let U = a(G, \"css-atrule\");\n            return (U == null ? void 0 : U.name) && U.name.toLowerCase().endsWith(\"keyframes\") && [\"from\", \"to\"].includes(z.toLowerCase());\n          }\n          function c(G) {\n            return G.includes(\"$\") || G.includes(\"@\") || G.includes(\"#\") || G.startsWith(\"%\") || G.startsWith(\"--\") || G.startsWith(\":--\") || G.includes(\"(\") && G.includes(\")\") ? G : G.toLowerCase();\n          }\n          function v(G, z) {\n            var U;\n            let le = a(G, \"value-func\");\n            return (le == null || (U = le.value) === null || U === void 0 ? void 0 : U.toLowerCase()) === z;\n          }\n          function m(G) {\n            var z;\n            let U = a(G, \"css-rule\"),\n              le = U == null || (z = U.raws) === null || z === void 0 ? void 0 : z.selector;\n            return le && (le.startsWith(\":import\") || le.startsWith(\":export\"));\n          }\n          function d(G, z) {\n            let U = Array.isArray(z) ? z : [z],\n              le = a(G, \"css-atrule\");\n            return le && U.includes(le.name.toLowerCase());\n          }\n          function p(G) {\n            let z = G.getValue(),\n              U = a(G, \"css-atrule\");\n            return (U == null ? void 0 : U.name) === \"import\" && z.groups[0].value === \"url\" && z.groups.length === 2;\n          }\n          function f(G) {\n            return G.type === \"value-func\" && G.value.toLowerCase() === \"url\";\n          }\n          function h(G, z) {\n            var U;\n            let le = (U = G.getParentNode()) === null || U === void 0 ? void 0 : U.nodes;\n            return le && le.indexOf(z) === le.length - 1;\n          }\n          function w(G) {\n            let {\n              selector: z\n            } = G;\n            return z ? typeof z == \"string\" && /^@.+:.*$/.test(z) || z.value && /^@.+:.*$/.test(z.value) : !1;\n          }\n          function T(G) {\n            return G.type === \"value-word\" && [\"from\", \"through\", \"end\"].includes(G.value);\n          }\n          function A(G) {\n            return G.type === \"value-word\" && [\"and\", \"or\", \"not\"].includes(G.value);\n          }\n          function S(G) {\n            return G.type === \"value-word\" && G.value === \"in\";\n          }\n          function B(G) {\n            return G.type === \"value-operator\" && G.value === \"*\";\n          }\n          function I(G) {\n            return G.type === \"value-operator\" && G.value === \"/\";\n          }\n          function k(G) {\n            return G.type === \"value-operator\" && G.value === \"+\";\n          }\n          function P(G) {\n            return G.type === \"value-operator\" && G.value === \"-\";\n          }\n          function C(G) {\n            return G.type === \"value-operator\" && G.value === \"%\";\n          }\n          function D(G) {\n            return B(G) || I(G) || k(G) || P(G) || C(G);\n          }\n          function g(G) {\n            return G.type === \"value-word\" && [\"==\", \"!=\"].includes(G.value);\n          }\n          function F(G) {\n            return G.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].includes(G.value);\n          }\n          function l(G) {\n            return G.type === \"css-atrule\" && [\"if\", \"else\", \"for\", \"each\", \"while\"].includes(G.name);\n          }\n          function E(G) {\n            var z;\n            return ((z = G.raws) === null || z === void 0 ? void 0 : z.params) && /^\\(\\s*\\)$/.test(G.raws.params);\n          }\n          function y(G) {\n            return G.name.startsWith(\"prettier-placeholder\");\n          }\n          function N(G) {\n            return G.prop.startsWith(\"@prettier-placeholder\");\n          }\n          function x(G, z) {\n            return G.value === \"$$\" && G.type === \"value-func\" && (z == null ? void 0 : z.type) === \"value-word\" && !z.raws.before;\n          }\n          function b(G) {\n            var z, U;\n            return ((z = G.value) === null || z === void 0 ? void 0 : z.type) === \"value-root\" && ((U = G.value.group) === null || U === void 0 ? void 0 : U.type) === \"value-value\" && G.prop.toLowerCase() === \"composes\";\n          }\n          function L(G) {\n            var z, U, le;\n            return ((z = G.value) === null || z === void 0 || (U = z.group) === null || U === void 0 || (le = U.group) === null || le === void 0 ? void 0 : le.type) === \"value-paren_group\" && G.value.group.group.open !== null && G.value.group.group.close !== null;\n          }\n          function M(G) {\n            var z;\n            return ((z = G.raws) === null || z === void 0 ? void 0 : z.before) === \"\";\n          }\n          function j(G) {\n            var z, U;\n            return G.type === \"value-comma_group\" && ((z = G.groups) === null || z === void 0 || (U = z[1]) === null || U === void 0 ? void 0 : U.type) === \"value-colon\";\n          }\n          function $(G) {\n            var z;\n            return G.type === \"value-paren_group\" && ((z = G.groups) === null || z === void 0 ? void 0 : z[0]) && j(G.groups[0]);\n          }\n          function V(G) {\n            var z;\n            let U = G.getValue();\n            if (U.groups.length === 0) return !1;\n            let le = G.getParentNode(1);\n            if (!$(U) && !(le && $(le))) return !1;\n            let ge = a(G, \"css-decl\");\n            return !!(ge != null && (z = ge.prop) !== null && z !== void 0 && z.startsWith(\"$\") || $(le) || le.type === \"value-func\");\n          }\n          function q(G) {\n            return G.type === \"value-comment\" && G.inline;\n          }\n          function Y(G) {\n            return G.type === \"value-word\" && G.value === \"#\";\n          }\n          function H(G) {\n            return G.type === \"value-word\" && G.value === \"{\";\n          }\n          function R(G) {\n            return G.type === \"value-word\" && G.value === \"}\";\n          }\n          function Q(G) {\n            return [\"value-word\", \"value-atword\"].includes(G.type);\n          }\n          function ee(G) {\n            return (G == null ? void 0 : G.type) === \"value-colon\";\n          }\n          function te(G, z) {\n            if (!j(z)) return !1;\n            let {\n                groups: U\n              } = z,\n              le = U.indexOf(G);\n            return le === -1 ? !1 : ee(U[le + 1]);\n          }\n          function oe(G) {\n            return G.value && [\"not\", \"and\", \"or\"].includes(G.value.toLowerCase());\n          }\n          function W(G) {\n            return G.type !== \"value-func\" ? !1 : t.has(G.value.toLowerCase());\n          }\n          function X(G) {\n            return /\\/\\//.test(G.split(/[\\n\\r]/).pop());\n          }\n          function ue(G) {\n            return (G == null ? void 0 : G.type) === \"value-atword\" && G.value.startsWith(\"prettier-placeholder-\");\n          }\n          function De(G, z) {\n            var U, le;\n            if (((U = G.open) === null || U === void 0 ? void 0 : U.value) !== \"(\" || ((le = G.close) === null || le === void 0 ? void 0 : le.value) !== \")\" || G.groups.some(ge => ge.type !== \"value-comma_group\")) return !1;\n            if (z.type === \"value-comma_group\") {\n              let ge = z.groups.indexOf(G) - 1,\n                Ae = z.groups[ge];\n              if ((Ae == null ? void 0 : Ae.type) === \"value-word\" && Ae.value === \"with\") return !0;\n            }\n            return !1;\n          }\n          function ie(G) {\n            var z, U;\n            return G.type === \"value-paren_group\" && ((z = G.open) === null || z === void 0 ? void 0 : z.value) === \"(\" && ((U = G.close) === null || U === void 0 ? void 0 : U.value) === \")\";\n          }\n          n.exports = {\n            getAncestorCounter: s,\n            getAncestorNode: a,\n            getPropOfDeclNode: r,\n            maybeToLowerCase: c,\n            insideValueFunctionNode: v,\n            insideICSSRuleNode: m,\n            insideAtRuleNode: d,\n            insideURLFunctionInImportAtRuleNode: p,\n            isKeyframeAtRuleKeywords: o,\n            isWideKeywords: i,\n            isLastNode: h,\n            isSCSSControlDirectiveNode: l,\n            isDetachedRulesetDeclarationNode: w,\n            isRelationalOperatorNode: F,\n            isEqualityOperatorNode: g,\n            isMultiplicationNode: B,\n            isDivisionNode: I,\n            isAdditionNode: k,\n            isSubtractionNode: P,\n            isModuloNode: C,\n            isMathOperatorNode: D,\n            isEachKeywordNode: S,\n            isForKeywordNode: T,\n            isURLFunctionNode: f,\n            isIfElseKeywordNode: A,\n            hasComposesNode: b,\n            hasParensAroundNode: L,\n            hasEmptyRawBefore: M,\n            isDetachedRulesetCallNode: E,\n            isTemplatePlaceholderNode: y,\n            isTemplatePropNode: N,\n            isPostcssSimpleVarNode: x,\n            isKeyValuePairNode: j,\n            isKeyValuePairInParenGroupNode: $,\n            isKeyInValuePairNode: te,\n            isSCSSMapItemNode: V,\n            isInlineValueCommentNode: q,\n            isHashNode: Y,\n            isLeftCurlyBraceNode: H,\n            isRightCurlyBraceNode: R,\n            isWordNode: Q,\n            isColonNode: ee,\n            isMediaAndSupportsKeywords: oe,\n            isColorAdjusterFuncNode: W,\n            lastLineHasInlineComment: X,\n            isAtWordPlaceholderNode: ue,\n            isConfigurationNode: De,\n            isParenGroupNode: ie\n          };\n        }\n      }),\n      pd = Z({\n        \"src/utils/line-column-to-index.js\"(e, n) {\n          \"use strict\";\n\n          re(), n.exports = function (t, s) {\n            let a = 0;\n            for (let r = 0; r < t.line - 1; ++r) a = s.indexOf(`\n`, a) + 1;\n            return a + t.column;\n          };\n        }\n      }),\n      fd = Z({\n        \"src/language-css/loc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              skipEverythingButNewLine: t\n            } = Nr(),\n            s = it(),\n            a = pd();\n          function r(p, f) {\n            return typeof p.sourceIndex == \"number\" ? p.sourceIndex : p.source ? a(p.source.start, f) - 1 : null;\n          }\n          function u(p, f) {\n            if (p.type === \"css-comment\" && p.inline) return t(f, p.source.startOffset);\n            let h = p.nodes && s(p.nodes);\n            return h && p.source && !p.source.end && (p = h), p.source && p.source.end ? a(p.source.end, f) : null;\n          }\n          function i(p, f) {\n            p.source && (p.source.startOffset = r(p, f), p.source.endOffset = u(p, f));\n            for (let h in p) {\n              let w = p[h];\n              h === \"source\" || !w || typeof w != \"object\" || (w.type === \"value-root\" || w.type === \"value-unknown\" ? o(w, c(p), w.text || w.value) : i(w, f));\n            }\n          }\n          function o(p, f, h) {\n            p.source && (p.source.startOffset = r(p, h) + f, p.source.endOffset = u(p, h) + f);\n            for (let w in p) {\n              let T = p[w];\n              w === \"source\" || !T || typeof T != \"object\" || o(T, f, h);\n            }\n          }\n          function c(p) {\n            let f = p.source.startOffset;\n            return typeof p.prop == \"string\" && (f += p.prop.length), p.type === \"css-atrule\" && typeof p.name == \"string\" && (f += 1 + p.name.length + p.raws.afterName.match(/^\\s*:?\\s*/)[0].length), p.type !== \"css-atrule\" && p.raws && typeof p.raws.between == \"string\" && (f += p.raws.between.length), f;\n          }\n          function v(p) {\n            let f = \"initial\",\n              h = \"initial\",\n              w,\n              T = !1,\n              A = [];\n            for (let S = 0; S < p.length; S++) {\n              let B = p[S];\n              switch (f) {\n                case \"initial\":\n                  if (B === \"'\") {\n                    f = \"single-quotes\";\n                    continue;\n                  }\n                  if (B === '\"') {\n                    f = \"double-quotes\";\n                    continue;\n                  }\n                  if ((B === \"u\" || B === \"U\") && p.slice(S, S + 4).toLowerCase() === \"url(\") {\n                    f = \"url\", S += 3;\n                    continue;\n                  }\n                  if (B === \"*\" && p[S - 1] === \"/\") {\n                    f = \"comment-block\";\n                    continue;\n                  }\n                  if (B === \"/\" && p[S - 1] === \"/\") {\n                    f = \"comment-inline\", w = S - 1;\n                    continue;\n                  }\n                  continue;\n                case \"single-quotes\":\n                  if (B === \"'\" && p[S - 1] !== \"\\\\\" && (f = h, h = \"initial\"), B === `\n` || B === \"\\r\") return p;\n                  continue;\n                case \"double-quotes\":\n                  if (B === '\"' && p[S - 1] !== \"\\\\\" && (f = h, h = \"initial\"), B === `\n` || B === \"\\r\") return p;\n                  continue;\n                case \"url\":\n                  if (B === \")\" && (f = \"initial\"), B === `\n` || B === \"\\r\") return p;\n                  if (B === \"'\") {\n                    f = \"single-quotes\", h = \"url\";\n                    continue;\n                  }\n                  if (B === '\"') {\n                    f = \"double-quotes\", h = \"url\";\n                    continue;\n                  }\n                  continue;\n                case \"comment-block\":\n                  B === \"/\" && p[S - 1] === \"*\" && (f = \"initial\");\n                  continue;\n                case \"comment-inline\":\n                  (B === '\"' || B === \"'\" || B === \"*\") && (T = !0), (B === `\n` || B === \"\\r\") && (T && A.push([w, S]), f = \"initial\", T = !1);\n                  continue;\n              }\n            }\n            for (let [S, B] of A) p = p.slice(0, S) + p.slice(S, B).replace(/[\"'*]/g, \" \") + p.slice(B);\n            return p;\n          }\n          function m(p) {\n            return p.source.startOffset;\n          }\n          function d(p) {\n            return p.source.endOffset;\n          }\n          n.exports = {\n            locStart: m,\n            locEnd: d,\n            calculateLoc: i,\n            replaceQuotesInInlineComments: v\n          };\n        }\n      }),\n      Dd = Z({\n        \"src/language-css/utils/is-less-parser.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s) {\n            return s.parser === \"css\" || s.parser === \"less\";\n          }\n          n.exports = t;\n        }\n      }),\n      md = Z({\n        \"src/language-css/utils/is-scss.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s, a) {\n            return s === \"less\" || s === \"scss\" ? s === \"scss\" : /(?:\\w\\s*:\\s*[^:}]+|#){|@import[^\\n]+(?:url|,)/.test(a);\n          }\n          n.exports = t;\n        }\n      }),\n      dd = Z({\n        \"src/language-css/utils/css-units.evaluate.js\"(e, n) {\n          n.exports = {\n            em: \"em\",\n            rem: \"rem\",\n            ex: \"ex\",\n            rex: \"rex\",\n            cap: \"cap\",\n            rcap: \"rcap\",\n            ch: \"ch\",\n            rch: \"rch\",\n            ic: \"ic\",\n            ric: \"ric\",\n            lh: \"lh\",\n            rlh: \"rlh\",\n            vw: \"vw\",\n            svw: \"svw\",\n            lvw: \"lvw\",\n            dvw: \"dvw\",\n            vh: \"vh\",\n            svh: \"svh\",\n            lvh: \"lvh\",\n            dvh: \"dvh\",\n            vi: \"vi\",\n            svi: \"svi\",\n            lvi: \"lvi\",\n            dvi: \"dvi\",\n            vb: \"vb\",\n            svb: \"svb\",\n            lvb: \"lvb\",\n            dvb: \"dvb\",\n            vmin: \"vmin\",\n            svmin: \"svmin\",\n            lvmin: \"lvmin\",\n            dvmin: \"dvmin\",\n            vmax: \"vmax\",\n            svmax: \"svmax\",\n            lvmax: \"lvmax\",\n            dvmax: \"dvmax\",\n            cm: \"cm\",\n            mm: \"mm\",\n            q: \"Q\",\n            in: \"in\",\n            pt: \"pt\",\n            pc: \"pc\",\n            px: \"px\",\n            deg: \"deg\",\n            grad: \"grad\",\n            rad: \"rad\",\n            turn: \"turn\",\n            s: \"s\",\n            ms: \"ms\",\n            hz: \"Hz\",\n            khz: \"kHz\",\n            dpi: \"dpi\",\n            dpcm: \"dpcm\",\n            dppx: \"dppx\",\n            x: \"x\"\n          };\n        }\n      }),\n      gd = Z({\n        \"src/language-css/utils/print-unit.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = dd();\n          function s(a) {\n            let r = a.toLowerCase();\n            return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : a;\n          }\n          n.exports = s;\n        }\n      }),\n      yd = Z({\n        \"src/language-css/printer-postcss.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = it(),\n            {\n              printNumber: s,\n              printString: a,\n              hasNewline: r,\n              isFrontMatterNode: u,\n              isNextLineEmpty: i,\n              isNonEmptyArray: o\n            } = Ue(),\n            {\n              builders: {\n                join: c,\n                line: v,\n                hardline: m,\n                softline: d,\n                group: p,\n                fill: f,\n                indent: h,\n                dedent: w,\n                ifBreak: T,\n                breakParent: A\n              },\n              utils: {\n                removeLines: S,\n                getDocParts: B\n              }\n            } = Oe(),\n            I = ad(),\n            k = od(),\n            {\n              insertPragma: P\n            } = ld(),\n            {\n              getAncestorNode: C,\n              getPropOfDeclNode: D,\n              maybeToLowerCase: g,\n              insideValueFunctionNode: F,\n              insideICSSRuleNode: l,\n              insideAtRuleNode: E,\n              insideURLFunctionInImportAtRuleNode: y,\n              isKeyframeAtRuleKeywords: N,\n              isWideKeywords: x,\n              isLastNode: b,\n              isSCSSControlDirectiveNode: L,\n              isDetachedRulesetDeclarationNode: M,\n              isRelationalOperatorNode: j,\n              isEqualityOperatorNode: $,\n              isMultiplicationNode: V,\n              isDivisionNode: q,\n              isAdditionNode: Y,\n              isSubtractionNode: H,\n              isMathOperatorNode: R,\n              isEachKeywordNode: Q,\n              isForKeywordNode: ee,\n              isURLFunctionNode: te,\n              isIfElseKeywordNode: oe,\n              hasComposesNode: W,\n              hasParensAroundNode: X,\n              hasEmptyRawBefore: ue,\n              isKeyValuePairNode: De,\n              isKeyInValuePairNode: ie,\n              isDetachedRulesetCallNode: G,\n              isTemplatePlaceholderNode: z,\n              isTemplatePropNode: U,\n              isPostcssSimpleVarNode: le,\n              isSCSSMapItemNode: ge,\n              isInlineValueCommentNode: Ae,\n              isHashNode: Ne,\n              isLeftCurlyBraceNode: ke,\n              isRightCurlyBraceNode: ce,\n              isWordNode: pe,\n              isColonNode: de,\n              isMediaAndSupportsKeywords: ae,\n              isColorAdjusterFuncNode: ve,\n              lastLineHasInlineComment: K,\n              isAtWordPlaceholderNode: he,\n              isConfigurationNode: ye,\n              isParenGroupNode: Ce\n            } = cd(),\n            {\n              locStart: Ie,\n              locEnd: Fe\n            } = fd(),\n            me = Dd(),\n            _ = md(),\n            J = gd();\n          function ne(be) {\n            return be.trailingComma === \"es5\" || be.trailingComma === \"all\";\n          }\n          function Ee(be, Le, qe) {\n            let se = be.getValue();\n            if (!se) return \"\";\n            if (typeof se == \"string\") return se;\n            switch (se.type) {\n              case \"front-matter\":\n                return [se.raw, m];\n              case \"css-root\":\n                {\n                  let He = We(be, Le, qe),\n                    Me = se.raws.after.trim();\n                  return [He, Me ? \" \".concat(Me) : \"\", B(He).length > 0 ? m : \"\"];\n                }\n              case \"css-comment\":\n                {\n                  let He = se.inline || se.raws.inline,\n                    Me = Le.originalText.slice(Ie(se), Fe(se));\n                  return He ? Me.trimEnd() : Me;\n                }\n              case \"css-rule\":\n                return [qe(\"selector\"), se.important ? \" !important\" : \"\", se.nodes ? [se.selector && se.selector.type === \"selector-unknown\" && K(se.selector.value) ? v : \" \", \"{\", se.nodes.length > 0 ? h([m, We(be, Le, qe)]) : \"\", m, \"}\", M(se) ? \";\" : \"\"] : \";\"];\n              case \"css-decl\":\n                {\n                  let He = be.getParentNode(),\n                    {\n                      between: Me\n                    } = se.raws,\n                    ze = Me.trim(),\n                    nt = ze === \":\",\n                    tt = W(se) ? S(qe(\"value\")) : qe(\"value\");\n                  return !nt && K(ze) && (tt = h([m, w(tt)])), [se.raws.before.replace(/[\\s;]/g, \"\"), l(be) ? se.prop : g(se.prop), ze.startsWith(\"//\") ? \" \" : \"\", ze, se.extend ? \"\" : \" \", me(Le) && se.extend && se.selector ? [\"extend(\", qe(\"selector\"), \")\"] : \"\", tt, se.raws.important ? se.raws.important.replace(/\\s*!\\s*important/i, \" !important\") : se.important ? \" !important\" : \"\", se.raws.scssDefault ? se.raws.scssDefault.replace(/\\s*!default/i, \" !default\") : se.scssDefault ? \" !default\" : \"\", se.raws.scssGlobal ? se.raws.scssGlobal.replace(/\\s*!global/i, \" !global\") : se.scssGlobal ? \" !global\" : \"\", se.nodes ? [\" {\", h([d, We(be, Le, qe)]), d, \"}\"] : U(se) && !He.raws.semicolon && Le.originalText[Fe(se) - 1] !== \";\" ? \"\" : Le.__isHTMLStyleAttribute && b(be, se) ? T(\";\") : \";\"];\n                }\n              case \"css-atrule\":\n                {\n                  let He = be.getParentNode(),\n                    Me = z(se) && !He.raws.semicolon && Le.originalText[Fe(se) - 1] !== \";\";\n                  if (me(Le)) {\n                    if (se.mixin) return [qe(\"selector\"), se.important ? \" !important\" : \"\", Me ? \"\" : \";\"];\n                    if (se.function) return [se.name, qe(\"params\"), Me ? \"\" : \";\"];\n                    if (se.variable) return [\"@\", se.name, \": \", se.value ? qe(\"value\") : \"\", se.raws.between.trim() ? se.raws.between.trim() + \" \" : \"\", se.nodes ? [\"{\", h([se.nodes.length > 0 ? d : \"\", We(be, Le, qe)]), d, \"}\"] : \"\", Me ? \"\" : \";\"];\n                  }\n                  return [\"@\", G(se) || se.name.endsWith(\":\") ? se.name : g(se.name), se.params ? [G(se) ? \"\" : z(se) ? se.raws.afterName === \"\" ? \"\" : se.name.endsWith(\":\") ? \" \" : /^\\s*\\n\\s*\\n/.test(se.raws.afterName) ? [m, m] : /^\\s*\\n/.test(se.raws.afterName) ? m : \" \" : \" \", qe(\"params\")] : \"\", se.selector ? h([\" \", qe(\"selector\")]) : \"\", se.value ? p([\" \", qe(\"value\"), L(se) ? X(se) ? \" \" : v : \"\"]) : se.name === \"else\" ? \" \" : \"\", se.nodes ? [L(se) ? \"\" : se.selector && !se.selector.nodes && typeof se.selector.value == \"string\" && K(se.selector.value) || !se.selector && typeof se.params == \"string\" && K(se.params) ? v : \" \", \"{\", h([se.nodes.length > 0 ? d : \"\", We(be, Le, qe)]), d, \"}\"] : Me ? \"\" : \";\"];\n                }\n              case \"media-query-list\":\n                {\n                  let He = [];\n                  return be.each(Me => {\n                    let ze = Me.getValue();\n                    ze.type === \"media-query\" && ze.value === \"\" || He.push(qe());\n                  }, \"nodes\"), p(h(c(v, He)));\n                }\n              case \"media-query\":\n                return [c(\" \", be.map(qe, \"nodes\")), b(be, se) ? \"\" : \",\"];\n              case \"media-type\":\n                return je(Xe(se.value, Le));\n              case \"media-feature-expression\":\n                return se.nodes ? [\"(\", ...be.map(qe, \"nodes\"), \")\"] : se.value;\n              case \"media-feature\":\n                return g(Xe(se.value.replace(/ +/g, \" \"), Le));\n              case \"media-colon\":\n                return [se.value, \" \"];\n              case \"media-value\":\n                return je(Xe(se.value, Le));\n              case \"media-keyword\":\n                return Xe(se.value, Le);\n              case \"media-url\":\n                return Xe(se.value.replace(/^url\\(\\s+/gi, \"url(\").replace(/\\s+\\)$/g, \")\"), Le);\n              case \"media-unknown\":\n                return se.value;\n              case \"selector-root\":\n                return p([E(be, \"custom-selector\") ? [C(be, \"css-atrule\").customSelector, v] : \"\", c([\",\", E(be, [\"extend\", \"custom-selector\", \"nest\"]) ? v : m], be.map(qe, \"nodes\"))]);\n              case \"selector-selector\":\n                return p(h(be.map(qe, \"nodes\")));\n              case \"selector-comment\":\n                return se.value;\n              case \"selector-string\":\n                return Xe(se.value, Le);\n              case \"selector-tag\":\n                {\n                  let He = be.getParentNode(),\n                    Me = He && He.nodes.indexOf(se),\n                    ze = Me && He.nodes[Me - 1];\n                  return [se.namespace ? [se.namespace === !0 ? \"\" : se.namespace.trim(), \"|\"] : \"\", ze.type === \"selector-nesting\" ? se.value : je(N(be, se.value) ? se.value.toLowerCase() : se.value)];\n                }\n              case \"selector-id\":\n                return [\"#\", se.value];\n              case \"selector-class\":\n                return [\".\", je(Xe(se.value, Le))];\n              case \"selector-attribute\":\n                return [\"[\", se.namespace ? [se.namespace === !0 ? \"\" : se.namespace.trim(), \"|\"] : \"\", se.attribute.trim(), se.operator ? se.operator : \"\", se.value ? _e(Xe(se.value.trim(), Le), Le) : \"\", se.insensitive ? \" i\" : \"\", \"]\"];\n              case \"selector-combinator\":\n                {\n                  if (se.value === \"+\" || se.value === \">\" || se.value === \"~\" || se.value === \">>>\") {\n                    let ze = be.getParentNode();\n                    return [ze.type === \"selector-selector\" && ze.nodes[0] === se ? \"\" : v, se.value, b(be, se) ? \"\" : \" \"];\n                  }\n                  let He = se.value.trim().startsWith(\"(\") ? v : \"\",\n                    Me = je(Xe(se.value.trim(), Le)) || v;\n                  return [He, Me];\n                }\n              case \"selector-universal\":\n                return [se.namespace ? [se.namespace === !0 ? \"\" : se.namespace.trim(), \"|\"] : \"\", se.value];\n              case \"selector-pseudo\":\n                return [g(se.value), o(se.nodes) ? [\"(\", c(\", \", be.map(qe, \"nodes\")), \")\"] : \"\"];\n              case \"selector-nesting\":\n                return se.value;\n              case \"selector-unknown\":\n                {\n                  let He = C(be, \"css-rule\");\n                  if (He && He.isSCSSNesterProperty) return je(Xe(g(se.value), Le));\n                  let Me = be.getParentNode();\n                  if (Me.raws && Me.raws.selector) {\n                    let nt = Ie(Me),\n                      tt = nt + Me.raws.selector.length;\n                    return Le.originalText.slice(nt, tt).trim();\n                  }\n                  let ze = be.getParentNode(1);\n                  if (Me.type === \"value-paren_group\" && ze && ze.type === \"value-func\" && ze.value === \"selector\") {\n                    let nt = Fe(Me.open) + 1,\n                      tt = Ie(Me.close),\n                      pt = Le.originalText.slice(nt, tt).trim();\n                    return K(pt) ? [A, pt] : pt;\n                  }\n                  return se.value;\n                }\n              case \"value-value\":\n              case \"value-root\":\n                return qe(\"group\");\n              case \"value-comment\":\n                return Le.originalText.slice(Ie(se), Fe(se));\n              case \"value-comma_group\":\n                {\n                  let He = be.getParentNode(),\n                    Me = be.getParentNode(1),\n                    ze = D(be),\n                    nt = ze && He.type === \"value-value\" && (ze === \"grid\" || ze.startsWith(\"grid-template\")),\n                    tt = C(be, \"css-atrule\"),\n                    pt = tt && L(tt),\n                    O = se.groups.some(ut => Ae(ut)),\n                    fe = be.map(qe, \"groups\"),\n                    Te = [],\n                    $e = F(be, \"url\"),\n                    Je = !1,\n                    Ze = !1;\n                  for (let ut = 0; ut < se.groups.length; ++ut) {\n                    Te.push(fe[ut]);\n                    let rt = se.groups[ut - 1],\n                      Ve = se.groups[ut],\n                      Ge = se.groups[ut + 1],\n                      tr = se.groups[ut + 2];\n                    if ($e) {\n                      (Ge && Y(Ge) || Y(Ve)) && Te.push(\" \");\n                      continue;\n                    }\n                    if (E(be, \"forward\") && Ve.type === \"value-word\" && Ve.value && rt !== void 0 && rt.type === \"value-word\" && rt.value === \"as\" && Ge.type === \"value-operator\" && Ge.value === \"*\" || !Ge || Ve.type === \"value-word\" && Ve.value.endsWith(\"-\") && he(Ge)) continue;\n                    let Eo = Ve.type === \"value-string\" && Ve.value.startsWith(\"#{\"),\n                      Fo = Je && Ge.type === \"value-string\" && Ge.value.endsWith(\"}\");\n                    if (Eo || Fo) {\n                      Je = !Je;\n                      continue;\n                    }\n                    if (Je || de(Ve) || de(Ge) || Ve.type === \"value-atword\" && Ve.value === \"\" || Ve.value === \"~\" || Ve.value && Ve.value.includes(\"\\\\\") && Ge && Ge.type !== \"value-comment\" || rt && rt.value && rt.value.indexOf(\"\\\\\") === rt.value.length - 1 && Ve.type === \"value-operator\" && Ve.value === \"/\" || Ve.value === \"\\\\\" || le(Ve, Ge) || Ne(Ve) || ke(Ve) || ce(Ge) || ke(Ge) && ue(Ge) || ce(Ve) && ue(Ge) || Ve.value === \"--\" && Ne(Ge)) continue;\n                    let Qn = R(Ve),\n                      Zn = R(Ge);\n                    if ((Qn && Ne(Ge) || Zn && ce(Ve)) && ue(Ge) || !rt && q(Ve) || F(be, \"calc\") && (Y(Ve) || Y(Ge) || H(Ve) || H(Ge)) && ue(Ge)) continue;\n                    let Ao = (Y(Ve) || H(Ve)) && ut === 0 && (Ge.type === \"value-number\" || Ge.isHex) && Me && ve(Me) && !ue(Ge),\n                      eu = tr && tr.type === \"value-func\" || tr && pe(tr) || Ve.type === \"value-func\" || pe(Ve),\n                      tu = Ge.type === \"value-func\" || pe(Ge) || rt && rt.type === \"value-func\" || rt && pe(rt);\n                    if (!(!(V(Ge) || V(Ve)) && !F(be, \"calc\") && !Ao && (q(Ge) && !eu || q(Ve) && !tu || Y(Ge) && !eu || Y(Ve) && !tu || H(Ge) || H(Ve)) && (ue(Ge) || Qn && (!rt || rt && R(rt))))) {\n                      if (Ae(Ve)) {\n                        if (He.type === \"value-paren_group\") {\n                          Te.push(w(m));\n                          continue;\n                        }\n                        Te.push(m);\n                        continue;\n                      }\n                      if (pt && ($(Ge) || j(Ge) || oe(Ge) || Q(Ve) || ee(Ve))) {\n                        Te.push(\" \");\n                        continue;\n                      }\n                      if (tt && tt.name.toLowerCase() === \"namespace\") {\n                        Te.push(\" \");\n                        continue;\n                      }\n                      if (nt) {\n                        Ve.source && Ge.source && Ve.source.start.line !== Ge.source.start.line ? (Te.push(m), Ze = !0) : Te.push(\" \");\n                        continue;\n                      }\n                      if (Zn) {\n                        Te.push(\" \");\n                        continue;\n                      }\n                      if (!(Ge && Ge.value === \"...\") && !(he(Ve) && he(Ge) && Fe(Ve) === Ie(Ge))) {\n                        if (he(Ve) && Ce(Ge) && Fe(Ve) === Ie(Ge.open)) {\n                          Te.push(d);\n                          continue;\n                        }\n                        if (Ve.value === \"with\" && Ce(Ge)) {\n                          Te.push(\" \");\n                          continue;\n                        }\n                        Te.push(v);\n                      }\n                    }\n                  }\n                  return O && Te.push(A), Ze && Te.unshift(m), pt ? p(h(Te)) : y(be) ? p(f(Te)) : p(h(f(Te)));\n                }\n              case \"value-paren_group\":\n                {\n                  let He = be.getParentNode();\n                  if (He && te(He) && (se.groups.length === 1 || se.groups.length > 0 && se.groups[0].type === \"value-comma_group\" && se.groups[0].groups.length > 0 && se.groups[0].groups[0].type === \"value-word\" && se.groups[0].groups[0].value.startsWith(\"data:\"))) return [se.open ? qe(\"open\") : \"\", c(\",\", be.map(qe, \"groups\")), se.close ? qe(\"close\") : \"\"];\n                  if (!se.open) {\n                    let $e = be.map(qe, \"groups\"),\n                      Je = [];\n                    for (let Ze = 0; Ze < $e.length; Ze++) Ze !== 0 && Je.push([\",\", v]), Je.push($e[Ze]);\n                    return p(h(f(Je)));\n                  }\n                  let Me = ge(be),\n                    ze = t(se.groups),\n                    nt = ze && ze.type === \"value-comment\",\n                    tt = ie(se, He),\n                    pt = ye(se, He),\n                    O = pt || Me && !tt,\n                    fe = pt || tt,\n                    Te = p([se.open ? qe(\"open\") : \"\", h([d, c([v], be.map(($e, Je) => {\n                      let Ze = $e.getValue(),\n                        ut = Je === se.groups.length - 1,\n                        rt = [qe(), ut ? \"\" : \",\"];\n                      if (De(Ze) && Ze.type === \"value-comma_group\" && Ze.groups && Ze.groups[0].type !== \"value-paren_group\" && Ze.groups[2] && Ze.groups[2].type === \"value-paren_group\") {\n                        let Ve = B(rt[0].contents.contents);\n                        return Ve[1] = p(Ve[1]), p(w(rt));\n                      }\n                      if (!ut && Ze.type === \"value-comma_group\" && o(Ze.groups)) {\n                        let Ve = t(Ze.groups);\n                        Ve.source && i(Le.originalText, Ve, Fe) && rt.push(m);\n                      }\n                      return rt;\n                    }, \"groups\"))]), T(!nt && _(Le.parser, Le.originalText) && Me && ne(Le) ? \",\" : \"\"), d, se.close ? qe(\"close\") : \"\"], {\n                      shouldBreak: O\n                    });\n                  return fe ? w(Te) : Te;\n                }\n              case \"value-func\":\n                return [se.value, E(be, \"supports\") && ae(se) ? \" \" : \"\", qe(\"group\")];\n              case \"value-paren\":\n                return se.value;\n              case \"value-number\":\n                return [Re(se.value), J(se.unit)];\n              case \"value-operator\":\n                return se.value;\n              case \"value-word\":\n                return se.isColor && se.isHex || x(se.value) ? se.value.toLowerCase() : se.value;\n              case \"value-colon\":\n                {\n                  let He = be.getParentNode(),\n                    Me = He && He.groups.indexOf(se),\n                    ze = Me && He.groups[Me - 1];\n                  return [se.value, ze && typeof ze.value == \"string\" && t(ze.value) === \"\\\\\" || F(be, \"url\") ? \"\" : v];\n                }\n              case \"value-comma\":\n                return [se.value, \" \"];\n              case \"value-string\":\n                return a(se.raws.quote + se.value + se.raws.quote, Le);\n              case \"value-atword\":\n                return [\"@\", se.value];\n              case \"value-unicode-range\":\n                return se.value;\n              case \"value-unknown\":\n                return se.value;\n              default:\n                throw new Error(\"Unknown postcss type \".concat(JSON.stringify(se.type)));\n            }\n          }\n          function We(be, Le, qe) {\n            let se = [];\n            return be.each((He, Me, ze) => {\n              let nt = ze[Me - 1];\n              if (nt && nt.type === \"css-comment\" && nt.text.trim() === \"prettier-ignore\") {\n                let tt = He.getValue();\n                se.push(Le.originalText.slice(Ie(tt), Fe(tt)));\n              } else se.push(qe());\n              Me !== ze.length - 1 && (ze[Me + 1].type === \"css-comment\" && !r(Le.originalText, Ie(ze[Me + 1]), {\n                backwards: !0\n              }) && !u(ze[Me]) || ze[Me + 1].type === \"css-atrule\" && ze[Me + 1].name === \"else\" && ze[Me].type !== \"css-comment\" ? se.push(\" \") : (se.push(Le.__isHTMLStyleAttribute ? v : m), i(Le.originalText, He.getValue(), Fe) && !u(ze[Me]) && se.push(m)));\n            }, \"nodes\"), se;\n          }\n          var Be = /([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*\\1/gs,\n            Pe = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[Ee][+-]?\\d+)?/g,\n            Se = /[A-Za-z]+/g,\n            Qe = /[$@]?[A-Z_a-z\\u0080-\\uFFFF][\\w\\u0080-\\uFFFF-]*/g,\n            xe = new RegExp(Be.source + \"|(\".concat(Qe.source, \")?(\").concat(Pe.source, \")(\").concat(Se.source, \")?\"), \"g\");\n          function Xe(be, Le) {\n            return be.replace(Be, qe => a(qe, Le));\n          }\n          function _e(be, Le) {\n            let qe = Le.singleQuote ? \"'\" : '\"';\n            return be.includes('\"') || be.includes(\"'\") ? be : qe + be + qe;\n          }\n          function je(be) {\n            return be.replace(xe, (Le, qe, se, He, Me) => !se && He ? Re(He) + g(Me || \"\") : Le);\n          }\n          function Re(be) {\n            return s(be).replace(/\\.0(?=$|e)/, \"\");\n          }\n          n.exports = {\n            print: Ee,\n            embed: k,\n            insertPragma: P,\n            massageAstNode: I\n          };\n        }\n      }),\n      hd = Z({\n        \"src/language-css/options.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Ot();\n          n.exports = {\n            singleQuote: t.singleQuote\n          };\n        }\n      }),\n      vd = Z({\n        \"src/language-css/parsers.js\"() {\n          re();\n        }\n      }),\n      Cd = Z({\n        \"node_modules/linguist-languages/data/CSS.json\"(e, n) {\n          n.exports = {\n            name: \"CSS\",\n            type: \"markup\",\n            tmScope: \"source.css\",\n            aceMode: \"css\",\n            codemirrorMode: \"css\",\n            codemirrorMimeType: \"text/css\",\n            color: \"#563d7c\",\n            extensions: [\".css\"],\n            languageId: 50\n          };\n        }\n      }),\n      Ed = Z({\n        \"node_modules/linguist-languages/data/PostCSS.json\"(e, n) {\n          n.exports = {\n            name: \"PostCSS\",\n            type: \"markup\",\n            color: \"#dc3a0c\",\n            tmScope: \"source.postcss\",\n            group: \"CSS\",\n            extensions: [\".pcss\", \".postcss\"],\n            aceMode: \"text\",\n            languageId: 262764437\n          };\n        }\n      }),\n      Fd = Z({\n        \"node_modules/linguist-languages/data/Less.json\"(e, n) {\n          n.exports = {\n            name: \"Less\",\n            type: \"markup\",\n            color: \"#1d365d\",\n            aliases: [\"less-css\"],\n            extensions: [\".less\"],\n            tmScope: \"source.css.less\",\n            aceMode: \"less\",\n            codemirrorMode: \"css\",\n            codemirrorMimeType: \"text/css\",\n            languageId: 198\n          };\n        }\n      }),\n      Ad = Z({\n        \"node_modules/linguist-languages/data/SCSS.json\"(e, n) {\n          n.exports = {\n            name: \"SCSS\",\n            type: \"markup\",\n            color: \"#c6538c\",\n            tmScope: \"source.css.scss\",\n            aceMode: \"scss\",\n            codemirrorMode: \"css\",\n            codemirrorMimeType: \"text/x-scss\",\n            extensions: [\".scss\"],\n            languageId: 329\n          };\n        }\n      }),\n      Sd = Z({\n        \"src/language-css/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Bt(),\n            s = yd(),\n            a = hd(),\n            r = vd(),\n            u = [t(Cd(), o => ({\n              since: \"1.4.0\",\n              parsers: [\"css\"],\n              vscodeLanguageIds: [\"css\"],\n              extensions: [...o.extensions, \".wxss\"]\n            })), t(Ed(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"css\"],\n              vscodeLanguageIds: [\"postcss\"]\n            })), t(Fd(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"less\"],\n              vscodeLanguageIds: [\"less\"]\n            })), t(Ad(), () => ({\n              since: \"1.4.0\",\n              parsers: [\"scss\"],\n              vscodeLanguageIds: [\"scss\"]\n            }))],\n            i = {\n              postcss: s\n            };\n          n.exports = {\n            languages: u,\n            options: a,\n            printers: i,\n            parsers: r\n          };\n        }\n      }),\n      xd = Z({\n        \"src/language-handlebars/loc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(a) {\n            return a.loc.start.offset;\n          }\n          function s(a) {\n            return a.loc.end.offset;\n          }\n          n.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      bd = Z({\n        \"src/language-handlebars/clean.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s, a) {\n            if (s.type === \"TextNode\") {\n              let r = s.chars.trim();\n              if (!r) return null;\n              a.chars = r.replace(/[\\t\\n\\f\\r ]+/g, \" \");\n            }\n            s.type === \"AttrNode\" && s.name.toLowerCase() === \"class\" && delete a.value;\n          }\n          t.ignoredProperties = new Set([\"loc\", \"selfClosing\"]), n.exports = t;\n        }\n      }),\n      Td = Z({\n        \"vendors/html-void-elements.json\"(e, n) {\n          n.exports = {\n            htmlVoidElements: [\"area\", \"base\", \"basefont\", \"bgsound\", \"br\", \"col\", \"command\", \"embed\", \"frame\", \"hr\", \"image\", \"img\", \"input\", \"isindex\", \"keygen\", \"link\", \"menuitem\", \"meta\", \"nextid\", \"param\", \"source\", \"track\", \"wbr\"]\n          };\n        }\n      }),\n      Bd = Z({\n        \"src/language-handlebars/utils.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              htmlVoidElements: t\n            } = Td(),\n            s = it();\n          function a(S) {\n            let B = S.getValue(),\n              I = S.getParentNode(0);\n            return !!(m(S, [\"ElementNode\"]) && s(I.children) === B || m(S, [\"Block\"]) && s(I.body) === B);\n          }\n          function r(S) {\n            return S.toUpperCase() === S;\n          }\n          function u(S) {\n            return v(S, [\"ElementNode\"]) && typeof S.tag == \"string\" && !S.tag.startsWith(\":\") && (r(S.tag[0]) || S.tag.includes(\".\"));\n          }\n          var i = new Set(t);\n          function o(S) {\n            return i.has(S.tag) || u(S) && S.children.every(B => c(B));\n          }\n          function c(S) {\n            return v(S, [\"TextNode\"]) && !/\\S/.test(S.chars);\n          }\n          function v(S, B) {\n            return S && B.includes(S.type);\n          }\n          function m(S, B) {\n            let I = S.getParentNode(0);\n            return v(I, B);\n          }\n          function d(S, B) {\n            let I = h(S);\n            return v(I, B);\n          }\n          function p(S, B) {\n            let I = w(S);\n            return v(I, B);\n          }\n          function f(S, B) {\n            var I, k, P, C;\n            let D = S.getValue(),\n              g = (I = S.getParentNode(0)) !== null && I !== void 0 ? I : {},\n              F = (k = (P = (C = g.children) !== null && C !== void 0 ? C : g.body) !== null && P !== void 0 ? P : g.parts) !== null && k !== void 0 ? k : [],\n              l = F.indexOf(D);\n            return l !== -1 && F[l + B];\n          }\n          function h(S) {\n            let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n            return f(S, -B);\n          }\n          function w(S) {\n            return f(S, 1);\n          }\n          function T(S) {\n            return v(S, [\"MustacheCommentStatement\"]) && typeof S.value == \"string\" && S.value.trim() === \"prettier-ignore\";\n          }\n          function A(S) {\n            let B = S.getValue(),\n              I = h(S, 2);\n            return T(B) || T(I);\n          }\n          n.exports = {\n            getNextNode: w,\n            getPreviousNode: h,\n            hasPrettierIgnore: A,\n            isLastNodeOfSiblings: a,\n            isNextNodeOfSomeType: p,\n            isNodeOfSomeType: v,\n            isParentOfSomeType: m,\n            isPreviousNodeOfSomeType: d,\n            isVoid: o,\n            isWhitespaceNode: c\n          };\n        }\n      }),\n      Nd = Z({\n        \"src/language-handlebars/printer-glimmer.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                dedent: t,\n                fill: s,\n                group: a,\n                hardline: r,\n                ifBreak: u,\n                indent: i,\n                join: o,\n                line: c,\n                softline: v\n              },\n              utils: {\n                getDocParts: m,\n                replaceTextEndOfLine: d\n              }\n            } = Oe(),\n            {\n              getPreferredQuote: p,\n              isNonEmptyArray: f\n            } = Ue(),\n            {\n              locStart: h,\n              locEnd: w\n            } = xd(),\n            T = bd(),\n            {\n              getNextNode: A,\n              getPreviousNode: S,\n              hasPrettierIgnore: B,\n              isLastNodeOfSiblings: I,\n              isNextNodeOfSomeType: k,\n              isNodeOfSomeType: P,\n              isParentOfSomeType: C,\n              isPreviousNodeOfSomeType: D,\n              isVoid: g,\n              isWhitespaceNode: F\n            } = Bd(),\n            l = 2;\n          function E(K, he, ye) {\n            let Ce = K.getValue();\n            if (!Ce) return \"\";\n            if (B(K)) return he.originalText.slice(h(Ce), w(Ce));\n            let Ie = he.singleQuote ? \"'\" : '\"';\n            switch (Ce.type) {\n              case \"Block\":\n              case \"Program\":\n              case \"Template\":\n                return a(K.map(ye, \"body\"));\n              case \"ElementNode\":\n                {\n                  let Fe = a(N(K, ye)),\n                    me = he.htmlWhitespaceSensitivity === \"ignore\" && k(K, [\"ElementNode\"]) ? v : \"\";\n                  if (g(Ce)) return [Fe, me];\n                  let _ = [\"</\", Ce.tag, \">\"];\n                  return Ce.children.length === 0 ? [Fe, i(_), me] : he.htmlWhitespaceSensitivity === \"ignore\" ? [Fe, i(x(K, he, ye)), r, i(_), me] : [Fe, i(a(x(K, he, ye))), i(_), me];\n                }\n              case \"BlockStatement\":\n                {\n                  let Fe = K.getParentNode(1);\n                  return Fe && Fe.inverse && Fe.inverse.body.length === 1 && Fe.inverse.body[0] === Ce && Fe.inverse.body[0].path.parts[0] === \"if\" ? [ee(K, ye), ue(K, ye, he), De(K, ye, he)] : [R(K, ye), a([ue(K, ye, he), De(K, ye, he), te(K, ye, he)])];\n                }\n              case \"ElementModifierStatement\":\n                return a([\"{{\", pe(K, ye), \"}}\"]);\n              case \"MustacheStatement\":\n                return a([L(Ce), pe(K, ye), M(Ce)]);\n              case \"SubExpression\":\n                return a([\"(\", ce(K, ye), v, \")\"]);\n              case \"AttrNode\":\n                {\n                  let Fe = Ce.value.type === \"TextNode\";\n                  if (Fe && Ce.value.chars === \"\" && h(Ce.value) === w(Ce.value)) return Ce.name;\n                  let _ = Fe ? p(Ce.value.chars, Ie).quote : Ce.value.type === \"ConcatStatement\" ? p(Ce.value.parts.filter(ne => ne.type === \"TextNode\").map(ne => ne.chars).join(\"\"), Ie).quote : \"\",\n                    J = ye(\"value\");\n                  return [Ce.name, \"=\", _, Ce.name === \"class\" && _ ? a(i(J)) : J, _];\n                }\n              case \"ConcatStatement\":\n                return K.map(ye, \"parts\");\n              case \"Hash\":\n                return o(c, K.map(ye, \"pairs\"));\n              case \"HashPair\":\n                return [Ce.key, \"=\", ye(\"value\")];\n              case \"TextNode\":\n                {\n                  let Fe = Ce.chars.replace(/{{/g, \"\\\\{{\"),\n                    me = z(K);\n                  if (me) {\n                    if (me === \"class\") {\n                      let xe = Fe.trim().split(/\\s+/).join(\" \"),\n                        Xe = !1,\n                        _e = !1;\n                      return C(K, [\"ConcatStatement\"]) && (D(K, [\"MustacheStatement\"]) && /^\\s/.test(Fe) && (Xe = !0), k(K, [\"MustacheStatement\"]) && /\\s$/.test(Fe) && xe !== \"\" && (_e = !0)), [Xe ? c : \"\", xe, _e ? c : \"\"];\n                    }\n                    return d(Fe);\n                  }\n                  let J = /^[\\t\\n\\f\\r ]*$/.test(Fe),\n                    ne = !S(K),\n                    Ee = !A(K);\n                  if (he.htmlWhitespaceSensitivity !== \"ignore\") {\n                    let xe = /^[\\t\\n\\f\\r ]*/,\n                      Xe = /[\\t\\n\\f\\r ]*$/,\n                      _e = Ee && C(K, [\"Template\"]),\n                      je = ne && C(K, [\"Template\"]);\n                    if (J) {\n                      if (je || _e) return \"\";\n                      let se = [c],\n                        He = U(Fe);\n                      return He && (se = Ae(He)), I(K) && (se = se.map(Me => t(Me))), se;\n                    }\n                    let [Re] = Fe.match(xe),\n                      [be] = Fe.match(Xe),\n                      Le = [];\n                    if (Re) {\n                      Le = [c];\n                      let se = U(Re);\n                      se && (Le = Ae(se)), Fe = Fe.replace(xe, \"\");\n                    }\n                    let qe = [];\n                    if (be) {\n                      if (!_e) {\n                        qe = [c];\n                        let se = U(be);\n                        se && (qe = Ae(se)), I(K) && (qe = qe.map(He => t(He)));\n                      }\n                      Fe = Fe.replace(Xe, \"\");\n                    }\n                    return [...Le, s(ie(Fe)), ...qe];\n                  }\n                  let We = U(Fe),\n                    Be = le(Fe),\n                    Pe = ge(Fe);\n                  if ((ne || Ee) && J && C(K, [\"Block\", \"ElementNode\", \"Template\"])) return \"\";\n                  J && We ? (Be = Math.min(We, l), Pe = 0) : (k(K, [\"BlockStatement\", \"ElementNode\"]) && (Pe = Math.max(Pe, 1)), D(K, [\"BlockStatement\", \"ElementNode\"]) && (Be = Math.max(Be, 1)));\n                  let Se = \"\",\n                    Qe = \"\";\n                  return Pe === 0 && k(K, [\"MustacheStatement\"]) && (Qe = \" \"), Be === 0 && D(K, [\"MustacheStatement\"]) && (Se = \" \"), ne && (Be = 0, Se = \"\"), Ee && (Pe = 0, Qe = \"\"), Fe = Fe.replace(/^[\\t\\n\\f\\r ]+/g, Se).replace(/[\\t\\n\\f\\r ]+$/, Qe), [...Ae(Be), s(ie(Fe)), ...Ae(Pe)];\n                }\n              case \"MustacheCommentStatement\":\n                {\n                  let Fe = h(Ce),\n                    me = w(Ce),\n                    _ = he.originalText.charAt(Fe + 2) === \"~\",\n                    J = he.originalText.charAt(me - 3) === \"~\",\n                    ne = Ce.value.includes(\"}}\") ? \"--\" : \"\";\n                  return [\"{{\", _ ? \"~\" : \"\", \"!\", ne, Ce.value, ne, J ? \"~\" : \"\", \"}}\"];\n                }\n              case \"PathExpression\":\n                return Ce.original;\n              case \"BooleanLiteral\":\n                return String(Ce.value);\n              case \"CommentStatement\":\n                return [\"<!--\", Ce.value, \"-->\"];\n              case \"StringLiteral\":\n                {\n                  if (ke(K)) {\n                    let Fe = he.singleQuote ? '\"' : \"'\";\n                    return Ne(Ce.value, Fe);\n                  }\n                  return Ne(Ce.value, Ie);\n                }\n              case \"NumberLiteral\":\n                return String(Ce.value);\n              case \"UndefinedLiteral\":\n                return \"undefined\";\n              case \"NullLiteral\":\n                return \"null\";\n              default:\n                throw new Error(\"unknown glimmer type: \" + JSON.stringify(Ce.type));\n            }\n          }\n          function y(K, he) {\n            return h(K) - h(he);\n          }\n          function N(K, he) {\n            let ye = K.getValue(),\n              Ce = [\"attributes\", \"modifiers\", \"comments\"].filter(Fe => f(ye[Fe])),\n              Ie = Ce.flatMap(Fe => ye[Fe]).sort(y);\n            for (let Fe of Ce) K.each(me => {\n              let _ = Ie.indexOf(me.getValue());\n              Ie.splice(_, 1, [c, he()]);\n            }, Fe);\n            return f(ye.blockParams) && Ie.push(c, ve(ye)), [\"<\", ye.tag, i(Ie), b(ye)];\n          }\n          function x(K, he, ye) {\n            let Ie = K.getValue().children.every(Fe => F(Fe));\n            return he.htmlWhitespaceSensitivity === \"ignore\" && Ie ? \"\" : K.map((Fe, me) => {\n              let _ = ye();\n              return me === 0 && he.htmlWhitespaceSensitivity === \"ignore\" ? [v, _] : _;\n            }, \"children\");\n          }\n          function b(K) {\n            return g(K) ? u([v, \"/>\"], [\" />\", v]) : u([v, \">\"], \">\");\n          }\n          function L(K) {\n            let he = K.escaped === !1 ? \"{{{\" : \"{{\",\n              ye = K.strip && K.strip.open ? \"~\" : \"\";\n            return [he, ye];\n          }\n          function M(K) {\n            let he = K.escaped === !1 ? \"}}}\" : \"}}\";\n            return [K.strip && K.strip.close ? \"~\" : \"\", he];\n          }\n          function j(K) {\n            let he = L(K),\n              ye = K.openStrip.open ? \"~\" : \"\";\n            return [he, ye, \"#\"];\n          }\n          function $(K) {\n            let he = M(K);\n            return [K.openStrip.close ? \"~\" : \"\", he];\n          }\n          function V(K) {\n            let he = L(K),\n              ye = K.closeStrip.open ? \"~\" : \"\";\n            return [he, ye, \"/\"];\n          }\n          function q(K) {\n            let he = M(K);\n            return [K.closeStrip.close ? \"~\" : \"\", he];\n          }\n          function Y(K) {\n            let he = L(K),\n              ye = K.inverseStrip.open ? \"~\" : \"\";\n            return [he, ye];\n          }\n          function H(K) {\n            let he = M(K);\n            return [K.inverseStrip.close ? \"~\" : \"\", he];\n          }\n          function R(K, he) {\n            let ye = K.getValue(),\n              Ce = j(ye),\n              Ie = $(ye),\n              Fe = [de(K, he)],\n              me = ae(K, he);\n            if (me && Fe.push(c, me), f(ye.program.blockParams)) {\n              let _ = ve(ye.program);\n              Fe.push(c, _);\n            }\n            return a([Ce, i(Fe), v, Ie]);\n          }\n          function Q(K, he) {\n            return [he.htmlWhitespaceSensitivity === \"ignore\" ? r : \"\", Y(K), \"else\", H(K)];\n          }\n          function ee(K, he) {\n            let ye = K.getParentNode(1);\n            return [Y(ye), \"else if \", ae(K, he), H(ye)];\n          }\n          function te(K, he, ye) {\n            let Ce = K.getValue();\n            return ye.htmlWhitespaceSensitivity === \"ignore\" ? [oe(Ce) ? v : r, V(Ce), he(\"path\"), q(Ce)] : [V(Ce), he(\"path\"), q(Ce)];\n          }\n          function oe(K) {\n            return P(K, [\"BlockStatement\"]) && K.program.body.every(he => F(he));\n          }\n          function W(K) {\n            return X(K) && K.inverse.body.length === 1 && P(K.inverse.body[0], [\"BlockStatement\"]) && K.inverse.body[0].path.parts[0] === \"if\";\n          }\n          function X(K) {\n            return P(K, [\"BlockStatement\"]) && K.inverse;\n          }\n          function ue(K, he, ye) {\n            let Ce = K.getValue();\n            if (oe(Ce)) return \"\";\n            let Ie = he(\"program\");\n            return ye.htmlWhitespaceSensitivity === \"ignore\" ? i([r, Ie]) : i(Ie);\n          }\n          function De(K, he, ye) {\n            let Ce = K.getValue(),\n              Ie = he(\"inverse\"),\n              Fe = ye.htmlWhitespaceSensitivity === \"ignore\" ? [r, Ie] : Ie;\n            return W(Ce) ? Fe : X(Ce) ? [Q(Ce, ye), i(Fe)] : \"\";\n          }\n          function ie(K) {\n            return m(o(c, G(K)));\n          }\n          function G(K) {\n            return K.split(/[\\t\\n\\f\\r ]+/);\n          }\n          function z(K) {\n            for (let he = 0; he < 2; he++) {\n              let ye = K.getParentNode(he);\n              if (ye && ye.type === \"AttrNode\") return ye.name.toLowerCase();\n            }\n          }\n          function U(K) {\n            return K = typeof K == \"string\" ? K : \"\", K.split(`\n`).length - 1;\n          }\n          function le(K) {\n            K = typeof K == \"string\" ? K : \"\";\n            let he = (K.match(/^([^\\S\\n\\r]*[\\n\\r])+/g) || [])[0] || \"\";\n            return U(he);\n          }\n          function ge(K) {\n            K = typeof K == \"string\" ? K : \"\";\n            let he = (K.match(/([\\n\\r][^\\S\\n\\r]*)+$/g) || [])[0] || \"\";\n            return U(he);\n          }\n          function Ae() {\n            let K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n            return Array.from({\n              length: Math.min(K, l)\n            }).fill(r);\n          }\n          function Ne(K, he) {\n            let {\n              quote: ye,\n              regex: Ce\n            } = p(K, he);\n            return [ye, K.replace(Ce, \"\\\\\".concat(ye)), ye];\n          }\n          function ke(K) {\n            let he = 0,\n              ye = K.getParentNode(he);\n            for (; ye && P(ye, [\"SubExpression\"]);) he++, ye = K.getParentNode(he);\n            return !!(ye && P(K.getParentNode(he + 1), [\"ConcatStatement\"]) && P(K.getParentNode(he + 2), [\"AttrNode\"]));\n          }\n          function ce(K, he) {\n            let ye = de(K, he),\n              Ce = ae(K, he);\n            return Ce ? i([ye, c, a(Ce)]) : ye;\n          }\n          function pe(K, he) {\n            let ye = de(K, he),\n              Ce = ae(K, he);\n            return Ce ? [i([ye, c, Ce]), v] : ye;\n          }\n          function de(K, he) {\n            return he(\"path\");\n          }\n          function ae(K, he) {\n            let ye = K.getValue(),\n              Ce = [];\n            if (ye.params.length > 0) {\n              let Ie = K.map(he, \"params\");\n              Ce.push(...Ie);\n            }\n            if (ye.hash && ye.hash.pairs.length > 0) {\n              let Ie = he(\"hash\");\n              Ce.push(Ie);\n            }\n            return Ce.length === 0 ? \"\" : o(c, Ce);\n          }\n          function ve(K) {\n            return [\"as |\", K.blockParams.join(\" \"), \"|\"];\n          }\n          n.exports = {\n            print: E,\n            massageAstNode: T\n          };\n        }\n      }),\n      wd = Z({\n        \"src/language-handlebars/parsers.js\"() {\n          re();\n        }\n      }),\n      _d = Z({\n        \"node_modules/linguist-languages/data/Handlebars.json\"(e, n) {\n          n.exports = {\n            name: \"Handlebars\",\n            type: \"markup\",\n            color: \"#f7931e\",\n            aliases: [\"hbs\", \"htmlbars\"],\n            extensions: [\".handlebars\", \".hbs\"],\n            tmScope: \"text.html.handlebars\",\n            aceMode: \"handlebars\",\n            languageId: 155\n          };\n        }\n      }),\n      Pd = Z({\n        \"src/language-handlebars/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Bt(),\n            s = Nd(),\n            a = wd(),\n            r = [t(_d(), () => ({\n              since: \"2.3.0\",\n              parsers: [\"glimmer\"],\n              vscodeLanguageIds: [\"handlebars\"]\n            }))],\n            u = {\n              glimmer: s\n            };\n          n.exports = {\n            languages: r,\n            printers: u,\n            parsers: a\n          };\n        }\n      }),\n      kd = Z({\n        \"src/language-graphql/pragma.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(a) {\n            return /^\\s*#[^\\S\\n]*@(?:format|prettier)\\s*(?:\\n|$)/.test(a);\n          }\n          function s(a) {\n            return `# @format\n\n` + a;\n          }\n          n.exports = {\n            hasPragma: t,\n            insertPragma: s\n          };\n        }\n      }),\n      Id = Z({\n        \"src/language-graphql/loc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(a) {\n            return typeof a.start == \"number\" ? a.start : a.loc && a.loc.start;\n          }\n          function s(a) {\n            return typeof a.end == \"number\" ? a.end : a.loc && a.loc.end;\n          }\n          n.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      Ld = Z({\n        \"src/language-graphql/printer-graphql.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                join: t,\n                hardline: s,\n                line: a,\n                softline: r,\n                group: u,\n                indent: i,\n                ifBreak: o\n              }\n            } = Oe(),\n            {\n              isNextLineEmpty: c,\n              isNonEmptyArray: v\n            } = Ue(),\n            {\n              insertPragma: m\n            } = kd(),\n            {\n              locStart: d,\n              locEnd: p\n            } = Id();\n          function f(k, P, C) {\n            let D = k.getValue();\n            if (!D) return \"\";\n            if (typeof D == \"string\") return D;\n            switch (D.kind) {\n              case \"Document\":\n                {\n                  let g = [];\n                  return k.each((F, l, E) => {\n                    g.push(C()), l !== E.length - 1 && (g.push(s), c(P.originalText, F.getValue(), p) && g.push(s));\n                  }, \"definitions\"), [...g, s];\n                }\n              case \"OperationDefinition\":\n                {\n                  let g = P.originalText[d(D)] !== \"{\",\n                    F = Boolean(D.name);\n                  return [g ? D.operation : \"\", g && F ? [\" \", C(\"name\")] : \"\", g && !F && v(D.variableDefinitions) ? \" \" : \"\", v(D.variableDefinitions) ? u([\"(\", i([r, t([o(\"\", \", \"), r], k.map(C, \"variableDefinitions\"))]), r, \")\"]) : \"\", h(k, C, D), D.selectionSet ? !g && !F ? \"\" : \" \" : \"\", C(\"selectionSet\")];\n                }\n              case \"FragmentDefinition\":\n                return [\"fragment \", C(\"name\"), v(D.variableDefinitions) ? u([\"(\", i([r, t([o(\"\", \", \"), r], k.map(C, \"variableDefinitions\"))]), r, \")\"]) : \"\", \" on \", C(\"typeCondition\"), h(k, C, D), \" \", C(\"selectionSet\")];\n              case \"SelectionSet\":\n                return [\"{\", i([s, t(s, w(k, P, C, \"selections\"))]), s, \"}\"];\n              case \"Field\":\n                return u([D.alias ? [C(\"alias\"), \": \"] : \"\", C(\"name\"), D.arguments.length > 0 ? u([\"(\", i([r, t([o(\"\", \", \"), r], w(k, P, C, \"arguments\"))]), r, \")\"]) : \"\", h(k, C, D), D.selectionSet ? \" \" : \"\", C(\"selectionSet\")]);\n              case \"Name\":\n                return D.value;\n              case \"StringValue\":\n                {\n                  if (D.block) {\n                    let g = D.value.replace(/\"\"\"/g, \"\\\\$&\").split(`\n`);\n                    return g.length === 1 && (g[0] = g[0].trim()), g.every(F => F === \"\") && (g.length = 0), t(s, ['\"\"\"', ...g, '\"\"\"']);\n                  }\n                  return ['\"', D.value.replace(/[\"\\\\]/g, \"\\\\$&\").replace(/\\n/g, \"\\\\n\"), '\"'];\n                }\n              case \"IntValue\":\n              case \"FloatValue\":\n              case \"EnumValue\":\n                return D.value;\n              case \"BooleanValue\":\n                return D.value ? \"true\" : \"false\";\n              case \"NullValue\":\n                return \"null\";\n              case \"Variable\":\n                return [\"$\", C(\"name\")];\n              case \"ListValue\":\n                return u([\"[\", i([r, t([o(\"\", \", \"), r], k.map(C, \"values\"))]), r, \"]\"]);\n              case \"ObjectValue\":\n                return u([\"{\", P.bracketSpacing && D.fields.length > 0 ? \" \" : \"\", i([r, t([o(\"\", \", \"), r], k.map(C, \"fields\"))]), r, o(\"\", P.bracketSpacing && D.fields.length > 0 ? \" \" : \"\"), \"}\"]);\n              case \"ObjectField\":\n              case \"Argument\":\n                return [C(\"name\"), \": \", C(\"value\")];\n              case \"Directive\":\n                return [\"@\", C(\"name\"), D.arguments.length > 0 ? u([\"(\", i([r, t([o(\"\", \", \"), r], w(k, P, C, \"arguments\"))]), r, \")\"]) : \"\"];\n              case \"NamedType\":\n                return C(\"name\");\n              case \"VariableDefinition\":\n                return [C(\"variable\"), \": \", C(\"type\"), D.defaultValue ? [\" = \", C(\"defaultValue\")] : \"\", h(k, C, D)];\n              case \"ObjectTypeExtension\":\n              case \"ObjectTypeDefinition\":\n                return [C(\"description\"), D.description ? s : \"\", D.kind === \"ObjectTypeExtension\" ? \"extend \" : \"\", \"type \", C(\"name\"), D.interfaces.length > 0 ? [\" implements \", ...S(k, P, C)] : \"\", h(k, C, D), D.fields.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"fields\"))]), s, \"}\"] : \"\"];\n              case \"FieldDefinition\":\n                return [C(\"description\"), D.description ? s : \"\", C(\"name\"), D.arguments.length > 0 ? u([\"(\", i([r, t([o(\"\", \", \"), r], w(k, P, C, \"arguments\"))]), r, \")\"]) : \"\", \": \", C(\"type\"), h(k, C, D)];\n              case \"DirectiveDefinition\":\n                return [C(\"description\"), D.description ? s : \"\", \"directive \", \"@\", C(\"name\"), D.arguments.length > 0 ? u([\"(\", i([r, t([o(\"\", \", \"), r], w(k, P, C, \"arguments\"))]), r, \")\"]) : \"\", D.repeatable ? \" repeatable\" : \"\", \" on \", t(\" | \", k.map(C, \"locations\"))];\n              case \"EnumTypeExtension\":\n              case \"EnumTypeDefinition\":\n                return [C(\"description\"), D.description ? s : \"\", D.kind === \"EnumTypeExtension\" ? \"extend \" : \"\", \"enum \", C(\"name\"), h(k, C, D), D.values.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"values\"))]), s, \"}\"] : \"\"];\n              case \"EnumValueDefinition\":\n                return [C(\"description\"), D.description ? s : \"\", C(\"name\"), h(k, C, D)];\n              case \"InputValueDefinition\":\n                return [C(\"description\"), D.description ? D.description.block ? s : a : \"\", C(\"name\"), \": \", C(\"type\"), D.defaultValue ? [\" = \", C(\"defaultValue\")] : \"\", h(k, C, D)];\n              case \"InputObjectTypeExtension\":\n              case \"InputObjectTypeDefinition\":\n                return [C(\"description\"), D.description ? s : \"\", D.kind === \"InputObjectTypeExtension\" ? \"extend \" : \"\", \"input \", C(\"name\"), h(k, C, D), D.fields.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"fields\"))]), s, \"}\"] : \"\"];\n              case \"SchemaExtension\":\n                return [\"extend schema\", h(k, C, D), ...(D.operationTypes.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"operationTypes\"))]), s, \"}\"] : [])];\n              case \"SchemaDefinition\":\n                return [C(\"description\"), D.description ? s : \"\", \"schema\", h(k, C, D), \" {\", D.operationTypes.length > 0 ? i([s, t(s, w(k, P, C, \"operationTypes\"))]) : \"\", s, \"}\"];\n              case \"OperationTypeDefinition\":\n                return [C(\"operation\"), \": \", C(\"type\")];\n              case \"InterfaceTypeExtension\":\n              case \"InterfaceTypeDefinition\":\n                return [C(\"description\"), D.description ? s : \"\", D.kind === \"InterfaceTypeExtension\" ? \"extend \" : \"\", \"interface \", C(\"name\"), D.interfaces.length > 0 ? [\" implements \", ...S(k, P, C)] : \"\", h(k, C, D), D.fields.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"fields\"))]), s, \"}\"] : \"\"];\n              case \"FragmentSpread\":\n                return [\"...\", C(\"name\"), h(k, C, D)];\n              case \"InlineFragment\":\n                return [\"...\", D.typeCondition ? [\" on \", C(\"typeCondition\")] : \"\", h(k, C, D), \" \", C(\"selectionSet\")];\n              case \"UnionTypeExtension\":\n              case \"UnionTypeDefinition\":\n                return u([C(\"description\"), D.description ? s : \"\", u([D.kind === \"UnionTypeExtension\" ? \"extend \" : \"\", \"union \", C(\"name\"), h(k, C, D), D.types.length > 0 ? [\" =\", o(\"\", \" \"), i([o([a, \"  \"]), t([a, \"| \"], k.map(C, \"types\"))])] : \"\"])]);\n              case \"ScalarTypeExtension\":\n              case \"ScalarTypeDefinition\":\n                return [C(\"description\"), D.description ? s : \"\", D.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\", \"scalar \", C(\"name\"), h(k, C, D)];\n              case \"NonNullType\":\n                return [C(\"type\"), \"!\"];\n              case \"ListType\":\n                return [\"[\", C(\"type\"), \"]\"];\n              default:\n                throw new Error(\"unknown graphql type: \" + JSON.stringify(D.kind));\n            }\n          }\n          function h(k, P, C) {\n            if (C.directives.length === 0) return \"\";\n            let D = t(a, k.map(P, \"directives\"));\n            return C.kind === \"FragmentDefinition\" || C.kind === \"OperationDefinition\" ? u([a, D]) : [\" \", u(i([r, D]))];\n          }\n          function w(k, P, C, D) {\n            return k.map((g, F, l) => {\n              let E = C();\n              return F < l.length - 1 && c(P.originalText, g.getValue(), p) ? [E, s] : E;\n            }, D);\n          }\n          function T(k) {\n            return k.kind && k.kind !== \"Comment\";\n          }\n          function A(k) {\n            let P = k.getValue();\n            if (P.kind === \"Comment\") return \"#\" + P.value.trimEnd();\n            throw new Error(\"Not a comment: \" + JSON.stringify(P));\n          }\n          function S(k, P, C) {\n            let D = k.getNode(),\n              g = [],\n              {\n                interfaces: F\n              } = D,\n              l = k.map(E => C(E), \"interfaces\");\n            for (let E = 0; E < F.length; E++) {\n              let y = F[E];\n              g.push(l[E]);\n              let N = F[E + 1];\n              if (N) {\n                let x = P.originalText.slice(y.loc.end, N.loc.start),\n                  b = x.includes(\"#\"),\n                  L = x.replace(/#.*/g, \"\").trim();\n                g.push(L === \",\" ? \",\" : \" &\", b ? a : \" \");\n              }\n            }\n            return g;\n          }\n          function B(k, P) {\n            k.kind === \"StringValue\" && k.block && !k.value.includes(`\n`) && (P.value = P.value.trim());\n          }\n          B.ignoredProperties = new Set([\"loc\", \"comments\"]);\n          function I(k) {\n            var P;\n            let C = k.getValue();\n            return C == null || (P = C.comments) === null || P === void 0 ? void 0 : P.some(D => D.value.trim() === \"prettier-ignore\");\n          }\n          n.exports = {\n            print: f,\n            massageAstNode: B,\n            hasPrettierIgnore: I,\n            insertPragma: m,\n            printComment: A,\n            canAttachComment: T\n          };\n        }\n      }),\n      jd = Z({\n        \"src/language-graphql/options.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Ot();\n          n.exports = {\n            bracketSpacing: t.bracketSpacing\n          };\n        }\n      }),\n      Od = Z({\n        \"src/language-graphql/parsers.js\"() {\n          re();\n        }\n      }),\n      qd = Z({\n        \"node_modules/linguist-languages/data/GraphQL.json\"(e, n) {\n          n.exports = {\n            name: \"GraphQL\",\n            type: \"data\",\n            color: \"#e10098\",\n            extensions: [\".graphql\", \".gql\", \".graphqls\"],\n            tmScope: \"source.graphql\",\n            aceMode: \"text\",\n            languageId: 139\n          };\n        }\n      }),\n      Md = Z({\n        \"src/language-graphql/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Bt(),\n            s = Ld(),\n            a = jd(),\n            r = Od(),\n            u = [t(qd(), () => ({\n              since: \"1.5.0\",\n              parsers: [\"graphql\"],\n              vscodeLanguageIds: [\"graphql\"]\n            }))],\n            i = {\n              graphql: s\n            };\n          n.exports = {\n            languages: u,\n            options: a,\n            printers: i,\n            parsers: r\n          };\n        }\n      }),\n      go = Z({\n        \"src/language-markdown/loc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(a) {\n            return a.position.start.offset;\n          }\n          function s(a) {\n            return a.position.end.offset;\n          }\n          n.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      Rd = Z({\n        \"src/language-markdown/constants.evaluate.js\"(e, n) {\n          n.exports = {\n            cjkPattern: \"(?:[\\\\u02ea-\\\\u02eb\\\\u1100-\\\\u11ff\\\\u2e80-\\\\u2e99\\\\u2e9b-\\\\u2ef3\\\\u2f00-\\\\u2fd5\\\\u2ff0-\\\\u303f\\\\u3041-\\\\u3096\\\\u3099-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312f\\\\u3131-\\\\u318e\\\\u3190-\\\\u3191\\\\u3196-\\\\u31ba\\\\u31c0-\\\\u31e3\\\\u31f0-\\\\u321e\\\\u322a-\\\\u3247\\\\u3260-\\\\u327e\\\\u328a-\\\\u32b0\\\\u32c0-\\\\u32cb\\\\u32d0-\\\\u3370\\\\u337b-\\\\u337f\\\\u33e0-\\\\u33fe\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fef\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufe10-\\\\ufe1f\\\\ufe30-\\\\ufe6f\\\\uff00-\\\\uffef]|[\\\\ud840-\\\\ud868\\\\ud86a-\\\\ud86c\\\\ud86f-\\\\ud872\\\\ud874-\\\\ud879][\\\\udc00-\\\\udfff]|\\\\ud82c[\\\\udc00-\\\\udd1e\\\\udd50-\\\\udd52\\\\udd64-\\\\udd67]|\\\\ud83c[\\\\ude00\\\\ude50-\\\\ude51]|\\\\ud869[\\\\udc00-\\\\uded6\\\\udf00-\\\\udfff]|\\\\ud86d[\\\\udc00-\\\\udf34\\\\udf40-\\\\udfff]|\\\\ud86e[\\\\udc00-\\\\udc1d\\\\udc20-\\\\udfff]|\\\\ud873[\\\\udc00-\\\\udea1\\\\udeb0-\\\\udfff]|\\\\ud87a[\\\\udc00-\\\\udfe0]|\\\\ud87e[\\\\udc00-\\\\ude1d])(?:[\\\\ufe00-\\\\ufe0f]|\\\\udb40[\\\\udd00-\\\\uddef])?\",\n            kPattern: \"[\\\\u1100-\\\\u11ff\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3013-\\\\u301f\\\\u302e-\\\\u3030\\\\u3037\\\\u30fb\\\\u3131-\\\\u318e\\\\u3200-\\\\u321e\\\\u3260-\\\\u327e\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\ufe45-\\\\ufe46\\\\uff61-\\\\uff65\\\\uffa0-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc]\",\n            punctuationPattern: \"[\\\\u0021-\\\\u002f\\\\u003a-\\\\u0040\\\\u005b-\\\\u0060\\\\u007b-\\\\u007e\\\\u00a1\\\\u00a7\\\\u00ab\\\\u00b6-\\\\u00b7\\\\u00bb\\\\u00bf\\\\u037e\\\\u0387\\\\u055a-\\\\u055f\\\\u0589-\\\\u058a\\\\u05be\\\\u05c0\\\\u05c3\\\\u05c6\\\\u05f3-\\\\u05f4\\\\u0609-\\\\u060a\\\\u060c-\\\\u060d\\\\u061b\\\\u061e-\\\\u061f\\\\u066a-\\\\u066d\\\\u06d4\\\\u0700-\\\\u070d\\\\u07f7-\\\\u07f9\\\\u0830-\\\\u083e\\\\u085e\\\\u0964-\\\\u0965\\\\u0970\\\\u09fd\\\\u0a76\\\\u0af0\\\\u0c77\\\\u0c84\\\\u0df4\\\\u0e4f\\\\u0e5a-\\\\u0e5b\\\\u0f04-\\\\u0f12\\\\u0f14\\\\u0f3a-\\\\u0f3d\\\\u0f85\\\\u0fd0-\\\\u0fd4\\\\u0fd9-\\\\u0fda\\\\u104a-\\\\u104f\\\\u10fb\\\\u1360-\\\\u1368\\\\u1400\\\\u166e\\\\u169b-\\\\u169c\\\\u16eb-\\\\u16ed\\\\u1735-\\\\u1736\\\\u17d4-\\\\u17d6\\\\u17d8-\\\\u17da\\\\u1800-\\\\u180a\\\\u1944-\\\\u1945\\\\u1a1e-\\\\u1a1f\\\\u1aa0-\\\\u1aa6\\\\u1aa8-\\\\u1aad\\\\u1b5a-\\\\u1b60\\\\u1bfc-\\\\u1bff\\\\u1c3b-\\\\u1c3f\\\\u1c7e-\\\\u1c7f\\\\u1cc0-\\\\u1cc7\\\\u1cd3\\\\u2010-\\\\u2027\\\\u2030-\\\\u2043\\\\u2045-\\\\u2051\\\\u2053-\\\\u205e\\\\u207d-\\\\u207e\\\\u208d-\\\\u208e\\\\u2308-\\\\u230b\\\\u2329-\\\\u232a\\\\u2768-\\\\u2775\\\\u27c5-\\\\u27c6\\\\u27e6-\\\\u27ef\\\\u2983-\\\\u2998\\\\u29d8-\\\\u29db\\\\u29fc-\\\\u29fd\\\\u2cf9-\\\\u2cfc\\\\u2cfe-\\\\u2cff\\\\u2d70\\\\u2e00-\\\\u2e2e\\\\u2e30-\\\\u2e4f\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3014-\\\\u301f\\\\u3030\\\\u303d\\\\u30a0\\\\u30fb\\\\ua4fe-\\\\ua4ff\\\\ua60d-\\\\ua60f\\\\ua673\\\\ua67e\\\\ua6f2-\\\\ua6f7\\\\ua874-\\\\ua877\\\\ua8ce-\\\\ua8cf\\\\ua8f8-\\\\ua8fa\\\\ua8fc\\\\ua92e-\\\\ua92f\\\\ua95f\\\\ua9c1-\\\\ua9cd\\\\ua9de-\\\\ua9df\\\\uaa5c-\\\\uaa5f\\\\uaade-\\\\uaadf\\\\uaaf0-\\\\uaaf1\\\\uabeb\\\\ufd3e-\\\\ufd3f\\\\ufe10-\\\\ufe19\\\\ufe30-\\\\ufe52\\\\ufe54-\\\\ufe61\\\\ufe63\\\\ufe68\\\\ufe6a-\\\\ufe6b\\\\uff01-\\\\uff03\\\\uff05-\\\\uff0a\\\\uff0c-\\\\uff0f\\\\uff1a-\\\\uff1b\\\\uff1f-\\\\uff20\\\\uff3b-\\\\uff3d\\\\uff3f\\\\uff5b\\\\uff5d\\\\uff5f-\\\\uff65]|\\\\ud800[\\\\udd00-\\\\udd02\\\\udf9f\\\\udfd0]|\\\\ud801[\\\\udd6f]|\\\\ud802[\\\\udc57\\\\udd1f\\\\udd3f\\\\ude50-\\\\ude58\\\\ude7f\\\\udef0-\\\\udef6\\\\udf39-\\\\udf3f\\\\udf99-\\\\udf9c]|\\\\ud803[\\\\udf55-\\\\udf59]|\\\\ud804[\\\\udc47-\\\\udc4d\\\\udcbb-\\\\udcbc\\\\udcbe-\\\\udcc1\\\\udd40-\\\\udd43\\\\udd74-\\\\udd75\\\\uddc5-\\\\uddc8\\\\uddcd\\\\udddb\\\\udddd-\\\\udddf\\\\ude38-\\\\ude3d\\\\udea9]|\\\\ud805[\\\\udc4b-\\\\udc4f\\\\udc5b\\\\udc5d\\\\udcc6\\\\uddc1-\\\\uddd7\\\\ude41-\\\\ude43\\\\ude60-\\\\ude6c\\\\udf3c-\\\\udf3e]|\\\\ud806[\\\\udc3b\\\\udde2\\\\ude3f-\\\\ude46\\\\ude9a-\\\\ude9c\\\\ude9e-\\\\udea2]|\\\\ud807[\\\\udc41-\\\\udc45\\\\udc70-\\\\udc71\\\\udef7-\\\\udef8\\\\udfff]|\\\\ud809[\\\\udc70-\\\\udc74]|\\\\ud81a[\\\\ude6e-\\\\ude6f\\\\udef5\\\\udf37-\\\\udf3b\\\\udf44]|\\\\ud81b[\\\\ude97-\\\\ude9a\\\\udfe2]|\\\\ud82f[\\\\udc9f]|\\\\ud836[\\\\ude87-\\\\ude8b]|\\\\ud83a[\\\\udd5e-\\\\udd5f]\"\n          };\n        }\n      }),\n      Kn = Z({\n        \"src/language-markdown/utils.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              getLast: t\n            } = Ue(),\n            {\n              locStart: s,\n              locEnd: a\n            } = go(),\n            {\n              cjkPattern: r,\n              kPattern: u,\n              punctuationPattern: i\n            } = Rd(),\n            o = [\"liquidNode\", \"inlineCode\", \"emphasis\", \"esComment\", \"strong\", \"delete\", \"wikiLink\", \"link\", \"linkReference\", \"image\", \"imageReference\", \"footnote\", \"footnoteReference\", \"sentence\", \"whitespace\", \"word\", \"break\", \"inlineMath\"],\n            c = [...o, \"tableCell\", \"paragraph\", \"heading\"],\n            v = new RegExp(u),\n            m = new RegExp(i);\n          function d(A, S) {\n            let B = \"non-cjk\",\n              I = \"cj-letter\",\n              k = \"k-letter\",\n              P = \"cjk-punctuation\",\n              C = [],\n              D = (S.proseWrap === \"preserve\" ? A : A.replace(new RegExp(\"(\".concat(r, `)\n(`).concat(r, \")\"), \"g\"), \"$1$2\")).split(/([\\t\\n ]+)/);\n            for (let [F, l] of D.entries()) {\n              if (F % 2 === 1) {\n                C.push({\n                  type: \"whitespace\",\n                  value: /\\n/.test(l) ? `\n` : \" \"\n                });\n                continue;\n              }\n              if ((F === 0 || F === D.length - 1) && l === \"\") continue;\n              let E = l.split(new RegExp(\"(\".concat(r, \")\")));\n              for (let [y, N] of E.entries()) if (!((y === 0 || y === E.length - 1) && N === \"\")) {\n                if (y % 2 === 0) {\n                  N !== \"\" && g({\n                    type: \"word\",\n                    value: N,\n                    kind: B,\n                    hasLeadingPunctuation: m.test(N[0]),\n                    hasTrailingPunctuation: m.test(t(N))\n                  });\n                  continue;\n                }\n                g(m.test(N) ? {\n                  type: \"word\",\n                  value: N,\n                  kind: P,\n                  hasLeadingPunctuation: !0,\n                  hasTrailingPunctuation: !0\n                } : {\n                  type: \"word\",\n                  value: N,\n                  kind: v.test(N) ? k : I,\n                  hasLeadingPunctuation: !1,\n                  hasTrailingPunctuation: !1\n                });\n              }\n            }\n            return C;\n            function g(F) {\n              let l = t(C);\n              l && l.type === \"word\" && (l.kind === B && F.kind === I && !l.hasTrailingPunctuation || l.kind === I && F.kind === B && !F.hasLeadingPunctuation ? C.push({\n                type: \"whitespace\",\n                value: \" \"\n              }) : !E(B, P) && ![l.value, F.value].some(y => /\\u3000/.test(y)) && C.push({\n                type: \"whitespace\",\n                value: \"\"\n              })), C.push(F);\n              function E(y, N) {\n                return l.kind === y && F.kind === N || l.kind === N && F.kind === y;\n              }\n            }\n          }\n          function p(A, S) {\n            let [, B, I, k] = S.slice(A.position.start.offset, A.position.end.offset).match(/^\\s*(\\d+)(\\.|\\))(\\s*)/);\n            return {\n              numberText: B,\n              marker: I,\n              leadingSpaces: k\n            };\n          }\n          function f(A, S) {\n            if (!A.ordered || A.children.length < 2) return !1;\n            let B = Number(p(A.children[0], S.originalText).numberText),\n              I = Number(p(A.children[1], S.originalText).numberText);\n            if (B === 0 && A.children.length > 2) {\n              let k = Number(p(A.children[2], S.originalText).numberText);\n              return I === 1 && k === 1;\n            }\n            return I === 1;\n          }\n          function h(A, S) {\n            let {\n              value: B\n            } = A;\n            return A.position.end.offset === S.length && B.endsWith(`\n`) && S.endsWith(`\n`) ? B.slice(0, -1) : B;\n          }\n          function w(A, S) {\n            return function B(I, k, P) {\n              let C = Object.assign({}, S(I, k, P));\n              return C.children && (C.children = C.children.map((D, g) => B(D, g, [C, ...P]))), C;\n            }(A, null, []);\n          }\n          function T(A) {\n            if ((A == null ? void 0 : A.type) !== \"link\" || A.children.length !== 1) return !1;\n            let [S] = A.children;\n            return s(A) === s(S) && a(A) === a(S);\n          }\n          n.exports = {\n            mapAst: w,\n            splitText: d,\n            punctuationPattern: i,\n            getFencedCodeBlockValue: h,\n            getOrderedListItemInfo: p,\n            hasGitDiffFriendlyOrderedList: f,\n            INLINE_NODE_TYPES: o,\n            INLINE_NODE_WRAPPER_TYPES: c,\n            isAutolink: T\n          };\n        }\n      }),\n      Vd = Z({\n        \"src/language-markdown/embed.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              inferParserByLanguage: t,\n              getMaxContinuousCount: s\n            } = Ue(),\n            {\n              builders: {\n                hardline: a,\n                markAsRoot: r\n              },\n              utils: {\n                replaceEndOfLine: u\n              }\n            } = Oe(),\n            i = Xn(),\n            {\n              getFencedCodeBlockValue: o\n            } = Kn();\n          function c(v, m, d, p) {\n            let f = v.getValue();\n            if (f.type === \"code\" && f.lang !== null) {\n              let h = t(f.lang, p);\n              if (h) {\n                let w = p.__inJsTemplate ? \"~\" : \"`\",\n                  T = w.repeat(Math.max(3, s(f.value, w) + 1)),\n                  A = {\n                    parser: h\n                  };\n                f.lang === \"tsx\" && (A.filepath = \"dummy.tsx\");\n                let S = d(o(f, p.originalText), A, {\n                  stripTrailingHardline: !0\n                });\n                return r([T, f.lang, f.meta ? \" \" + f.meta : \"\", a, u(S), a, T]);\n              }\n            }\n            switch (f.type) {\n              case \"front-matter\":\n                return i(f, d);\n              case \"importExport\":\n                return [d(f.value, {\n                  parser: \"babel\"\n                }, {\n                  stripTrailingHardline: !0\n                }), a];\n              case \"jsx\":\n                return d(\"<$>\".concat(f.value, \"</$>\"), {\n                  parser: \"__js_expression\",\n                  rootMarker: \"mdx\"\n                }, {\n                  stripTrailingHardline: !0\n                });\n            }\n            return null;\n          }\n          n.exports = c;\n        }\n      }),\n      yo = Z({\n        \"src/language-markdown/pragma.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = mo(),\n            s = [\"format\", \"prettier\"];\n          function a(r) {\n            let u = \"@(\".concat(s.join(\"|\"), \")\"),\n              i = new RegExp([\"<!--\\\\s*\".concat(u, \"\\\\s*-->\"), \"{\\\\s*\\\\/\\\\*\\\\s*\".concat(u, \"\\\\s*\\\\*\\\\/\\\\s*}\"), `<!--.*\\r?\n[\\\\s\\\\S]*(^|\n)[^\\\\S\n]*`.concat(u, `[^\\\\S\n]*($|\n)[\\\\s\\\\S]*\n.*-->`)].join(\"|\"), \"m\"),\n              o = r.match(i);\n            return (o == null ? void 0 : o.index) === 0;\n          }\n          n.exports = {\n            startWithPragma: a,\n            hasPragma: r => a(t(r).content.trimStart()),\n            insertPragma: r => {\n              let u = t(r),\n                i = \"<!-- @\".concat(s[0], \" -->\");\n              return u.frontMatter ? \"\".concat(u.frontMatter.raw, `\n\n`).concat(i, `\n\n`).concat(u.content) : \"\".concat(i, `\n\n`).concat(u.content);\n            }\n          };\n        }\n      }),\n      Wd = Z({\n        \"src/language-markdown/print-preprocess.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = it(),\n            {\n              getOrderedListItemInfo: s,\n              mapAst: a,\n              splitText: r\n            } = Kn(),\n            u = /^.$/su;\n          function i(T, A) {\n            return T = v(T, A), T = p(T), T = c(T), T = h(T, A), T = w(T, A), T = f(T, A), T = o(T), T = m(T), T;\n          }\n          function o(T) {\n            return a(T, A => A.type !== \"import\" && A.type !== \"export\" ? A : Object.assign(Object.assign({}, A), {}, {\n              type: \"importExport\"\n            }));\n          }\n          function c(T) {\n            return a(T, A => A.type !== \"inlineCode\" ? A : Object.assign(Object.assign({}, A), {}, {\n              value: A.value.replace(/\\s+/g, \" \")\n            }));\n          }\n          function v(T, A) {\n            return a(T, S => S.type !== \"text\" || S.value === \"*\" || S.value === \"_\" || !u.test(S.value) || S.position.end.offset - S.position.start.offset === S.value.length ? S : Object.assign(Object.assign({}, S), {}, {\n              value: A.originalText.slice(S.position.start.offset, S.position.end.offset)\n            }));\n          }\n          function m(T) {\n            return d(T, (A, S) => A.type === \"importExport\" && S.type === \"importExport\", (A, S) => ({\n              type: \"importExport\",\n              value: A.value + `\n\n` + S.value,\n              position: {\n                start: A.position.start,\n                end: S.position.end\n              }\n            }));\n          }\n          function d(T, A, S) {\n            return a(T, B => {\n              if (!B.children) return B;\n              let I = B.children.reduce((k, P) => {\n                let C = t(k);\n                return C && A(C, P) ? k.splice(-1, 1, S(C, P)) : k.push(P), k;\n              }, []);\n              return Object.assign(Object.assign({}, B), {}, {\n                children: I\n              });\n            });\n          }\n          function p(T) {\n            return d(T, (A, S) => A.type === \"text\" && S.type === \"text\", (A, S) => ({\n              type: \"text\",\n              value: A.value + S.value,\n              position: {\n                start: A.position.start,\n                end: S.position.end\n              }\n            }));\n          }\n          function f(T, A) {\n            return a(T, (S, B, I) => {\n              let [k] = I;\n              if (S.type !== \"text\") return S;\n              let {\n                value: P\n              } = S;\n              return k.type === \"paragraph\" && (B === 0 && (P = P.trimStart()), B === k.children.length - 1 && (P = P.trimEnd())), {\n                type: \"sentence\",\n                position: S.position,\n                children: r(P, A)\n              };\n            });\n          }\n          function h(T, A) {\n            return a(T, (S, B, I) => {\n              if (S.type === \"code\") {\n                let k = /^\\n?(?: {4,}|\\t)/.test(A.originalText.slice(S.position.start.offset, S.position.end.offset));\n                if (S.isIndented = k, k) for (let P = 0; P < I.length; P++) {\n                  let C = I[P];\n                  if (C.hasIndentedCodeblock) break;\n                  C.type === \"list\" && (C.hasIndentedCodeblock = !0);\n                }\n              }\n              return S;\n            });\n          }\n          function w(T, A) {\n            return a(T, (I, k, P) => {\n              if (I.type === \"list\" && I.children.length > 0) {\n                for (let C = 0; C < P.length; C++) {\n                  let D = P[C];\n                  if (D.type === \"list\" && !D.isAligned) return I.isAligned = !1, I;\n                }\n                I.isAligned = B(I);\n              }\n              return I;\n            });\n            function S(I) {\n              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;\n            }\n            function B(I) {\n              if (!I.ordered) return !0;\n              let [k, P] = I.children;\n              if (s(k, A.originalText).leadingSpaces.length > 1) return !0;\n              let D = S(k);\n              if (D === -1) return !1;\n              if (I.children.length === 1) return D % A.tabWidth === 0;\n              let g = S(P);\n              return D !== g ? !1 : D % A.tabWidth === 0 ? !0 : s(P, A.originalText).leadingSpaces.length > 1;\n            }\n          }\n          n.exports = i;\n        }\n      }),\n      $d = Z({\n        \"src/language-markdown/clean.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isFrontMatterNode: t\n            } = Ue(),\n            {\n              startWithPragma: s\n            } = yo(),\n            a = new Set([\"position\", \"raw\"]);\n          function r(u, i, o) {\n            if ((u.type === \"front-matter\" || u.type === \"code\" || u.type === \"yaml\" || u.type === \"import\" || u.type === \"export\" || u.type === \"jsx\") && delete i.value, u.type === \"list\" && delete i.isAligned, (u.type === \"list\" || u.type === \"listItem\") && (delete i.spread, delete i.loose), u.type === \"text\" || (u.type === \"inlineCode\" && (i.value = u.value.replace(/[\\t\\n ]+/g, \" \")), u.type === \"wikiLink\" && (i.value = u.value.trim().replace(/[\\t\\n]+/g, \" \")), (u.type === \"definition\" || u.type === \"linkReference\") && (i.label = u.label.trim().replace(/[\\t\\n ]+/g, \" \").toLowerCase()), (u.type === \"definition\" || u.type === \"link\" || u.type === \"image\") && u.title && (i.title = u.title.replace(/\\\\([\"')])/g, \"$1\")), o && o.type === \"root\" && o.children.length > 0 && (o.children[0] === u || t(o.children[0]) && o.children[1] === u) && u.type === \"html\" && s(u.value))) return null;\n          }\n          r.ignoredProperties = a, n.exports = r;\n        }\n      }),\n      Hd = Z({\n        \"src/language-markdown/printer-markdown.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              getLast: t,\n              getMinNotPresentContinuousCount: s,\n              getMaxContinuousCount: a,\n              getStringWidth: r,\n              isNonEmptyArray: u\n            } = Ue(),\n            {\n              builders: {\n                breakParent: i,\n                join: o,\n                line: c,\n                literalline: v,\n                markAsRoot: m,\n                hardline: d,\n                softline: p,\n                ifBreak: f,\n                fill: h,\n                align: w,\n                indent: T,\n                group: A,\n                hardlineWithoutBreakParent: S\n              },\n              utils: {\n                normalizeDoc: B,\n                replaceTextEndOfLine: I\n              },\n              printer: {\n                printDocToString: k\n              }\n            } = Oe(),\n            P = Vd(),\n            {\n              insertPragma: C\n            } = yo(),\n            {\n              locStart: D,\n              locEnd: g\n            } = go(),\n            F = Wd(),\n            l = $d(),\n            {\n              getFencedCodeBlockValue: E,\n              hasGitDiffFriendlyOrderedList: y,\n              splitText: N,\n              punctuationPattern: x,\n              INLINE_NODE_TYPES: b,\n              INLINE_NODE_WRAPPER_TYPES: L,\n              isAutolink: M\n            } = Kn(),\n            j = new Set([\"importExport\"]),\n            $ = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"],\n            V = new Set([\"listItem\", \"definition\", \"footnoteDefinition\"]);\n          function q(ce, pe, de) {\n            let ae = ce.getValue();\n            if (le(ce)) return N(pe.originalText.slice(ae.position.start.offset, ae.position.end.offset), pe).map(ve => ve.type === \"word\" ? ve.value : ve.value === \"\" ? \"\" : oe(ce, ve.value, pe));\n            switch (ae.type) {\n              case \"front-matter\":\n                return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);\n              case \"root\":\n                return ae.children.length === 0 ? \"\" : [B(X(ce, pe, de)), j.has(De(ae).type) ? \"\" : d];\n              case \"paragraph\":\n                return ue(ce, pe, de, {\n                  postprocessor: h\n                });\n              case \"sentence\":\n                return ue(ce, pe, de);\n              case \"word\":\n                {\n                  let ve = ae.value.replace(/\\*/g, \"\\\\$&\").replace(new RegExp([\"(^|\".concat(x, \")(_+)\"), \"(_+)(\".concat(x, \"|$)\")].join(\"|\"), \"g\"), (ye, Ce, Ie, Fe, me) => (Ie ? \"\".concat(Ce).concat(Ie) : \"\".concat(Fe).concat(me)).replace(/_/g, \"\\\\_\")),\n                    K = (ye, Ce, Ie) => ye.type === \"sentence\" && Ie === 0,\n                    he = (ye, Ce, Ie) => M(ye.children[Ie - 1]);\n                  return ve !== ae.value && (ce.match(void 0, K, he) || ce.match(void 0, K, (ye, Ce, Ie) => ye.type === \"emphasis\" && Ie === 0, he)) && (ve = ve.replace(/^(\\\\?[*_])+/, ye => ye.replace(/\\\\/g, \"\"))), ve;\n                }\n              case \"whitespace\":\n                {\n                  let ve = ce.getParentNode(),\n                    K = ve.children.indexOf(ae),\n                    he = ve.children[K + 1],\n                    ye = he && /^>|^(?:[*+-]|#{1,6}|\\d+[).])$/.test(he.value) ? \"never\" : pe.proseWrap;\n                  return oe(ce, ae.value, {\n                    proseWrap: ye\n                  });\n                }\n              case \"emphasis\":\n                {\n                  let ve;\n                  if (M(ae.children[0])) ve = pe.originalText[ae.position.start.offset];else {\n                    let K = ce.getParentNode(),\n                      he = K.children.indexOf(ae),\n                      ye = K.children[he - 1],\n                      Ce = K.children[he + 1];\n                    ve = ye && ye.type === \"sentence\" && ye.children.length > 0 && t(ye.children).type === \"word\" && !t(ye.children).hasTrailingPunctuation || Ce && Ce.type === \"sentence\" && Ce.children.length > 0 && Ce.children[0].type === \"word\" && !Ce.children[0].hasLeadingPunctuation || te(ce, \"emphasis\") ? \"*\" : \"_\";\n                  }\n                  return [ve, ue(ce, pe, de), ve];\n                }\n              case \"strong\":\n                return [\"**\", ue(ce, pe, de), \"**\"];\n              case \"delete\":\n                return [\"~~\", ue(ce, pe, de), \"~~\"];\n              case \"inlineCode\":\n                {\n                  let ve = s(ae.value, \"`\"),\n                    K = \"`\".repeat(ve || 1),\n                    he = ve && !/^\\s/.test(ae.value) ? \" \" : \"\";\n                  return [K, he, ae.value, he, K];\n                }\n              case \"wikiLink\":\n                {\n                  let ve = \"\";\n                  return pe.proseWrap === \"preserve\" ? ve = ae.value : ve = ae.value.replace(/[\\t\\n]+/g, \" \"), [\"[[\", ve, \"]]\"];\n                }\n              case \"link\":\n                switch (pe.originalText[ae.position.start.offset]) {\n                  case \"<\":\n                    {\n                      let ve = \"mailto:\",\n                        K = ae.url.startsWith(ve) && pe.originalText.slice(ae.position.start.offset + 1, ae.position.start.offset + 1 + ve.length) !== ve ? ae.url.slice(ve.length) : ae.url;\n                      return [\"<\", K, \">\"];\n                    }\n                  case \"[\":\n                    return [\"[\", ue(ce, pe, de), \"](\", ge(ae.url, \")\"), Ae(ae.title, pe), \")\"];\n                  default:\n                    return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);\n                }\n              case \"image\":\n                return [\"![\", ae.alt || \"\", \"](\", ge(ae.url, \")\"), Ae(ae.title, pe), \")\"];\n              case \"blockquote\":\n                return [\"> \", w(\"> \", ue(ce, pe, de))];\n              case \"heading\":\n                return [\"#\".repeat(ae.depth) + \" \", ue(ce, pe, de)];\n              case \"code\":\n                {\n                  if (ae.isIndented) {\n                    let he = \" \".repeat(4);\n                    return w(he, [he, ...I(ae.value, d)]);\n                  }\n                  let ve = pe.__inJsTemplate ? \"~\" : \"`\",\n                    K = ve.repeat(Math.max(3, a(ae.value, ve) + 1));\n                  return [K, ae.lang || \"\", ae.meta ? \" \" + ae.meta : \"\", d, ...I(E(ae, pe.originalText), d), d, K];\n                }\n              case \"html\":\n                {\n                  let ve = ce.getParentNode(),\n                    K = ve.type === \"root\" && t(ve.children) === ae ? ae.value.trimEnd() : ae.value,\n                    he = /^<!--.*-->$/s.test(K);\n                  return I(K, he ? d : m(v));\n                }\n              case \"list\":\n                {\n                  let ve = R(ae, ce.getParentNode()),\n                    K = y(ae, pe);\n                  return ue(ce, pe, de, {\n                    processor: (he, ye) => {\n                      let Ce = Fe(),\n                        Ie = he.getValue();\n                      if (Ie.children.length === 2 && Ie.children[1].type === \"html\" && Ie.children[0].position.start.column !== Ie.children[1].position.start.column) return [Ce, Y(he, pe, de, Ce)];\n                      return [Ce, w(\" \".repeat(Ce.length), Y(he, pe, de, Ce))];\n                      function Fe() {\n                        let me = ae.ordered ? (ye === 0 ? ae.start : K ? 1 : ae.start + ye) + (ve % 2 === 0 ? \". \" : \") \") : ve % 2 === 0 ? \"- \" : \"* \";\n                        return ae.isAligned || ae.hasIndentedCodeblock ? H(me, pe) : me;\n                      }\n                    }\n                  });\n                }\n              case \"thematicBreak\":\n                {\n                  let ve = ee(ce, \"list\");\n                  return ve === -1 ? \"---\" : R(ce.getParentNode(ve), ce.getParentNode(ve + 1)) % 2 === 0 ? \"***\" : \"---\";\n                }\n              case \"linkReference\":\n                return [\"[\", ue(ce, pe, de), \"]\", ae.referenceType === \"full\" ? [\"[\", ae.identifier, \"]\"] : ae.referenceType === \"collapsed\" ? \"[]\" : \"\"];\n              case \"imageReference\":\n                switch (ae.referenceType) {\n                  case \"full\":\n                    return [\"![\", ae.alt || \"\", \"][\", ae.identifier, \"]\"];\n                  default:\n                    return [\"![\", ae.alt, \"]\", ae.referenceType === \"collapsed\" ? \"[]\" : \"\"];\n                }\n              case \"definition\":\n                {\n                  let ve = pe.proseWrap === \"always\" ? c : \" \";\n                  return A([\"[\", ae.identifier, \"]:\", T([ve, ge(ae.url), ae.title === null ? \"\" : [ve, Ae(ae.title, pe, !1)]])]);\n                }\n              case \"footnote\":\n                return [\"[^\", ue(ce, pe, de), \"]\"];\n              case \"footnoteReference\":\n                return [\"[^\", ae.identifier, \"]\"];\n              case \"footnoteDefinition\":\n                {\n                  let ve = ce.getParentNode().children[ce.getName() + 1],\n                    K = ae.children.length === 1 && ae.children[0].type === \"paragraph\" && (pe.proseWrap === \"never\" || pe.proseWrap === \"preserve\" && ae.children[0].position.start.line === ae.children[0].position.end.line);\n                  return [\"[^\", ae.identifier, \"]: \", K ? ue(ce, pe, de) : A([w(\" \".repeat(4), ue(ce, pe, de, {\n                    processor: (he, ye) => ye === 0 ? A([p, de()]) : de()\n                  })), ve && ve.type === \"footnoteDefinition\" ? p : \"\"])];\n                }\n              case \"table\":\n                return W(ce, pe, de);\n              case \"tableCell\":\n                return ue(ce, pe, de);\n              case \"break\":\n                return /\\s/.test(pe.originalText[ae.position.start.offset]) ? [\"  \", m(v)] : [\"\\\\\", d];\n              case \"liquidNode\":\n                return I(ae.value, d);\n              case \"importExport\":\n                return [ae.value, d];\n              case \"esComment\":\n                return [\"{/* \", ae.value, \" */}\"];\n              case \"jsx\":\n                return ae.value;\n              case \"math\":\n                return [\"$$\", d, ae.value ? [...I(ae.value, d), d] : \"\", \"$$\"];\n              case \"inlineMath\":\n                return pe.originalText.slice(D(ae), g(ae));\n              case \"tableRow\":\n              case \"listItem\":\n              default:\n                throw new Error(\"Unknown markdown type \".concat(JSON.stringify(ae.type)));\n            }\n          }\n          function Y(ce, pe, de, ae) {\n            let ve = ce.getValue(),\n              K = ve.checked === null ? \"\" : ve.checked ? \"[x] \" : \"[ ] \";\n            return [K, ue(ce, pe, de, {\n              processor: (he, ye) => {\n                if (ye === 0 && he.getValue().type !== \"list\") return w(\" \".repeat(K.length), de());\n                let Ce = \" \".repeat(Ne(pe.tabWidth - ae.length, 0, 3));\n                return [Ce, w(Ce, de())];\n              }\n            })];\n          }\n          function H(ce, pe) {\n            let de = ae();\n            return ce + \" \".repeat(de >= 4 ? 0 : de);\n            function ae() {\n              let ve = ce.length % pe.tabWidth;\n              return ve === 0 ? 0 : pe.tabWidth - ve;\n            }\n          }\n          function R(ce, pe) {\n            return Q(ce, pe, de => de.ordered === ce.ordered);\n          }\n          function Q(ce, pe, de) {\n            let ae = -1;\n            for (let ve of pe.children) if (ve.type === ce.type && de(ve) ? ae++ : ae = -1, ve === ce) return ae;\n          }\n          function ee(ce, pe) {\n            let de = Array.isArray(pe) ? pe : [pe],\n              ae = -1,\n              ve;\n            for (; ve = ce.getParentNode(++ae);) if (de.includes(ve.type)) return ae;\n            return -1;\n          }\n          function te(ce, pe) {\n            let de = ee(ce, pe);\n            return de === -1 ? null : ce.getParentNode(de);\n          }\n          function oe(ce, pe, de) {\n            if (de.proseWrap === \"preserve\" && pe === `\n`) return d;\n            let ae = de.proseWrap === \"always\" && !te(ce, $);\n            return pe !== \"\" ? ae ? c : \" \" : ae ? p : \"\";\n          }\n          function W(ce, pe, de) {\n            let ae = ce.getValue(),\n              ve = [],\n              K = ce.map(me => me.map((_, J) => {\n                let ne = k(de(), pe).formatted,\n                  Ee = r(ne);\n                return ve[J] = Math.max(ve[J] || 3, Ee), {\n                  text: ne,\n                  width: Ee\n                };\n              }, \"children\"), \"children\"),\n              he = Ce(!1);\n            if (pe.proseWrap !== \"never\") return [i, he];\n            let ye = Ce(!0);\n            return [i, A(f(ye, he))];\n            function Ce(me) {\n              let _ = [Fe(K[0], me), Ie(me)];\n              return K.length > 1 && _.push(o(S, K.slice(1).map(J => Fe(J, me)))), o(S, _);\n            }\n            function Ie(me) {\n              let _ = ve.map((J, ne) => {\n                let Ee = ae.align[ne],\n                  We = Ee === \"center\" || Ee === \"left\" ? \":\" : \"-\",\n                  Be = Ee === \"center\" || Ee === \"right\" ? \":\" : \"-\",\n                  Pe = me ? \"-\" : \"-\".repeat(J - 2);\n                return \"\".concat(We).concat(Pe).concat(Be);\n              });\n              return \"| \".concat(_.join(\" | \"), \" |\");\n            }\n            function Fe(me, _) {\n              let J = me.map((ne, Ee) => {\n                let {\n                  text: We,\n                  width: Be\n                } = ne;\n                if (_) return We;\n                let Pe = ve[Ee] - Be,\n                  Se = ae.align[Ee],\n                  Qe = 0;\n                Se === \"right\" ? Qe = Pe : Se === \"center\" && (Qe = Math.floor(Pe / 2));\n                let xe = Pe - Qe;\n                return \"\".concat(\" \".repeat(Qe)).concat(We).concat(\" \".repeat(xe));\n              });\n              return \"| \".concat(J.join(\" | \"), \" |\");\n            }\n          }\n          function X(ce, pe, de) {\n            let ae = [],\n              ve = null,\n              {\n                children: K\n              } = ce.getValue();\n            for (let [he, ye] of K.entries()) switch (ie(ye)) {\n              case \"start\":\n                ve === null && (ve = {\n                  index: he,\n                  offset: ye.position.end.offset\n                });\n                break;\n              case \"end\":\n                ve !== null && (ae.push({\n                  start: ve,\n                  end: {\n                    index: he,\n                    offset: ye.position.start.offset\n                  }\n                }), ve = null);\n                break;\n              default:\n                break;\n            }\n            return ue(ce, pe, de, {\n              processor: (he, ye) => {\n                if (ae.length > 0) {\n                  let Ce = ae[0];\n                  if (ye === Ce.start.index) return [K[Ce.start.index].value, pe.originalText.slice(Ce.start.offset, Ce.end.offset), K[Ce.end.index].value];\n                  if (Ce.start.index < ye && ye < Ce.end.index) return !1;\n                  if (ye === Ce.end.index) return ae.shift(), !1;\n                }\n                return de();\n              }\n            });\n          }\n          function ue(ce, pe, de) {\n            let ae = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},\n              {\n                postprocessor: ve\n              } = ae,\n              K = ae.processor || (() => de()),\n              he = ce.getValue(),\n              ye = [],\n              Ce;\n            return ce.each((Ie, Fe) => {\n              let me = Ie.getValue(),\n                _ = K(Ie, Fe);\n              if (_ !== !1) {\n                let J = {\n                  parts: ye,\n                  prevNode: Ce,\n                  parentNode: he,\n                  options: pe\n                };\n                G(me, J) && (ye.push(d), Ce && j.has(Ce.type) || (z(me, J) || U(me, J)) && ye.push(d), U(me, J) && ye.push(d)), ye.push(_), Ce = me;\n              }\n            }, \"children\"), ve ? ve(ye) : ye;\n          }\n          function De(ce) {\n            let pe = ce;\n            for (; u(pe.children);) pe = t(pe.children);\n            return pe;\n          }\n          function ie(ce) {\n            let pe;\n            if (ce.type === \"html\") pe = ce.value.match(/^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/);else {\n              let de;\n              ce.type === \"esComment\" ? de = ce : ce.type === \"paragraph\" && ce.children.length === 1 && ce.children[0].type === \"esComment\" && (de = ce.children[0]), de && (pe = de.value.match(/^prettier-ignore(?:-(start|end))?$/));\n            }\n            return pe ? pe[1] || \"next\" : !1;\n          }\n          function G(ce, pe) {\n            let de = pe.parts.length === 0,\n              ae = b.includes(ce.type),\n              ve = ce.type === \"html\" && L.includes(pe.parentNode.type);\n            return !de && !ae && !ve;\n          }\n          function z(ce, pe) {\n            var de, ae, ve;\n            let he = (pe.prevNode && pe.prevNode.type) === ce.type && V.has(ce.type),\n              ye = pe.parentNode.type === \"listItem\" && !pe.parentNode.loose,\n              Ce = ((de = pe.prevNode) === null || de === void 0 ? void 0 : de.type) === \"listItem\" && pe.prevNode.loose,\n              Ie = ie(pe.prevNode) === \"next\",\n              Fe = ce.type === \"html\" && ((ae = pe.prevNode) === null || ae === void 0 ? void 0 : ae.type) === \"html\" && pe.prevNode.position.end.line + 1 === ce.position.start.line,\n              me = ce.type === \"html\" && pe.parentNode.type === \"listItem\" && ((ve = pe.prevNode) === null || ve === void 0 ? void 0 : ve.type) === \"paragraph\" && pe.prevNode.position.end.line + 1 === ce.position.start.line;\n            return Ce || !(he || ye || Ie || Fe || me);\n          }\n          function U(ce, pe) {\n            let de = pe.prevNode && pe.prevNode.type === \"list\",\n              ae = ce.type === \"code\" && ce.isIndented;\n            return de && ae;\n          }\n          function le(ce) {\n            let pe = te(ce, [\"linkReference\", \"imageReference\"]);\n            return pe && (pe.type !== \"linkReference\" || pe.referenceType !== \"full\");\n          }\n          function ge(ce) {\n            let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],\n              de = [\" \", ...(Array.isArray(pe) ? pe : [pe])];\n            return new RegExp(de.map(ae => \"\\\\\".concat(ae)).join(\"|\")).test(ce) ? \"<\".concat(ce, \">\") : ce;\n          }\n          function Ae(ce, pe) {\n            let de = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;\n            if (!ce) return \"\";\n            if (de) return \" \" + Ae(ce, pe, !1);\n            if (ce = ce.replace(/\\\\([\"')])/g, \"$1\"), ce.includes('\"') && ce.includes(\"'\") && !ce.includes(\")\")) return \"(\".concat(ce, \")\");\n            let ae = ce.split(\"'\").length - 1,\n              ve = ce.split('\"').length - 1,\n              K = ae > ve ? '\"' : ve > ae || pe.singleQuote ? \"'\" : '\"';\n            return ce = ce.replace(/\\\\/, \"\\\\\\\\\"), ce = ce.replace(new RegExp(\"(\".concat(K, \")\"), \"g\"), \"\\\\$1\"), \"\".concat(K).concat(ce).concat(K);\n          }\n          function Ne(ce, pe, de) {\n            return ce < pe ? pe : ce > de ? de : ce;\n          }\n          function ke(ce) {\n            let pe = Number(ce.getName());\n            if (pe === 0) return !1;\n            let de = ce.getParentNode().children[pe - 1];\n            return ie(de) === \"next\";\n          }\n          n.exports = {\n            preprocess: F,\n            print: q,\n            embed: P,\n            massageAstNode: l,\n            hasPrettierIgnore: ke,\n            insertPragma: C\n          };\n        }\n      }),\n      Gd = Z({\n        \"src/language-markdown/options.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Ot();\n          n.exports = {\n            proseWrap: t.proseWrap,\n            singleQuote: t.singleQuote\n          };\n        }\n      }),\n      Jd = Z({\n        \"src/language-markdown/parsers.js\"() {\n          re();\n        }\n      }),\n      da = Z({\n        \"node_modules/linguist-languages/data/Markdown.json\"(e, n) {\n          n.exports = {\n            name: \"Markdown\",\n            type: \"prose\",\n            color: \"#083fa1\",\n            aliases: [\"pandoc\"],\n            aceMode: \"markdown\",\n            codemirrorMode: \"gfm\",\n            codemirrorMimeType: \"text/x-gfm\",\n            wrap: !0,\n            extensions: [\".md\", \".livemd\", \".markdown\", \".mdown\", \".mdwn\", \".mdx\", \".mkd\", \".mkdn\", \".mkdown\", \".ronn\", \".scd\", \".workbook\"],\n            filenames: [\"contents.lr\"],\n            tmScope: \"source.gfm\",\n            languageId: 222\n          };\n        }\n      }),\n      Ud = Z({\n        \"src/language-markdown/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Bt(),\n            s = Hd(),\n            a = Gd(),\n            r = Jd(),\n            u = [t(da(), o => ({\n              since: \"1.8.0\",\n              parsers: [\"markdown\"],\n              vscodeLanguageIds: [\"markdown\"],\n              filenames: [...o.filenames, \"README\"],\n              extensions: o.extensions.filter(c => c !== \".mdx\")\n            })), t(da(), () => ({\n              name: \"MDX\",\n              since: \"1.15.0\",\n              parsers: [\"mdx\"],\n              vscodeLanguageIds: [\"mdx\"],\n              filenames: [],\n              extensions: [\".mdx\"]\n            }))],\n            i = {\n              mdast: s\n            };\n          n.exports = {\n            languages: u,\n            options: a,\n            printers: i,\n            parsers: r\n          };\n        }\n      }),\n      zd = Z({\n        \"src/language-html/clean.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              isFrontMatterNode: t\n            } = Ue(),\n            s = new Set([\"sourceSpan\", \"startSourceSpan\", \"endSourceSpan\", \"nameSpan\", \"valueSpan\"]);\n          function a(r, u) {\n            if (r.type === \"text\" || r.type === \"comment\" || t(r) || r.type === \"yaml\" || r.type === \"toml\") return null;\n            r.type === \"attribute\" && delete u.value, r.type === \"docType\" && delete u.value;\n          }\n          a.ignoredProperties = s, n.exports = a;\n        }\n      }),\n      Xd = Z({\n        \"src/language-html/constants.evaluate.js\"(e, n) {\n          n.exports = {\n            CSS_DISPLAY_TAGS: {\n              area: \"none\",\n              base: \"none\",\n              basefont: \"none\",\n              datalist: \"none\",\n              head: \"none\",\n              link: \"none\",\n              meta: \"none\",\n              noembed: \"none\",\n              noframes: \"none\",\n              param: \"block\",\n              rp: \"none\",\n              script: \"block\",\n              source: \"block\",\n              style: \"none\",\n              template: \"inline\",\n              track: \"block\",\n              title: \"none\",\n              html: \"block\",\n              body: \"block\",\n              address: \"block\",\n              blockquote: \"block\",\n              center: \"block\",\n              div: \"block\",\n              figure: \"block\",\n              figcaption: \"block\",\n              footer: \"block\",\n              form: \"block\",\n              header: \"block\",\n              hr: \"block\",\n              legend: \"block\",\n              listing: \"block\",\n              main: \"block\",\n              p: \"block\",\n              plaintext: \"block\",\n              pre: \"block\",\n              xmp: \"block\",\n              slot: \"contents\",\n              ruby: \"ruby\",\n              rt: \"ruby-text\",\n              article: \"block\",\n              aside: \"block\",\n              h1: \"block\",\n              h2: \"block\",\n              h3: \"block\",\n              h4: \"block\",\n              h5: \"block\",\n              h6: \"block\",\n              hgroup: \"block\",\n              nav: \"block\",\n              section: \"block\",\n              dir: \"block\",\n              dd: \"block\",\n              dl: \"block\",\n              dt: \"block\",\n              ol: \"block\",\n              ul: \"block\",\n              li: \"list-item\",\n              table: \"table\",\n              caption: \"table-caption\",\n              colgroup: \"table-column-group\",\n              col: \"table-column\",\n              thead: \"table-header-group\",\n              tbody: \"table-row-group\",\n              tfoot: \"table-footer-group\",\n              tr: \"table-row\",\n              td: \"table-cell\",\n              th: \"table-cell\",\n              fieldset: \"block\",\n              button: \"inline-block\",\n              details: \"block\",\n              summary: \"block\",\n              dialog: \"block\",\n              meter: \"inline-block\",\n              progress: \"inline-block\",\n              object: \"inline-block\",\n              video: \"inline-block\",\n              audio: \"inline-block\",\n              select: \"inline-block\",\n              option: \"block\",\n              optgroup: \"block\"\n            },\n            CSS_DISPLAY_DEFAULT: \"inline\",\n            CSS_WHITE_SPACE_TAGS: {\n              listing: \"pre\",\n              plaintext: \"pre\",\n              pre: \"pre\",\n              xmp: \"pre\",\n              nobr: \"nowrap\",\n              table: \"initial\",\n              textarea: \"pre-wrap\"\n            },\n            CSS_WHITE_SPACE_DEFAULT: \"normal\"\n          };\n        }\n      }),\n      Kd = Z({\n        \"src/language-html/utils/is-unknown-namespace.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s) {\n            return s.type === \"element\" && !s.hasExplicitNamespace && ![\"html\", \"svg\"].includes(s.namespace);\n          }\n          n.exports = t;\n        }\n      }),\n      qt = Z({\n        \"src/language-html/utils/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              inferParserByLanguage: t,\n              isFrontMatterNode: s\n            } = Ue(),\n            {\n              builders: {\n                line: a,\n                hardline: r,\n                join: u\n              },\n              utils: {\n                getDocParts: i,\n                replaceTextEndOfLine: o\n              }\n            } = Oe(),\n            {\n              CSS_DISPLAY_TAGS: c,\n              CSS_DISPLAY_DEFAULT: v,\n              CSS_WHITE_SPACE_TAGS: m,\n              CSS_WHITE_SPACE_DEFAULT: d\n            } = Xd(),\n            p = Kd(),\n            f = new Set([\"\t\", `\n`, \"\\f\", \"\\r\", \" \"]),\n            h = _ => _.replace(/^[\\t\\n\\f\\r ]+/, \"\"),\n            w = _ => _.replace(/[\\t\\n\\f\\r ]+$/, \"\"),\n            T = _ => h(w(_)),\n            A = _ => _.replace(/^[\\t\\f\\r ]*\\n/g, \"\"),\n            S = _ => A(w(_)),\n            B = _ => _.split(/[\\t\\n\\f\\r ]+/),\n            I = _ => _.match(/^[\\t\\n\\f\\r ]*/)[0],\n            k = _ => {\n              let [, J, ne, Ee] = _.match(/^([\\t\\n\\f\\r ]*)(.*?)([\\t\\n\\f\\r ]*)$/s);\n              return {\n                leadingWhitespace: J,\n                trailingWhitespace: Ee,\n                text: ne\n              };\n            },\n            P = _ => /[\\t\\n\\f\\r ]/.test(_);\n          function C(_, J) {\n            return !!(_.type === \"ieConditionalComment\" && _.lastChild && !_.lastChild.isSelfClosing && !_.lastChild.endSourceSpan || _.type === \"ieConditionalComment\" && !_.complete || le(_) && _.children.some(ne => ne.type !== \"text\" && ne.type !== \"interpolation\") || ye(_, J) && !l(_) && _.type !== \"interpolation\");\n          }\n          function D(_) {\n            return _.type === \"attribute\" || !_.parent || !_.prev ? !1 : g(_.prev);\n          }\n          function g(_) {\n            return _.type === \"comment\" && _.value.trim() === \"prettier-ignore\";\n          }\n          function F(_) {\n            return _.type === \"text\" || _.type === \"comment\";\n          }\n          function l(_) {\n            return _.type === \"element\" && (_.fullName === \"script\" || _.fullName === \"style\" || _.fullName === \"svg:style\" || p(_) && (_.name === \"script\" || _.name === \"style\"));\n          }\n          function E(_) {\n            return _.children && !l(_);\n          }\n          function y(_) {\n            return l(_) || _.type === \"interpolation\" || N(_);\n          }\n          function N(_) {\n            return ke(_).startsWith(\"pre\");\n          }\n          function x(_, J) {\n            let ne = Ee();\n            if (ne && !_.prev && _.parent && _.parent.tagDefinition && _.parent.tagDefinition.ignoreFirstLf) return _.type === \"interpolation\";\n            return ne;\n            function Ee() {\n              return s(_) ? !1 : (_.type === \"text\" || _.type === \"interpolation\") && _.prev && (_.prev.type === \"text\" || _.prev.type === \"interpolation\") ? !0 : !_.parent || _.parent.cssDisplay === \"none\" ? !1 : le(_.parent) ? !0 : !(!_.prev && (_.parent.type === \"root\" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !De(_.parent.cssDisplay)) || _.prev && !z(_.prev.cssDisplay));\n            }\n          }\n          function b(_, J) {\n            return s(_) ? !1 : (_.type === \"text\" || _.type === \"interpolation\") && _.next && (_.next.type === \"text\" || _.next.type === \"interpolation\") ? !0 : !_.parent || _.parent.cssDisplay === \"none\" ? !1 : le(_.parent) ? !0 : !(!_.next && (_.parent.type === \"root\" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !ie(_.parent.cssDisplay)) || _.next && !G(_.next.cssDisplay));\n          }\n          function L(_) {\n            return U(_.cssDisplay) && !l(_);\n          }\n          function M(_) {\n            return s(_) || _.next && _.sourceSpan.end && _.sourceSpan.end.line + 1 < _.next.sourceSpan.start.line;\n          }\n          function j(_) {\n            return $(_) || _.type === \"element\" && _.children.length > 0 && ([\"body\", \"script\", \"style\"].includes(_.name) || _.children.some(J => te(J))) || _.firstChild && _.firstChild === _.lastChild && _.firstChild.type !== \"text\" && H(_.firstChild) && (!_.lastChild.isTrailingSpaceSensitive || R(_.lastChild));\n          }\n          function $(_) {\n            return _.type === \"element\" && _.children.length > 0 && ([\"html\", \"head\", \"ul\", \"ol\", \"select\"].includes(_.name) || _.cssDisplay.startsWith(\"table\") && _.cssDisplay !== \"table-cell\");\n          }\n          function V(_) {\n            return Q(_) || _.prev && q(_.prev) || Y(_);\n          }\n          function q(_) {\n            return Q(_) || _.type === \"element\" && _.fullName === \"br\" || Y(_);\n          }\n          function Y(_) {\n            return H(_) && R(_);\n          }\n          function H(_) {\n            return _.hasLeadingSpaces && (_.prev ? _.prev.sourceSpan.end.line < _.sourceSpan.start.line : _.parent.type === \"root\" || _.parent.startSourceSpan.end.line < _.sourceSpan.start.line);\n          }\n          function R(_) {\n            return _.hasTrailingSpaces && (_.next ? _.next.sourceSpan.start.line > _.sourceSpan.end.line : _.parent.type === \"root\" || _.parent.endSourceSpan && _.parent.endSourceSpan.start.line > _.sourceSpan.end.line);\n          }\n          function Q(_) {\n            switch (_.type) {\n              case \"ieConditionalComment\":\n              case \"comment\":\n              case \"directive\":\n                return !0;\n              case \"element\":\n                return [\"script\", \"select\"].includes(_.name);\n            }\n            return !1;\n          }\n          function ee(_) {\n            return _.lastChild ? ee(_.lastChild) : _;\n          }\n          function te(_) {\n            return _.children && _.children.some(J => J.type !== \"text\");\n          }\n          function oe(_) {\n            let {\n              type: J,\n              lang: ne\n            } = _.attrMap;\n            if (J === \"module\" || J === \"text/javascript\" || J === \"text/babel\" || J === \"application/javascript\" || ne === \"jsx\") return \"babel\";\n            if (J === \"application/x-typescript\" || ne === \"ts\" || ne === \"tsx\") return \"typescript\";\n            if (J === \"text/markdown\") return \"markdown\";\n            if (J === \"text/html\") return \"html\";\n            if (J && (J.endsWith(\"json\") || J.endsWith(\"importmap\")) || J === \"speculationrules\") return \"json\";\n            if (J === \"text/x-handlebars-template\") return \"glimmer\";\n          }\n          function W(_, J) {\n            let {\n              lang: ne\n            } = _.attrMap;\n            if (!ne || ne === \"postcss\" || ne === \"css\") return \"css\";\n            if (ne === \"scss\") return \"scss\";\n            if (ne === \"less\") return \"less\";\n            if (ne === \"stylus\") return t(\"stylus\", J);\n          }\n          function X(_, J) {\n            if (_.name === \"script\" && !_.attrMap.src) return !_.attrMap.lang && !_.attrMap.type ? \"babel\" : oe(_);\n            if (_.name === \"style\") return W(_, J);\n            if (J && ye(_, J)) return oe(_) || !(\"src\" in _.attrMap) && t(_.attrMap.lang, J);\n          }\n          function ue(_) {\n            return _ === \"block\" || _ === \"list-item\" || _.startsWith(\"table\");\n          }\n          function De(_) {\n            return !ue(_) && _ !== \"inline-block\";\n          }\n          function ie(_) {\n            return !ue(_) && _ !== \"inline-block\";\n          }\n          function G(_) {\n            return !ue(_);\n          }\n          function z(_) {\n            return !ue(_);\n          }\n          function U(_) {\n            return !ue(_) && _ !== \"inline-block\";\n          }\n          function le(_) {\n            return ke(_).startsWith(\"pre\");\n          }\n          function ge(_, J) {\n            let ne = 0;\n            for (let Ee = _.stack.length - 1; Ee >= 0; Ee--) {\n              let We = _.stack[Ee];\n              We && typeof We == \"object\" && !Array.isArray(We) && J(We) && ne++;\n            }\n            return ne;\n          }\n          function Ae(_, J) {\n            let ne = _;\n            for (; ne;) {\n              if (J(ne)) return !0;\n              ne = ne.parent;\n            }\n            return !1;\n          }\n          function Ne(_, J) {\n            if (_.prev && _.prev.type === \"comment\") {\n              let Ee = _.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);\n              if (Ee) return Ee[1];\n            }\n            let ne = !1;\n            if (_.type === \"element\" && _.namespace === \"svg\") if (Ae(_, Ee => Ee.fullName === \"svg:foreignObject\")) ne = !0;else return _.name === \"svg\" ? \"inline-block\" : \"block\";\n            switch (J.htmlWhitespaceSensitivity) {\n              case \"strict\":\n                return \"inline\";\n              case \"ignore\":\n                return \"block\";\n              default:\n                return J.parser === \"vue\" && _.parent && _.parent.type === \"root\" ? \"block\" : _.type === \"element\" && (!_.namespace || ne || p(_)) && c[_.name] || v;\n            }\n          }\n          function ke(_) {\n            return _.type === \"element\" && (!_.namespace || p(_)) && m[_.name] || d;\n          }\n          function ce(_) {\n            let J = Number.POSITIVE_INFINITY;\n            for (let ne of _.split(`\n`)) {\n              if (ne.length === 0) continue;\n              if (!f.has(ne[0])) return 0;\n              let Ee = I(ne).length;\n              ne.length !== Ee && Ee < J && (J = Ee);\n            }\n            return J === Number.POSITIVE_INFINITY ? 0 : J;\n          }\n          function pe(_) {\n            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ce(_);\n            return J === 0 ? _ : _.split(`\n`).map(ne => ne.slice(J)).join(`\n`);\n          }\n          function de(_, J) {\n            let ne = 0;\n            for (let Ee = 0; Ee < _.length; Ee++) _[Ee] === J && ne++;\n            return ne;\n          }\n          function ae(_) {\n            return _.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n          }\n          var ve = new Set([\"template\", \"style\", \"script\"]);\n          function K(_, J) {\n            return he(_, J) && !ve.has(_.fullName);\n          }\n          function he(_, J) {\n            return J.parser === \"vue\" && _.type === \"element\" && _.parent.type === \"root\" && _.fullName.toLowerCase() !== \"html\";\n          }\n          function ye(_, J) {\n            return he(_, J) && (K(_, J) || _.attrMap.lang && _.attrMap.lang !== \"html\");\n          }\n          function Ce(_) {\n            let J = _.fullName;\n            return J.charAt(0) === \"#\" || J === \"slot-scope\" || J === \"v-slot\" || J.startsWith(\"v-slot:\");\n          }\n          function Ie(_, J) {\n            let ne = _.parent;\n            if (!he(ne, J)) return !1;\n            let Ee = ne.fullName,\n              We = _.fullName;\n            return Ee === \"script\" && We === \"setup\" || Ee === \"style\" && We === \"vars\";\n          }\n          function Fe(_) {\n            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.value;\n            return _.parent.isWhitespaceSensitive ? _.parent.isIndentationSensitive ? o(J) : o(pe(S(J)), r) : i(u(a, B(J)));\n          }\n          function me(_, J) {\n            return he(_, J) && _.name === \"script\";\n          }\n          n.exports = {\n            htmlTrim: T,\n            htmlTrimPreserveIndentation: S,\n            hasHtmlWhitespace: P,\n            getLeadingAndTrailingHtmlWhitespace: k,\n            canHaveInterpolation: E,\n            countChars: de,\n            countParents: ge,\n            dedentString: pe,\n            forceBreakChildren: $,\n            forceBreakContent: j,\n            forceNextEmptyLine: M,\n            getLastDescendant: ee,\n            getNodeCssStyleDisplay: Ne,\n            getNodeCssStyleWhiteSpace: ke,\n            hasPrettierIgnore: D,\n            inferScriptParser: X,\n            isVueCustomBlock: K,\n            isVueNonHtmlBlock: ye,\n            isVueScriptTag: me,\n            isVueSlotAttribute: Ce,\n            isVueSfcBindingsAttribute: Ie,\n            isVueSfcBlock: he,\n            isDanglingSpaceSensitiveNode: L,\n            isIndentationSensitiveNode: N,\n            isLeadingSpaceSensitiveNode: x,\n            isPreLikeNode: le,\n            isScriptLikeTag: l,\n            isTextLikeNode: F,\n            isTrailingSpaceSensitiveNode: b,\n            isWhitespaceSensitiveNode: y,\n            isUnknownNamespace: p,\n            preferHardlineAsLeadingSpaces: V,\n            preferHardlineAsTrailingSpaces: q,\n            shouldPreserveContent: C,\n            unescapeQuoteEntities: ae,\n            getTextValueParts: Fe\n          };\n        }\n      }),\n      Yd = Z({\n        \"node_modules/angular-html-parser/lib/compiler/src/chars.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;\n          function n(i) {\n            return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;\n          }\n          e.isWhitespace = n;\n          function t(i) {\n            return e.$0 <= i && i <= e.$9;\n          }\n          e.isDigit = t;\n          function s(i) {\n            return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;\n          }\n          e.isAsciiLetter = s;\n          function a(i) {\n            return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);\n          }\n          e.isAsciiHexDigit = a;\n          function r(i) {\n            return i === e.$LF || i === e.$CR;\n          }\n          e.isNewLine = r;\n          function u(i) {\n            return e.$0 <= i && i <= e.$7;\n          }\n          e.isOctalDigit = u;\n        }\n      }),\n      Qd = Z({\n        \"node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = class {\n            constructor(s, a, r) {\n              this.filePath = s, this.name = a, this.members = r;\n            }\n            assertNoMembers() {\n              if (this.members.length) throw new Error(\"Illegal state: symbol without members expected, but got \".concat(JSON.stringify(this), \".\"));\n            }\n          };\n          e.StaticSymbol = n;\n          var t = class {\n            constructor() {\n              this.cache = new Map();\n            }\n            get(s, a, r) {\n              r = r || [];\n              let u = r.length ? \".\".concat(r.join(\".\")) : \"\",\n                i = '\"'.concat(s, '\".').concat(a).concat(u),\n                o = this.cache.get(i);\n              return o || (o = new n(s, a, r), this.cache.set(i, o)), o;\n            }\n          };\n          e.StaticSymbolCache = t;\n        }\n      }),\n      Zd = Z({\n        \"node_modules/angular-html-parser/lib/compiler/src/util.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = /-+([a-z0-9])/g;\n          function t(l) {\n            return l.replace(n, function () {\n              for (var E = arguments.length, y = new Array(E), N = 0; N < E; N++) y[N] = arguments[N];\n              return y[1].toUpperCase();\n            });\n          }\n          e.dashCaseToCamelCase = t;\n          function s(l, E) {\n            return r(l, \":\", E);\n          }\n          e.splitAtColon = s;\n          function a(l, E) {\n            return r(l, \".\", E);\n          }\n          e.splitAtPeriod = a;\n          function r(l, E, y) {\n            let N = l.indexOf(E);\n            return N == -1 ? y : [l.slice(0, N).trim(), l.slice(N + 1).trim()];\n          }\n          function u(l, E, y) {\n            return Array.isArray(l) ? E.visitArray(l, y) : A(l) ? E.visitStringMap(l, y) : l == null || typeof l == \"string\" || typeof l == \"number\" || typeof l == \"boolean\" ? E.visitPrimitive(l, y) : E.visitOther(l, y);\n          }\n          e.visitValue = u;\n          function i(l) {\n            return l != null;\n          }\n          e.isDefined = i;\n          function o(l) {\n            return l === void 0 ? null : l;\n          }\n          e.noUndefined = o;\n          var c = class {\n            visitArray(l, E) {\n              return l.map(y => u(y, this, E));\n            }\n            visitStringMap(l, E) {\n              let y = {};\n              return Object.keys(l).forEach(N => {\n                y[N] = u(l[N], this, E);\n              }), y;\n            }\n            visitPrimitive(l, E) {\n              return l;\n            }\n            visitOther(l, E) {\n              return l;\n            }\n          };\n          e.ValueTransformer = c, e.SyncAsync = {\n            assertSync: l => {\n              if (k(l)) throw new Error(\"Illegal state: value cannot be a promise\");\n              return l;\n            },\n            then: (l, E) => k(l) ? l.then(E) : E(l),\n            all: l => l.some(k) ? Promise.all(l) : l\n          };\n          function v(l) {\n            throw new Error(\"Internal Error: \".concat(l));\n          }\n          e.error = v;\n          function m(l, E) {\n            let y = Error(l);\n            return y[d] = !0, E && (y[p] = E), y;\n          }\n          e.syntaxError = m;\n          var d = \"ngSyntaxError\",\n            p = \"ngParseErrors\";\n          function f(l) {\n            return l[d];\n          }\n          e.isSyntaxError = f;\n          function h(l) {\n            return l[p] || [];\n          }\n          e.getParseErrors = h;\n          function w(l) {\n            return l.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n          }\n          e.escapeRegExp = w;\n          var T = Object.getPrototypeOf({});\n          function A(l) {\n            return typeof l == \"object\" && l !== null && Object.getPrototypeOf(l) === T;\n          }\n          function S(l) {\n            let E = \"\";\n            for (let y = 0; y < l.length; y++) {\n              let N = l.charCodeAt(y);\n              if (N >= 55296 && N <= 56319 && l.length > y + 1) {\n                let x = l.charCodeAt(y + 1);\n                x >= 56320 && x <= 57343 && (y++, N = (N - 55296 << 10) + x - 56320 + 65536);\n              }\n              N <= 127 ? E += String.fromCharCode(N) : N <= 2047 ? E += String.fromCharCode(N >> 6 & 31 | 192, N & 63 | 128) : N <= 65535 ? E += String.fromCharCode(N >> 12 | 224, N >> 6 & 63 | 128, N & 63 | 128) : N <= 2097151 && (E += String.fromCharCode(N >> 18 & 7 | 240, N >> 12 & 63 | 128, N >> 6 & 63 | 128, N & 63 | 128));\n            }\n            return E;\n          }\n          e.utf8Encode = S;\n          function B(l) {\n            if (typeof l == \"string\") return l;\n            if (l instanceof Array) return \"[\" + l.map(B).join(\", \") + \"]\";\n            if (l == null) return \"\" + l;\n            if (l.overriddenName) return \"\".concat(l.overriddenName);\n            if (l.name) return \"\".concat(l.name);\n            if (!l.toString) return \"object\";\n            let E = l.toString();\n            if (E == null) return \"\" + E;\n            let y = E.indexOf(`\n`);\n            return y === -1 ? E : E.substring(0, y);\n          }\n          e.stringify = B;\n          function I(l) {\n            return typeof l == \"function\" && l.hasOwnProperty(\"__forward_ref__\") ? l() : l;\n          }\n          e.resolveForwardRef = I;\n          function k(l) {\n            return !!l && typeof l.then == \"function\";\n          }\n          e.isPromise = k;\n          var P = class {\n            constructor(l) {\n              this.full = l;\n              let E = l.split(\".\");\n              this.major = E[0], this.minor = E[1], this.patch = E.slice(2).join(\".\");\n            }\n          };\n          e.Version = P;\n          var C = typeof window < \"u\" && window,\n            D = typeof self < \"u\" && typeof WorkerGlobalScope < \"u\" && self instanceof WorkerGlobalScope && self,\n            g = typeof globalThis < \"u\" && globalThis,\n            F = g || C || D;\n          e.global = F;\n        }\n      }),\n      eg = Z({\n        \"node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = Qd(),\n            t = Zd(),\n            s = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n          function a(y) {\n            return y.replace(/\\W/g, \"_\");\n          }\n          e.sanitizeIdentifier = a;\n          var r = 0;\n          function u(y) {\n            if (!y || !y.reference) return null;\n            let N = y.reference;\n            if (N instanceof n.StaticSymbol) return N.name;\n            if (N.__anonymousType) return N.__anonymousType;\n            let x = t.stringify(N);\n            return x.indexOf(\"(\") >= 0 ? (x = \"anonymous_\".concat(r++), N.__anonymousType = x) : x = a(x), x;\n          }\n          e.identifierName = u;\n          function i(y) {\n            let N = y.reference;\n            return N instanceof n.StaticSymbol ? N.filePath : \"./\".concat(t.stringify(N));\n          }\n          e.identifierModuleUrl = i;\n          function o(y, N) {\n            return \"View_\".concat(u({\n              reference: y\n            }), \"_\").concat(N);\n          }\n          e.viewClassName = o;\n          function c(y) {\n            return \"RenderType_\".concat(u({\n              reference: y\n            }));\n          }\n          e.rendererTypeName = c;\n          function v(y) {\n            return \"HostView_\".concat(u({\n              reference: y\n            }));\n          }\n          e.hostViewClassName = v;\n          function m(y) {\n            return \"\".concat(u({\n              reference: y\n            }), \"NgFactory\");\n          }\n          e.componentFactoryName = m;\n          var d;\n          (function (y) {\n            y[y.Pipe = 0] = \"Pipe\", y[y.Directive = 1] = \"Directive\", y[y.NgModule = 2] = \"NgModule\", y[y.Injectable = 3] = \"Injectable\";\n          })(d = e.CompileSummaryKind || (e.CompileSummaryKind = {}));\n          function p(y) {\n            return y.value != null ? a(y.value) : u(y.identifier);\n          }\n          e.tokenName = p;\n          function f(y) {\n            return y.identifier != null ? y.identifier.reference : y.value;\n          }\n          e.tokenReference = f;\n          var h = class {\n            constructor() {\n              let {\n                moduleUrl: y,\n                styles: N,\n                styleUrls: x\n              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n              this.moduleUrl = y || null, this.styles = k(N), this.styleUrls = k(x);\n            }\n          };\n          e.CompileStylesheetMetadata = h;\n          var w = class {\n            constructor(y) {\n              let {\n                encapsulation: N,\n                template: x,\n                templateUrl: b,\n                htmlAst: L,\n                styles: M,\n                styleUrls: j,\n                externalStylesheets: $,\n                animations: V,\n                ngContentSelectors: q,\n                interpolation: Y,\n                isInline: H,\n                preserveWhitespaces: R\n              } = y;\n              if (this.encapsulation = N, this.template = x, this.templateUrl = b, this.htmlAst = L, this.styles = k(M), this.styleUrls = k(j), this.externalStylesheets = k($), this.animations = V ? C(V) : [], this.ngContentSelectors = q || [], Y && Y.length != 2) throw new Error(\"'interpolation' should have a start and an end symbol.\");\n              this.interpolation = Y, this.isInline = H, this.preserveWhitespaces = R;\n            }\n            toSummary() {\n              return {\n                ngContentSelectors: this.ngContentSelectors,\n                encapsulation: this.encapsulation,\n                styles: this.styles,\n                animations: this.animations\n              };\n            }\n          };\n          e.CompileTemplateMetadata = w;\n          var T = class {\n            static create(y) {\n              let {\n                  isHost: N,\n                  type: x,\n                  isComponent: b,\n                  selector: L,\n                  exportAs: M,\n                  changeDetection: j,\n                  inputs: $,\n                  outputs: V,\n                  host: q,\n                  providers: Y,\n                  viewProviders: H,\n                  queries: R,\n                  guards: Q,\n                  viewQueries: ee,\n                  entryComponents: te,\n                  template: oe,\n                  componentViewType: W,\n                  rendererType: X,\n                  componentFactory: ue\n                } = y,\n                De = {},\n                ie = {},\n                G = {};\n              q != null && Object.keys(q).forEach(le => {\n                let ge = q[le],\n                  Ae = le.match(s);\n                Ae === null ? G[le] = ge : Ae[1] != null ? ie[Ae[1]] = ge : Ae[2] != null && (De[Ae[2]] = ge);\n              });\n              let z = {};\n              $ != null && $.forEach(le => {\n                let ge = t.splitAtColon(le, [le, le]);\n                z[ge[0]] = ge[1];\n              });\n              let U = {};\n              return V != null && V.forEach(le => {\n                let ge = t.splitAtColon(le, [le, le]);\n                U[ge[0]] = ge[1];\n              }), new T({\n                isHost: N,\n                type: x,\n                isComponent: !!b,\n                selector: L,\n                exportAs: M,\n                changeDetection: j,\n                inputs: z,\n                outputs: U,\n                hostListeners: De,\n                hostProperties: ie,\n                hostAttributes: G,\n                providers: Y,\n                viewProviders: H,\n                queries: R,\n                guards: Q,\n                viewQueries: ee,\n                entryComponents: te,\n                template: oe,\n                componentViewType: W,\n                rendererType: X,\n                componentFactory: ue\n              });\n            }\n            constructor(y) {\n              let {\n                isHost: N,\n                type: x,\n                isComponent: b,\n                selector: L,\n                exportAs: M,\n                changeDetection: j,\n                inputs: $,\n                outputs: V,\n                hostListeners: q,\n                hostProperties: Y,\n                hostAttributes: H,\n                providers: R,\n                viewProviders: Q,\n                queries: ee,\n                guards: te,\n                viewQueries: oe,\n                entryComponents: W,\n                template: X,\n                componentViewType: ue,\n                rendererType: De,\n                componentFactory: ie\n              } = y;\n              this.isHost = !!N, this.type = x, this.isComponent = b, this.selector = L, this.exportAs = M, this.changeDetection = j, this.inputs = $, this.outputs = V, this.hostListeners = q, this.hostProperties = Y, this.hostAttributes = H, this.providers = k(R), this.viewProviders = k(Q), this.queries = k(ee), this.guards = te, this.viewQueries = k(oe), this.entryComponents = k(W), this.template = X, this.componentViewType = ue, this.rendererType = De, this.componentFactory = ie;\n            }\n            toSummary() {\n              return {\n                summaryKind: d.Directive,\n                type: this.type,\n                isComponent: this.isComponent,\n                selector: this.selector,\n                exportAs: this.exportAs,\n                inputs: this.inputs,\n                outputs: this.outputs,\n                hostListeners: this.hostListeners,\n                hostProperties: this.hostProperties,\n                hostAttributes: this.hostAttributes,\n                providers: this.providers,\n                viewProviders: this.viewProviders,\n                queries: this.queries,\n                guards: this.guards,\n                viewQueries: this.viewQueries,\n                entryComponents: this.entryComponents,\n                changeDetection: this.changeDetection,\n                template: this.template && this.template.toSummary(),\n                componentViewType: this.componentViewType,\n                rendererType: this.rendererType,\n                componentFactory: this.componentFactory\n              };\n            }\n          };\n          e.CompileDirectiveMetadata = T;\n          var A = class {\n            constructor(y) {\n              let {\n                type: N,\n                name: x,\n                pure: b\n              } = y;\n              this.type = N, this.name = x, this.pure = !!b;\n            }\n            toSummary() {\n              return {\n                summaryKind: d.Pipe,\n                type: this.type,\n                name: this.name,\n                pure: this.pure\n              };\n            }\n          };\n          e.CompilePipeMetadata = A;\n          var S = class {};\n          e.CompileShallowModuleMetadata = S;\n          var B = class {\n            constructor(y) {\n              let {\n                type: N,\n                providers: x,\n                declaredDirectives: b,\n                exportedDirectives: L,\n                declaredPipes: M,\n                exportedPipes: j,\n                entryComponents: $,\n                bootstrapComponents: V,\n                importedModules: q,\n                exportedModules: Y,\n                schemas: H,\n                transitiveModule: R,\n                id: Q\n              } = y;\n              this.type = N || null, this.declaredDirectives = k(b), this.exportedDirectives = k(L), this.declaredPipes = k(M), this.exportedPipes = k(j), this.providers = k(x), this.entryComponents = k($), this.bootstrapComponents = k(V), this.importedModules = k(q), this.exportedModules = k(Y), this.schemas = k(H), this.id = Q || null, this.transitiveModule = R || null;\n            }\n            toSummary() {\n              let y = this.transitiveModule;\n              return {\n                summaryKind: d.NgModule,\n                type: this.type,\n                entryComponents: y.entryComponents,\n                providers: y.providers,\n                modules: y.modules,\n                exportedDirectives: y.exportedDirectives,\n                exportedPipes: y.exportedPipes\n              };\n            }\n          };\n          e.CompileNgModuleMetadata = B;\n          var I = class {\n            constructor() {\n              this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];\n            }\n            addProvider(y, N) {\n              this.providers.push({\n                provider: y,\n                module: N\n              });\n            }\n            addDirective(y) {\n              this.directivesSet.has(y.reference) || (this.directivesSet.add(y.reference), this.directives.push(y));\n            }\n            addExportedDirective(y) {\n              this.exportedDirectivesSet.has(y.reference) || (this.exportedDirectivesSet.add(y.reference), this.exportedDirectives.push(y));\n            }\n            addPipe(y) {\n              this.pipesSet.has(y.reference) || (this.pipesSet.add(y.reference), this.pipes.push(y));\n            }\n            addExportedPipe(y) {\n              this.exportedPipesSet.has(y.reference) || (this.exportedPipesSet.add(y.reference), this.exportedPipes.push(y));\n            }\n            addModule(y) {\n              this.modulesSet.has(y.reference) || (this.modulesSet.add(y.reference), this.modules.push(y));\n            }\n            addEntryComponent(y) {\n              this.entryComponentsSet.has(y.componentType) || (this.entryComponentsSet.add(y.componentType), this.entryComponents.push(y));\n            }\n          };\n          e.TransitiveCompileNgModuleMetadata = I;\n          function k(y) {\n            return y || [];\n          }\n          var P = class {\n            constructor(y, N) {\n              let {\n                useClass: x,\n                useValue: b,\n                useExisting: L,\n                useFactory: M,\n                deps: j,\n                multi: $\n              } = N;\n              this.token = y, this.useClass = x || null, this.useValue = b, this.useExisting = L, this.useFactory = M || null, this.dependencies = j || null, this.multi = !!$;\n            }\n          };\n          e.ProviderMeta = P;\n          function C(y) {\n            return y.reduce((N, x) => {\n              let b = Array.isArray(x) ? C(x) : x;\n              return N.concat(b);\n            }, []);\n          }\n          e.flatten = C;\n          function D(y) {\n            return y.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, \"ng:///\");\n          }\n          function g(y, N, x) {\n            let b;\n            return x.isInline ? N.type.reference instanceof n.StaticSymbol ? b = \"\".concat(N.type.reference.filePath, \".\").concat(N.type.reference.name, \".html\") : b = \"\".concat(u(y), \"/\").concat(u(N.type), \".html\") : b = x.templateUrl, N.type.reference instanceof n.StaticSymbol ? b : D(b);\n          }\n          e.templateSourceUrl = g;\n          function F(y, N) {\n            let x = y.moduleUrl.split(/\\/\\\\/g),\n              b = x[x.length - 1];\n            return D(\"css/\".concat(N).concat(b, \".ngstyle.js\"));\n          }\n          e.sharedStylesheetJitUrl = F;\n          function l(y) {\n            return D(\"\".concat(u(y.type), \"/module.ngfactory.js\"));\n          }\n          e.ngModuleJitUrl = l;\n          function E(y, N) {\n            return D(\"\".concat(u(y), \"/\").concat(u(N.type), \".ngfactory.js\"));\n          }\n          e.templateJitUrl = E;\n        }\n      }),\n      tg = Z({\n        \"node_modules/angular-html-parser/lib/compiler/src/parse_util.js\"(e) {\n          \"use strict\";\n\n          re(), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n          });\n          var n = Yd(),\n            t = eg(),\n            s = class {\n              constructor(v, m, d, p) {\n                this.file = v, this.offset = m, this.line = d, this.col = p;\n              }\n              toString() {\n                return this.offset != null ? \"\".concat(this.file.url, \"@\").concat(this.line, \":\").concat(this.col) : this.file.url;\n              }\n              moveBy(v) {\n                let m = this.file.content,\n                  d = m.length,\n                  p = this.offset,\n                  f = this.line,\n                  h = this.col;\n                for (; p > 0 && v < 0;) if (p--, v++, m.charCodeAt(p) == n.$LF) {\n                  f--;\n                  let T = m.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));\n                  h = T > 0 ? p - T : p;\n                } else h--;\n                for (; p < d && v > 0;) {\n                  let w = m.charCodeAt(p);\n                  p++, v--, w == n.$LF ? (f++, h = 0) : h++;\n                }\n                return new s(this.file, p, f, h);\n              }\n              getContext(v, m) {\n                let d = this.file.content,\n                  p = this.offset;\n                if (p != null) {\n                  p > d.length - 1 && (p = d.length - 1);\n                  let f = p,\n                    h = 0,\n                    w = 0;\n                  for (; h < v && p > 0 && (p--, h++, !(d[p] == `\n` && ++w == m)););\n                  for (h = 0, w = 0; h < v && f < d.length - 1 && (f++, h++, !(d[f] == `\n` && ++w == m)););\n                  return {\n                    before: d.substring(p, this.offset),\n                    after: d.substring(this.offset, f + 1)\n                  };\n                }\n                return null;\n              }\n            };\n          e.ParseLocation = s;\n          var a = class {\n            constructor(v, m) {\n              this.content = v, this.url = m;\n            }\n          };\n          e.ParseSourceFile = a;\n          var r = class {\n            constructor(v, m) {\n              let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n              this.start = v, this.end = m, this.details = d;\n            }\n            toString() {\n              return this.start.file.content.substring(this.start.offset, this.end.offset);\n            }\n          };\n          e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s(new a(\"\", \"\"), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);\n          var u;\n          (function (v) {\n            v[v.WARNING = 0] = \"WARNING\", v[v.ERROR = 1] = \"ERROR\";\n          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));\n          var i = class {\n            constructor(v, m) {\n              let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;\n              this.span = v, this.msg = m, this.level = d;\n            }\n            contextualMessage() {\n              let v = this.span.start.getContext(100, 3);\n              return v ? \"\".concat(this.msg, ' (\"').concat(v.before, \"[\").concat(u[this.level], \" ->]\").concat(v.after, '\")') : this.msg;\n            }\n            toString() {\n              let v = this.span.details ? \", \".concat(this.span.details) : \"\";\n              return \"\".concat(this.contextualMessage(), \": \").concat(this.span.start).concat(v);\n            }\n          };\n          e.ParseError = i;\n          function o(v, m) {\n            let d = t.identifierModuleUrl(m),\n              p = d != null ? \"in \".concat(v, \" \").concat(t.identifierName(m), \" in \").concat(d) : \"in \".concat(v, \" \").concat(t.identifierName(m)),\n              f = new a(\"\", p);\n            return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));\n          }\n          e.typeSourceSpan = o;\n          function c(v, m, d) {\n            let p = \"in \".concat(v, \" \").concat(m, \" in \").concat(d),\n              f = new a(\"\", p);\n            return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));\n          }\n          e.r3JitTypeSourceSpan = c;\n        }\n      }),\n      rg = Z({\n        \"src/language-html/print-preprocess.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              ParseSourceSpan: t\n            } = tg(),\n            {\n              htmlTrim: s,\n              getLeadingAndTrailingHtmlWhitespace: a,\n              hasHtmlWhitespace: r,\n              canHaveInterpolation: u,\n              getNodeCssStyleDisplay: i,\n              isDanglingSpaceSensitiveNode: o,\n              isIndentationSensitiveNode: c,\n              isLeadingSpaceSensitiveNode: v,\n              isTrailingSpaceSensitiveNode: m,\n              isWhitespaceSensitiveNode: d,\n              isVueScriptTag: p\n            } = qt(),\n            f = [w, T, S, I, k, D, P, C, g, B, F];\n          function h(l, E) {\n            for (let y of f) y(l, E);\n            return l;\n          }\n          function w(l) {\n            l.walk(E => {\n              if (E.type === \"element\" && E.tagDefinition.ignoreFirstLf && E.children.length > 0 && E.children[0].type === \"text\" && E.children[0].value[0] === `\n`) {\n                let y = E.children[0];\n                y.value.length === 1 ? E.removeChild(y) : y.value = y.value.slice(1);\n              }\n            });\n          }\n          function T(l) {\n            let E = y => y.type === \"element\" && y.prev && y.prev.type === \"ieConditionalStartComment\" && y.prev.sourceSpan.end.offset === y.startSourceSpan.start.offset && y.firstChild && y.firstChild.type === \"ieConditionalEndComment\" && y.firstChild.sourceSpan.start.offset === y.startSourceSpan.end.offset;\n            l.walk(y => {\n              if (y.children) for (let N = 0; N < y.children.length; N++) {\n                let x = y.children[N];\n                if (!E(x)) continue;\n                let b = x.prev,\n                  L = x.firstChild;\n                y.removeChild(b), N--;\n                let M = new t(b.sourceSpan.start, L.sourceSpan.end),\n                  j = new t(M.start, x.sourceSpan.end);\n                x.condition = b.condition, x.sourceSpan = j, x.startSourceSpan = M, x.removeChild(L);\n              }\n            });\n          }\n          function A(l, E, y) {\n            l.walk(N => {\n              if (N.children) for (let x = 0; x < N.children.length; x++) {\n                let b = N.children[x];\n                if (b.type !== \"text\" && !E(b)) continue;\n                b.type !== \"text\" && (b.type = \"text\", b.value = y(b));\n                let L = b.prev;\n                !L || L.type !== \"text\" || (L.value += b.value, L.sourceSpan = new t(L.sourceSpan.start, b.sourceSpan.end), N.removeChild(b), x--);\n              }\n            });\n          }\n          function S(l) {\n            return A(l, E => E.type === \"cdata\", E => \"<![CDATA[\".concat(E.value, \"]]>\"));\n          }\n          function B(l) {\n            let E = y => y.type === \"element\" && y.attrs.length === 0 && y.children.length === 1 && y.firstChild.type === \"text\" && !r(y.children[0].value) && !y.firstChild.hasLeadingSpaces && !y.firstChild.hasTrailingSpaces && y.isLeadingSpaceSensitive && !y.hasLeadingSpaces && y.isTrailingSpaceSensitive && !y.hasTrailingSpaces && y.prev && y.prev.type === \"text\" && y.next && y.next.type === \"text\";\n            l.walk(y => {\n              if (y.children) for (let N = 0; N < y.children.length; N++) {\n                let x = y.children[N];\n                if (!E(x)) continue;\n                let b = x.prev,\n                  L = x.next;\n                b.value += \"<\".concat(x.rawName, \">\") + x.firstChild.value + \"</\".concat(x.rawName, \">\") + L.value, b.sourceSpan = new t(b.sourceSpan.start, L.sourceSpan.end), b.isTrailingSpaceSensitive = L.isTrailingSpaceSensitive, b.hasTrailingSpaces = L.hasTrailingSpaces, y.removeChild(x), N--, y.removeChild(L);\n              }\n            });\n          }\n          function I(l, E) {\n            if (E.parser === \"html\") return;\n            let y = /{{(.+?)}}/s;\n            l.walk(N => {\n              if (!!u(N)) for (let x of N.children) {\n                if (x.type !== \"text\") continue;\n                let b = x.sourceSpan.start,\n                  L = null,\n                  M = x.value.split(y);\n                for (let j = 0; j < M.length; j++, b = L) {\n                  let $ = M[j];\n                  if (j % 2 === 0) {\n                    L = b.moveBy($.length), $.length > 0 && N.insertChildBefore(x, {\n                      type: \"text\",\n                      value: $,\n                      sourceSpan: new t(b, L)\n                    });\n                    continue;\n                  }\n                  L = b.moveBy($.length + 4), N.insertChildBefore(x, {\n                    type: \"interpolation\",\n                    sourceSpan: new t(b, L),\n                    children: $.length === 0 ? [] : [{\n                      type: \"text\",\n                      value: $,\n                      sourceSpan: new t(b.moveBy(2), L.moveBy(-2))\n                    }]\n                  });\n                }\n                N.removeChild(x);\n              }\n            });\n          }\n          function k(l) {\n            l.walk(E => {\n              if (!E.children) return;\n              if (E.children.length === 0 || E.children.length === 1 && E.children[0].type === \"text\" && s(E.children[0].value).length === 0) {\n                E.hasDanglingSpaces = E.children.length > 0, E.children = [];\n                return;\n              }\n              let y = d(E),\n                N = c(E);\n              if (!y) for (let x = 0; x < E.children.length; x++) {\n                let b = E.children[x];\n                if (b.type !== \"text\") continue;\n                let {\n                    leadingWhitespace: L,\n                    text: M,\n                    trailingWhitespace: j\n                  } = a(b.value),\n                  $ = b.prev,\n                  V = b.next;\n                M ? (b.value = M, b.sourceSpan = new t(b.sourceSpan.start.moveBy(L.length), b.sourceSpan.end.moveBy(-j.length)), L && ($ && ($.hasTrailingSpaces = !0), b.hasLeadingSpaces = !0), j && (b.hasTrailingSpaces = !0, V && (V.hasLeadingSpaces = !0))) : (E.removeChild(b), x--, (L || j) && ($ && ($.hasTrailingSpaces = !0), V && (V.hasLeadingSpaces = !0)));\n              }\n              E.isWhitespaceSensitive = y, E.isIndentationSensitive = N;\n            });\n          }\n          function P(l) {\n            l.walk(E => {\n              E.isSelfClosing = !E.children || E.type === \"element\" && (E.tagDefinition.isVoid || E.startSourceSpan === E.endSourceSpan);\n            });\n          }\n          function C(l, E) {\n            l.walk(y => {\n              y.type === \"element\" && (y.hasHtmComponentClosingTag = y.endSourceSpan && /^<\\s*\\/\\s*\\/\\s*>$/.test(E.originalText.slice(y.endSourceSpan.start.offset, y.endSourceSpan.end.offset)));\n            });\n          }\n          function D(l, E) {\n            l.walk(y => {\n              y.cssDisplay = i(y, E);\n            });\n          }\n          function g(l, E) {\n            l.walk(y => {\n              let {\n                children: N\n              } = y;\n              if (!!N) {\n                if (N.length === 0) {\n                  y.isDanglingSpaceSensitive = o(y);\n                  return;\n                }\n                for (let x of N) x.isLeadingSpaceSensitive = v(x, E), x.isTrailingSpaceSensitive = m(x, E);\n                for (let x = 0; x < N.length; x++) {\n                  let b = N[x];\n                  b.isLeadingSpaceSensitive = (x === 0 || b.prev.isTrailingSpaceSensitive) && b.isLeadingSpaceSensitive, b.isTrailingSpaceSensitive = (x === N.length - 1 || b.next.isLeadingSpaceSensitive) && b.isTrailingSpaceSensitive;\n                }\n              }\n            });\n          }\n          function F(l, E) {\n            if (E.parser === \"vue\") {\n              let y = l.children.find(x => p(x, E));\n              if (!y) return;\n              let {\n                lang: N\n              } = y.attrMap;\n              (N === \"ts\" || N === \"typescript\") && (E.__should_parse_vue_template_with_ts = !0);\n            }\n          }\n          n.exports = h;\n        }\n      }),\n      ng = Z({\n        \"src/language-html/pragma.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(a) {\n            return /^\\s*<!--\\s*@(?:format|prettier)\\s*-->/.test(a);\n          }\n          function s(a) {\n            return `<!-- @format -->\n\n` + a.replace(/^\\s*\\n/, \"\");\n          }\n          n.exports = {\n            hasPragma: t,\n            insertPragma: s\n          };\n        }\n      }),\n      Yn = Z({\n        \"src/language-html/loc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(a) {\n            return a.sourceSpan.start.offset;\n          }\n          function s(a) {\n            return a.sourceSpan.end.offset;\n          }\n          n.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      er = Z({\n        \"src/language-html/print/tag.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Xt(),\n            {\n              isNonEmptyArray: s\n            } = Ue(),\n            {\n              builders: {\n                indent: a,\n                join: r,\n                line: u,\n                softline: i,\n                hardline: o\n              },\n              utils: {\n                replaceTextEndOfLine: c\n              }\n            } = Oe(),\n            {\n              locStart: v,\n              locEnd: m\n            } = Yn(),\n            {\n              isTextLikeNode: d,\n              getLastDescendant: p,\n              isPreLikeNode: f,\n              hasPrettierIgnore: h,\n              shouldPreserveContent: w,\n              isVueSfcBlock: T\n            } = qt();\n          function A(q, Y) {\n            return [q.isSelfClosing ? \"\" : S(q, Y), B(q, Y)];\n          }\n          function S(q, Y) {\n            return q.lastChild && l(q.lastChild) ? \"\" : [I(q, Y), P(q, Y)];\n          }\n          function B(q, Y) {\n            return (q.next ? g(q.next) : F(q.parent)) ? \"\" : [C(q, Y), k(q, Y)];\n          }\n          function I(q, Y) {\n            return F(q) ? C(q.lastChild, Y) : \"\";\n          }\n          function k(q, Y) {\n            return l(q) ? P(q.parent, Y) : E(q) ? $(q.next) : \"\";\n          }\n          function P(q, Y) {\n            if (t(!q.isSelfClosing), D(q, Y)) return \"\";\n            switch (q.type) {\n              case \"ieConditionalComment\":\n                return \"<!\";\n              case \"element\":\n                if (q.hasHtmComponentClosingTag) return \"<//\";\n              default:\n                return \"</\".concat(q.rawName);\n            }\n          }\n          function C(q, Y) {\n            if (D(q, Y)) return \"\";\n            switch (q.type) {\n              case \"ieConditionalComment\":\n              case \"ieConditionalEndComment\":\n                return \"[endif]-->\";\n              case \"ieConditionalStartComment\":\n                return \"]><!-->\";\n              case \"interpolation\":\n                return \"}}\";\n              case \"element\":\n                if (q.isSelfClosing) return \"/>\";\n              default:\n                return \">\";\n            }\n          }\n          function D(q, Y) {\n            return !q.isSelfClosing && !q.endSourceSpan && (h(q) || w(q.parent, Y));\n          }\n          function g(q) {\n            return q.prev && q.prev.type !== \"docType\" && !d(q.prev) && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;\n          }\n          function F(q) {\n            return q.lastChild && q.lastChild.isTrailingSpaceSensitive && !q.lastChild.hasTrailingSpaces && !d(p(q.lastChild)) && !f(q);\n          }\n          function l(q) {\n            return !q.next && !q.hasTrailingSpaces && q.isTrailingSpaceSensitive && d(p(q));\n          }\n          function E(q) {\n            return q.next && !d(q.next) && d(q) && q.isTrailingSpaceSensitive && !q.hasTrailingSpaces;\n          }\n          function y(q) {\n            let Y = q.trim().match(/^prettier-ignore-attribute(?:\\s+(.+))?$/s);\n            return Y ? Y[1] ? Y[1].split(/\\s+/) : !0 : !1;\n          }\n          function N(q) {\n            return !q.prev && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;\n          }\n          function x(q, Y, H) {\n            let R = q.getValue();\n            if (!s(R.attrs)) return R.isSelfClosing ? \" \" : \"\";\n            let Q = R.prev && R.prev.type === \"comment\" && y(R.prev.value),\n              ee = typeof Q == \"boolean\" ? () => Q : Array.isArray(Q) ? De => Q.includes(De.rawName) : () => !1,\n              te = q.map(De => {\n                let ie = De.getValue();\n                return ee(ie) ? c(Y.originalText.slice(v(ie), m(ie))) : H();\n              }, \"attrs\"),\n              oe = R.type === \"element\" && R.fullName === \"script\" && R.attrs.length === 1 && R.attrs[0].fullName === \"src\" && R.children.length === 0,\n              X = Y.singleAttributePerLine && R.attrs.length > 1 && !T(R, Y) ? o : u,\n              ue = [a([oe ? \" \" : u, r(X, te)])];\n            return R.firstChild && N(R.firstChild) || R.isSelfClosing && F(R.parent) || oe ? ue.push(R.isSelfClosing ? \" \" : \"\") : ue.push(Y.bracketSameLine ? R.isSelfClosing ? \" \" : \"\" : R.isSelfClosing ? u : i), ue;\n          }\n          function b(q) {\n            return q.firstChild && N(q.firstChild) ? \"\" : V(q);\n          }\n          function L(q, Y, H) {\n            let R = q.getValue();\n            return [M(R, Y), x(q, Y, H), R.isSelfClosing ? \"\" : b(R)];\n          }\n          function M(q, Y) {\n            return q.prev && E(q.prev) ? \"\" : [j(q, Y), $(q)];\n          }\n          function j(q, Y) {\n            return N(q) ? V(q.parent) : g(q) ? C(q.prev, Y) : \"\";\n          }\n          function $(q) {\n            switch (q.type) {\n              case \"ieConditionalComment\":\n              case \"ieConditionalStartComment\":\n                return \"<!--[if \".concat(q.condition);\n              case \"ieConditionalEndComment\":\n                return \"<!--<!\";\n              case \"interpolation\":\n                return \"{{\";\n              case \"docType\":\n                return \"<!DOCTYPE\";\n              case \"element\":\n                if (q.condition) return \"<!--[if \".concat(q.condition, \"]><!--><\").concat(q.rawName);\n              default:\n                return \"<\".concat(q.rawName);\n            }\n          }\n          function V(q) {\n            switch (t(!q.isSelfClosing), q.type) {\n              case \"ieConditionalComment\":\n                return \"]>\";\n              case \"element\":\n                if (q.condition) return \"><!--<![endif]-->\";\n              default:\n                return \">\";\n            }\n          }\n          n.exports = {\n            printClosingTag: A,\n            printClosingTagStart: S,\n            printClosingTagStartMarker: P,\n            printClosingTagEndMarker: C,\n            printClosingTagSuffix: k,\n            printClosingTagEnd: B,\n            needsToBorrowLastChildClosingTagEndMarker: F,\n            needsToBorrowParentClosingTagStartMarker: l,\n            needsToBorrowPrevClosingTagEndMarker: g,\n            printOpeningTag: L,\n            printOpeningTagStart: M,\n            printOpeningTagPrefix: j,\n            printOpeningTagStartMarker: $,\n            printOpeningTagEndMarker: V,\n            needsToBorrowNextOpeningTagStartMarker: E,\n            needsToBorrowParentOpeningTagEndMarker: N\n          };\n        }\n      }),\n      ug = Z({\n        \"node_modules/parse-srcset/src/parse-srcset.js\"(e, n) {\n          re(), function (t, s) {\n             true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (s),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n          }(e, function () {\n            return function (t, s) {\n              var a = s && s.logger || console;\n              function r(P) {\n                return P === \" \" || P === \"\t\" || P === `\n` || P === \"\\f\" || P === \"\\r\";\n              }\n              function u(P) {\n                var C,\n                  D = P.exec(t.substring(S));\n                if (D) return C = D[0], S += C.length, C;\n              }\n              for (var i = t.length, o = /^[ \\t\\n\\r\\u000c]+/, c = /^[, \\t\\n\\r\\u000c]+/, v = /^[^ \\t\\n\\r\\u000c]+/, m = /[,]+$/, d = /^\\d+$/, p = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, h, w, T, A, S = 0, B = [];;) {\n                if (u(c), S >= i) return B;\n                f = u(v), h = [], f.slice(-1) === \",\" ? (f = f.replace(m, \"\"), k()) : I();\n              }\n              function I() {\n                for (u(o), w = \"\", T = \"in descriptor\";;) {\n                  if (A = t.charAt(S), T === \"in descriptor\") {\n                    if (r(A)) w && (h.push(w), w = \"\", T = \"after descriptor\");else if (A === \",\") {\n                      S += 1, w && h.push(w), k();\n                      return;\n                    } else if (A === \"(\") w = w + A, T = \"in parens\";else if (A === \"\") {\n                      w && h.push(w), k();\n                      return;\n                    } else w = w + A;\n                  } else if (T === \"in parens\") {\n                    if (A === \")\") w = w + A, T = \"in descriptor\";else if (A === \"\") {\n                      h.push(w), k();\n                      return;\n                    } else w = w + A;\n                  } else if (T === \"after descriptor\" && !r(A)) if (A === \"\") {\n                    k();\n                    return;\n                  } else T = \"in descriptor\", S -= 1;\n                  S += 1;\n                }\n              }\n              function k() {\n                var P = !1,\n                  C,\n                  D,\n                  g,\n                  F,\n                  l = {},\n                  E,\n                  y,\n                  N,\n                  x,\n                  b;\n                for (F = 0; F < h.length; F++) E = h[F], y = E[E.length - 1], N = E.substring(0, E.length - 1), x = parseInt(N, 10), b = parseFloat(N), d.test(N) && y === \"w\" ? ((C || D) && (P = !0), x === 0 ? P = !0 : C = x) : p.test(N) && y === \"x\" ? ((C || D || g) && (P = !0), b < 0 ? P = !0 : D = b) : d.test(N) && y === \"h\" ? ((g || D) && (P = !0), x === 0 ? P = !0 : g = x) : P = !0;\n                P ? a && a.error && a.error(\"Invalid srcset descriptor found in '\" + t + \"' at '\" + E + \"'.\") : (l.url = f, C && (l.w = C), D && (l.d = D), g && (l.h = g), B.push(l));\n              }\n            };\n          });\n        }\n      }),\n      sg = Z({\n        \"src/language-html/syntax-attribute.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = ug(),\n            {\n              builders: {\n                ifBreak: s,\n                join: a,\n                line: r\n              }\n            } = Oe();\n          function u(o) {\n            let c = t(o, {\n                logger: {\n                  error(I) {\n                    throw new Error(I);\n                  }\n                }\n              }),\n              v = c.some(I => {\n                let {\n                  w: k\n                } = I;\n                return k;\n              }),\n              m = c.some(I => {\n                let {\n                  h: k\n                } = I;\n                return k;\n              }),\n              d = c.some(I => {\n                let {\n                  d: k\n                } = I;\n                return k;\n              });\n            if (v + m + d > 1) throw new Error(\"Mixed descriptor in srcset is not supported\");\n            let p = v ? \"w\" : m ? \"h\" : \"d\",\n              f = v ? \"w\" : m ? \"h\" : \"x\",\n              h = I => Math.max(...I),\n              w = c.map(I => I.url),\n              T = h(w.map(I => I.length)),\n              A = c.map(I => I[p]).map(I => I ? I.toString() : \"\"),\n              S = A.map(I => {\n                let k = I.indexOf(\".\");\n                return k === -1 ? I.length : k;\n              }),\n              B = h(S);\n            return a([\",\", r], w.map((I, k) => {\n              let P = [I],\n                C = A[k];\n              if (C) {\n                let D = T - I.length + 1,\n                  g = B - S[k],\n                  F = \" \".repeat(D + g);\n                P.push(s(F, \" \"), C + f);\n              }\n              return P;\n            }));\n          }\n          function i(o) {\n            return o.trim().split(/\\s+/).join(\" \");\n          }\n          n.exports = {\n            printImgSrcset: u,\n            printClassNames: i\n          };\n        }\n      }),\n      ig = Z({\n        \"src/language-html/syntax-vue.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            builders: {\n              group: t\n            }\n          } = Oe();\n          function s(i, o) {\n            let {\n              left: c,\n              operator: v,\n              right: m\n            } = a(i);\n            return [t(o(\"function _(\".concat(c, \") {}\"), {\n              parser: \"babel\",\n              __isVueForBindingLeft: !0\n            })), \" \", v, \" \", o(m, {\n              parser: \"__js_expression\"\n            }, {\n              stripTrailingHardline: !0\n            })];\n          }\n          function a(i) {\n            let o = /(.*?)\\s+(in|of)\\s+(.*)/s,\n              c = /,([^,\\]}]*)(?:,([^,\\]}]*))?$/,\n              v = /^\\(|\\)$/g,\n              m = i.match(o);\n            if (!m) return;\n            let d = {};\n            if (d.for = m[3].trim(), !d.for) return;\n            let p = m[1].trim().replace(v, \"\"),\n              f = p.match(c);\n            f ? (d.alias = p.replace(c, \"\"), d.iterator1 = f[1].trim(), f[2] && (d.iterator2 = f[2].trim())) : d.alias = p;\n            let h = [d.alias, d.iterator1, d.iterator2];\n            if (!h.some((w, T) => !w && (T === 0 || h.slice(T + 1).some(Boolean)))) return {\n              left: h.filter(Boolean).join(\",\"),\n              operator: m[2],\n              right: d.for\n            };\n          }\n          function r(i, o) {\n            return o(\"function _(\".concat(i, \") {}\"), {\n              parser: \"babel\",\n              __isVueBindings: !0\n            });\n          }\n          function u(i) {\n            let o = /^(?:[\\w$]+|\\([^)]*\\))\\s*=>|^function\\s*\\(/,\n              c = /^[$A-Z_a-z][\\w$]*(?:\\.[$A-Z_a-z][\\w$]*|\\['[^']*']|\\[\"[^\"]*\"]|\\[\\d+]|\\[[$A-Z_a-z][\\w$]*])*$/,\n              v = i.trim();\n            return o.test(v) || c.test(v);\n          }\n          n.exports = {\n            isVueEventBindingExpression: u,\n            printVueFor: s,\n            printVueBindings: r\n          };\n        }\n      }),\n      ho = Z({\n        \"src/language-html/get-node-content.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            needsToBorrowParentClosingTagStartMarker: t,\n            printClosingTagStartMarker: s,\n            needsToBorrowLastChildClosingTagEndMarker: a,\n            printClosingTagEndMarker: r,\n            needsToBorrowParentOpeningTagEndMarker: u,\n            printOpeningTagEndMarker: i\n          } = er();\n          function o(c, v) {\n            let m = c.startSourceSpan.end.offset;\n            c.firstChild && u(c.firstChild) && (m -= i(c).length);\n            let d = c.endSourceSpan.start.offset;\n            return c.lastChild && t(c.lastChild) ? d += s(c, v).length : a(c) && (d -= r(c.lastChild, v).length), v.originalText.slice(m, d);\n          }\n          n.exports = o;\n        }\n      }),\n      ag = Z({\n        \"src/language-html/embed.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                breakParent: t,\n                group: s,\n                hardline: a,\n                indent: r,\n                line: u,\n                fill: i,\n                softline: o\n              },\n              utils: {\n                mapDoc: c,\n                replaceTextEndOfLine: v\n              }\n            } = Oe(),\n            m = Xn(),\n            {\n              printClosingTag: d,\n              printClosingTagSuffix: p,\n              needsToBorrowPrevClosingTagEndMarker: f,\n              printOpeningTagPrefix: h,\n              printOpeningTag: w\n            } = er(),\n            {\n              printImgSrcset: T,\n              printClassNames: A\n            } = sg(),\n            {\n              printVueFor: S,\n              printVueBindings: B,\n              isVueEventBindingExpression: I\n            } = ig(),\n            {\n              isScriptLikeTag: k,\n              isVueNonHtmlBlock: P,\n              inferScriptParser: C,\n              htmlTrimPreserveIndentation: D,\n              dedentString: g,\n              unescapeQuoteEntities: F,\n              isVueSlotAttribute: l,\n              isVueSfcBindingsAttribute: E,\n              getTextValueParts: y\n            } = qt(),\n            N = ho();\n          function x(L, M, j) {\n            let $ = te => new RegExp(te.join(\"|\")).test(L.fullName),\n              V = () => F(L.value),\n              q = !1,\n              Y = (te, oe) => {\n                let W = te.type === \"NGRoot\" ? te.node.type === \"NGMicrosyntax\" && te.node.body.length === 1 && te.node.body[0].type === \"NGMicrosyntaxExpression\" ? te.node.body[0].expression : te.node : te.type === \"JsExpressionRoot\" ? te.node : te;\n                W && (W.type === \"ObjectExpression\" || W.type === \"ArrayExpression\" || oe.parser === \"__vue_expression\" && (W.type === \"TemplateLiteral\" || W.type === \"StringLiteral\")) && (q = !0);\n              },\n              H = te => s(te),\n              R = function (te) {\n                let oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n                return s([r([o, te]), oe ? o : \"\"]);\n              },\n              Q = te => q ? H(te) : R(te),\n              ee = (te, oe) => M(te, Object.assign({\n                __onHtmlBindingRoot: Y,\n                __embeddedInHtml: !0\n              }, oe));\n            if (L.fullName === \"srcset\" && (L.parent.fullName === \"img\" || L.parent.fullName === \"source\")) return R(T(V()));\n            if (L.fullName === \"class\" && !j.parentParser) {\n              let te = V();\n              if (!te.includes(\"{{\")) return A(te);\n            }\n            if (L.fullName === \"style\" && !j.parentParser) {\n              let te = V();\n              if (!te.includes(\"{{\")) return R(ee(te, {\n                parser: \"css\",\n                __isHTMLStyleAttribute: !0\n              }));\n            }\n            if (j.parser === \"vue\") {\n              if (L.fullName === \"v-for\") return S(V(), ee);\n              if (l(L) || E(L, j)) return B(V(), ee);\n              let te = [\"^@\", \"^v-on:\"],\n                oe = [\"^:\", \"^v-bind:\"],\n                W = [\"^v-\"];\n              if ($(te)) {\n                let X = V(),\n                  ue = I(X) ? \"__js_expression\" : j.__should_parse_vue_template_with_ts ? \"__vue_ts_event_binding\" : \"__vue_event_binding\";\n                return Q(ee(X, {\n                  parser: ue\n                }));\n              }\n              if ($(oe)) return Q(ee(V(), {\n                parser: \"__vue_expression\"\n              }));\n              if ($(W)) return Q(ee(V(), {\n                parser: \"__js_expression\"\n              }));\n            }\n            if (j.parser === \"angular\") {\n              let te = (G, z) => ee(G, Object.assign(Object.assign({}, z), {}, {\n                  trailingComma: \"none\"\n                })),\n                oe = [\"^\\\\*\"],\n                W = [\"^\\\\(.+\\\\)$\", \"^on-\"],\n                X = [\"^\\\\[.+\\\\]$\", \"^bind(on)?-\", \"^ng-(if|show|hide|class|style)$\"],\n                ue = [\"^i18n(-.+)?$\"];\n              if ($(W)) return Q(te(V(), {\n                parser: \"__ng_action\"\n              }));\n              if ($(X)) return Q(te(V(), {\n                parser: \"__ng_binding\"\n              }));\n              if ($(ue)) {\n                let G = V().trim();\n                return R(i(y(L, G)), !G.includes(\"@@\"));\n              }\n              if ($(oe)) return Q(te(V(), {\n                parser: \"__ng_directive\"\n              }));\n              let De = /{{(.+?)}}/s,\n                ie = V();\n              if (De.test(ie)) {\n                let G = [];\n                for (let [z, U] of ie.split(De).entries()) if (z % 2 === 0) G.push(v(U));else try {\n                  G.push(s([\"{{\", r([u, te(U, {\n                    parser: \"__ng_interpolation\",\n                    __isInHtmlInterpolation: !0\n                  })]), u, \"}}\"]));\n                } catch {\n                  G.push(\"{{\", v(U), \"}}\");\n                }\n                return s(G);\n              }\n            }\n            return null;\n          }\n          function b(L, M, j, $) {\n            let V = L.getValue();\n            switch (V.type) {\n              case \"element\":\n                {\n                  if (k(V) || V.type === \"interpolation\") return;\n                  if (!V.isSelfClosing && P(V, $)) {\n                    let q = C(V, $);\n                    if (!q) return;\n                    let Y = N(V, $),\n                      H = /^\\s*$/.test(Y),\n                      R = \"\";\n                    return H || (R = j(D(Y), {\n                      parser: q,\n                      __embeddedInHtml: !0\n                    }, {\n                      stripTrailingHardline: !0\n                    }), H = R === \"\"), [h(V, $), s(w(L, $, M)), H ? \"\" : a, R, H ? \"\" : a, d(V, $), p(V, $)];\n                  }\n                  break;\n                }\n              case \"text\":\n                {\n                  if (k(V.parent)) {\n                    let q = C(V.parent, $);\n                    if (q) {\n                      let Y = q === \"markdown\" ? g(V.value.replace(/^[^\\S\\n]*\\n/, \"\")) : V.value,\n                        H = {\n                          parser: q,\n                          __embeddedInHtml: !0\n                        };\n                      if ($.parser === \"html\" && q === \"babel\") {\n                        let R = \"script\",\n                          {\n                            attrMap: Q\n                          } = V.parent;\n                        Q && (Q.type === \"module\" || Q.type === \"text/babel\" && Q[\"data-type\"] === \"module\") && (R = \"module\"), H.__babelSourceType = R;\n                      }\n                      return [t, h(V, $), j(Y, H, {\n                        stripTrailingHardline: !0\n                      }), p(V, $)];\n                    }\n                  } else if (V.parent.type === \"interpolation\") {\n                    let q = {\n                      __isInHtmlInterpolation: !0,\n                      __embeddedInHtml: !0\n                    };\n                    return $.parser === \"angular\" ? (q.parser = \"__ng_interpolation\", q.trailingComma = \"none\") : $.parser === \"vue\" ? q.parser = $.__should_parse_vue_template_with_ts ? \"__vue_ts_expression\" : \"__vue_expression\" : q.parser = \"__js_expression\", [r([u, j(V.value, q, {\n                      stripTrailingHardline: !0\n                    })]), V.parent.next && f(V.parent.next) ? \" \" : u];\n                  }\n                  break;\n                }\n              case \"attribute\":\n                {\n                  if (!V.value) break;\n                  if (/^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset))) return [V.rawName, \"=\", V.value];\n                  if ($.parser === \"lwc\" && /^{.*}$/s.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset))) return [V.rawName, \"=\", V.value];\n                  let q = x(V, (Y, H) => j(Y, Object.assign({\n                    __isInHtmlAttribute: !0,\n                    __embeddedInHtml: !0\n                  }, H), {\n                    stripTrailingHardline: !0\n                  }), $);\n                  if (q) return [V.rawName, '=\"', s(c(q, Y => typeof Y == \"string\" ? Y.replace(/\"/g, \"&quot;\") : Y)), '\"'];\n                  break;\n                }\n              case \"front-matter\":\n                return m(V, j);\n            }\n          }\n          n.exports = b;\n        }\n      }),\n      vo = Z({\n        \"src/language-html/print/children.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                breakParent: t,\n                group: s,\n                ifBreak: a,\n                line: r,\n                softline: u,\n                hardline: i\n              },\n              utils: {\n                replaceTextEndOfLine: o\n              }\n            } = Oe(),\n            {\n              locStart: c,\n              locEnd: v\n            } = Yn(),\n            {\n              forceBreakChildren: m,\n              forceNextEmptyLine: d,\n              isTextLikeNode: p,\n              hasPrettierIgnore: f,\n              preferHardlineAsLeadingSpaces: h\n            } = qt(),\n            {\n              printOpeningTagPrefix: w,\n              needsToBorrowNextOpeningTagStartMarker: T,\n              printOpeningTagStartMarker: A,\n              needsToBorrowPrevClosingTagEndMarker: S,\n              printClosingTagEndMarker: B,\n              printClosingTagSuffix: I,\n              needsToBorrowParentClosingTagStartMarker: k\n            } = er();\n          function P(g, F, l) {\n            let E = g.getValue();\n            return f(E) ? [w(E, F), ...o(F.originalText.slice(c(E) + (E.prev && T(E.prev) ? A(E).length : 0), v(E) - (E.next && S(E.next) ? B(E, F).length : 0))), I(E, F)] : l();\n          }\n          function C(g, F) {\n            return p(g) && p(F) ? g.isTrailingSpaceSensitive ? g.hasTrailingSpaces ? h(F) ? i : r : \"\" : h(F) ? i : u : T(g) && (f(F) || F.firstChild || F.isSelfClosing || F.type === \"element\" && F.attrs.length > 0) || g.type === \"element\" && g.isSelfClosing && S(F) ? \"\" : !F.isLeadingSpaceSensitive || h(F) || S(F) && g.lastChild && k(g.lastChild) && g.lastChild.lastChild && k(g.lastChild.lastChild) ? i : F.hasLeadingSpaces ? r : u;\n          }\n          function D(g, F, l) {\n            let E = g.getValue();\n            if (m(E)) return [t, ...g.map(N => {\n              let x = N.getValue(),\n                b = x.prev ? C(x.prev, x) : \"\";\n              return [b ? [b, d(x.prev) ? i : \"\"] : \"\", P(N, F, l)];\n            }, \"children\")];\n            let y = E.children.map(() => Symbol(\"\"));\n            return g.map((N, x) => {\n              let b = N.getValue();\n              if (p(b)) {\n                if (b.prev && p(b.prev)) {\n                  let Y = C(b.prev, b);\n                  if (Y) return d(b.prev) ? [i, i, P(N, F, l)] : [Y, P(N, F, l)];\n                }\n                return P(N, F, l);\n              }\n              let L = [],\n                M = [],\n                j = [],\n                $ = [],\n                V = b.prev ? C(b.prev, b) : \"\",\n                q = b.next ? C(b, b.next) : \"\";\n              return V && (d(b.prev) ? L.push(i, i) : V === i ? L.push(i) : p(b.prev) ? M.push(V) : M.push(a(\"\", u, {\n                groupId: y[x - 1]\n              }))), q && (d(b) ? p(b.next) && $.push(i, i) : q === i ? p(b.next) && $.push(i) : j.push(q)), [...L, s([...M, s([P(N, F, l), ...j], {\n                id: y[x]\n              })]), ...$];\n            }, \"children\");\n          }\n          n.exports = {\n            printChildren: D\n          };\n        }\n      }),\n      og = Z({\n        \"src/language-html/print/element.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                breakParent: t,\n                dedentToRoot: s,\n                group: a,\n                ifBreak: r,\n                indentIfBreak: u,\n                indent: i,\n                line: o,\n                softline: c\n              },\n              utils: {\n                replaceTextEndOfLine: v\n              }\n            } = Oe(),\n            m = ho(),\n            {\n              shouldPreserveContent: d,\n              isScriptLikeTag: p,\n              isVueCustomBlock: f,\n              countParents: h,\n              forceBreakContent: w\n            } = qt(),\n            {\n              printOpeningTagPrefix: T,\n              printOpeningTag: A,\n              printClosingTagSuffix: S,\n              printClosingTag: B,\n              needsToBorrowPrevClosingTagEndMarker: I,\n              needsToBorrowLastChildClosingTagEndMarker: k\n            } = er(),\n            {\n              printChildren: P\n            } = vo();\n          function C(D, g, F) {\n            let l = D.getValue();\n            if (d(l, g)) return [T(l, g), a(A(D, g, F)), ...v(m(l, g)), ...B(l, g), S(l, g)];\n            let E = l.children.length === 1 && l.firstChild.type === \"interpolation\" && l.firstChild.isLeadingSpaceSensitive && !l.firstChild.hasLeadingSpaces && l.lastChild.isTrailingSpaceSensitive && !l.lastChild.hasTrailingSpaces,\n              y = Symbol(\"element-attr-group-id\"),\n              N = M => a([a(A(D, g, F), {\n                id: y\n              }), M, B(l, g)]),\n              x = M => E ? u(M, {\n                groupId: y\n              }) : (p(l) || f(l, g)) && l.parent.type === \"root\" && g.parser === \"vue\" && !g.vueIndentScriptAndStyle ? M : i(M),\n              b = () => E ? r(c, \"\", {\n                groupId: y\n              }) : l.firstChild.hasLeadingSpaces && l.firstChild.isLeadingSpaceSensitive ? o : l.firstChild.type === \"text\" && l.isWhitespaceSensitive && l.isIndentationSensitive ? s(c) : c,\n              L = () => (l.next ? I(l.next) : k(l.parent)) ? l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? \" \" : \"\" : E ? r(c, \"\", {\n                groupId: y\n              }) : l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? o : (l.lastChild.type === \"comment\" || l.lastChild.type === \"text\" && l.isWhitespaceSensitive && l.isIndentationSensitive) && new RegExp(\"\\\\n[\\\\t ]{\".concat(g.tabWidth * h(D, j => j.parent && j.parent.type !== \"root\"), \"}$\")).test(l.lastChild.value) ? \"\" : c;\n            return l.children.length === 0 ? N(l.hasDanglingSpaces && l.isDanglingSpaceSensitive ? o : \"\") : N([w(l) ? t : \"\", x([b(), P(D, g, F)]), L()]);\n          }\n          n.exports = {\n            printElement: C\n          };\n        }\n      }),\n      lg = Z({\n        \"src/language-html/printer-html.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                fill: t,\n                group: s,\n                hardline: a,\n                literalline: r\n              },\n              utils: {\n                cleanDoc: u,\n                getDocParts: i,\n                isConcat: o,\n                replaceTextEndOfLine: c\n              }\n            } = Oe(),\n            v = zd(),\n            {\n              countChars: m,\n              unescapeQuoteEntities: d,\n              getTextValueParts: p\n            } = qt(),\n            f = rg(),\n            {\n              insertPragma: h\n            } = ng(),\n            {\n              locStart: w,\n              locEnd: T\n            } = Yn(),\n            A = ag(),\n            {\n              printClosingTagSuffix: S,\n              printClosingTagEnd: B,\n              printOpeningTagPrefix: I,\n              printOpeningTagStart: k\n            } = er(),\n            {\n              printElement: P\n            } = og(),\n            {\n              printChildren: C\n            } = vo();\n          function D(g, F, l) {\n            let E = g.getValue();\n            switch (E.type) {\n              case \"front-matter\":\n                return c(E.raw);\n              case \"root\":\n                return F.__onHtmlRoot && F.__onHtmlRoot(E), [s(C(g, F, l)), a];\n              case \"element\":\n              case \"ieConditionalComment\":\n                return P(g, F, l);\n              case \"ieConditionalStartComment\":\n              case \"ieConditionalEndComment\":\n                return [k(E), B(E)];\n              case \"interpolation\":\n                return [k(E, F), ...g.map(l, \"children\"), B(E, F)];\n              case \"text\":\n                {\n                  if (E.parent.type === \"interpolation\") {\n                    let N = /\\n[^\\S\\n]*$/,\n                      x = N.test(E.value),\n                      b = x ? E.value.replace(N, \"\") : E.value;\n                    return [...c(b), x ? a : \"\"];\n                  }\n                  let y = u([I(E, F), ...p(E), S(E, F)]);\n                  return o(y) || y.type === \"fill\" ? t(i(y)) : y;\n                }\n              case \"docType\":\n                return [s([k(E, F), \" \", E.value.replace(/^html\\b/i, \"html\").replace(/\\s+/g, \" \")]), B(E, F)];\n              case \"comment\":\n                return [I(E, F), ...c(F.originalText.slice(w(E), T(E)), r), S(E, F)];\n              case \"attribute\":\n                {\n                  if (E.value === null) return E.rawName;\n                  let y = d(E.value),\n                    N = m(y, \"'\"),\n                    x = m(y, '\"'),\n                    b = N < x ? \"'\" : '\"';\n                  return [E.rawName, \"=\", b, ...c(b === '\"' ? y.replace(/\"/g, \"&quot;\") : y.replace(/'/g, \"&apos;\")), b];\n                }\n              default:\n                throw new Error(\"Unexpected node type \".concat(E.type));\n            }\n          }\n          n.exports = {\n            preprocess: f,\n            print: D,\n            insertPragma: h,\n            massageAstNode: v,\n            embed: A\n          };\n        }\n      }),\n      cg = Z({\n        \"src/language-html/options.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Ot(),\n            s = \"HTML\";\n          n.exports = {\n            bracketSameLine: t.bracketSameLine,\n            htmlWhitespaceSensitivity: {\n              since: \"1.15.0\",\n              category: s,\n              type: \"choice\",\n              default: \"css\",\n              description: \"How to handle whitespaces in HTML.\",\n              choices: [{\n                value: \"css\",\n                description: \"Respect the default value of CSS display property.\"\n              }, {\n                value: \"strict\",\n                description: \"Whitespaces are considered sensitive.\"\n              }, {\n                value: \"ignore\",\n                description: \"Whitespaces are considered insensitive.\"\n              }]\n            },\n            singleAttributePerLine: t.singleAttributePerLine,\n            vueIndentScriptAndStyle: {\n              since: \"1.19.0\",\n              category: s,\n              type: \"boolean\",\n              default: !1,\n              description: \"Indent script and style tags in Vue files.\"\n            }\n          };\n        }\n      }),\n      pg = Z({\n        \"src/language-html/parsers.js\"() {\n          re();\n        }\n      }),\n      xn = Z({\n        \"node_modules/linguist-languages/data/HTML.json\"(e, n) {\n          n.exports = {\n            name: \"HTML\",\n            type: \"markup\",\n            tmScope: \"text.html.basic\",\n            aceMode: \"html\",\n            codemirrorMode: \"htmlmixed\",\n            codemirrorMimeType: \"text/html\",\n            color: \"#e34c26\",\n            aliases: [\"xhtml\"],\n            extensions: [\".html\", \".hta\", \".htm\", \".html.hl\", \".inc\", \".xht\", \".xhtml\"],\n            languageId: 146\n          };\n        }\n      }),\n      fg = Z({\n        \"node_modules/linguist-languages/data/Vue.json\"(e, n) {\n          n.exports = {\n            name: \"Vue\",\n            type: \"markup\",\n            color: \"#41b883\",\n            extensions: [\".vue\"],\n            tmScope: \"text.html.vue\",\n            aceMode: \"html\",\n            languageId: 391\n          };\n        }\n      }),\n      Dg = Z({\n        \"src/language-html/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Bt(),\n            s = lg(),\n            a = cg(),\n            r = pg(),\n            u = [t(xn(), () => ({\n              name: \"Angular\",\n              since: \"1.15.0\",\n              parsers: [\"angular\"],\n              vscodeLanguageIds: [\"html\"],\n              extensions: [\".component.html\"],\n              filenames: []\n            })), t(xn(), o => ({\n              since: \"1.15.0\",\n              parsers: [\"html\"],\n              vscodeLanguageIds: [\"html\"],\n              extensions: [...o.extensions, \".mjml\"]\n            })), t(xn(), () => ({\n              name: \"Lightning Web Components\",\n              since: \"1.17.0\",\n              parsers: [\"lwc\"],\n              vscodeLanguageIds: [\"html\"],\n              extensions: [],\n              filenames: []\n            })), t(fg(), () => ({\n              since: \"1.10.0\",\n              parsers: [\"vue\"],\n              vscodeLanguageIds: [\"vue\"]\n            }))],\n            i = {\n              html: s\n            };\n          n.exports = {\n            languages: u,\n            printers: i,\n            options: a,\n            parsers: r\n          };\n        }\n      }),\n      mg = Z({\n        \"src/language-yaml/pragma.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(r) {\n            return /^\\s*@(?:prettier|format)\\s*$/.test(r);\n          }\n          function s(r) {\n            return /^\\s*#[^\\S\\n]*@(?:prettier|format)\\s*?(?:\\n|$)/.test(r);\n          }\n          function a(r) {\n            return `# @format\n\n`.concat(r);\n          }\n          n.exports = {\n            isPragma: t,\n            hasPragma: s,\n            insertPragma: a\n          };\n        }\n      }),\n      dg = Z({\n        \"src/language-yaml/loc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(a) {\n            return a.position.start.offset;\n          }\n          function s(a) {\n            return a.position.end.offset;\n          }\n          n.exports = {\n            locStart: t,\n            locEnd: s\n          };\n        }\n      }),\n      gg = Z({\n        \"src/language-yaml/embed.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          function t(s, a, r, u) {\n            if (s.getValue().type === \"root\" && u.filepath && /(?:[/\\\\]|^)\\.(?:prettier|stylelint)rc$/.test(u.filepath)) return r(u.originalText, Object.assign(Object.assign({}, u), {}, {\n              parser: \"json\"\n            }));\n          }\n          n.exports = t;\n        }\n      }),\n      Mt = Z({\n        \"src/language-yaml/utils.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            getLast: t,\n            isNonEmptyArray: s\n          } = Ue();\n          function a(C, D) {\n            let g = 0,\n              F = C.stack.length - 1;\n            for (let l = 0; l < F; l++) {\n              let E = C.stack[l];\n              r(E) && D(E) && g++;\n            }\n            return g;\n          }\n          function r(C, D) {\n            return C && typeof C.type == \"string\" && (!D || D.includes(C.type));\n          }\n          function u(C, D, g) {\n            return D(\"children\" in C ? Object.assign(Object.assign({}, C), {}, {\n              children: C.children.map(F => u(F, D, C))\n            }) : C, g);\n          }\n          function i(C, D, g) {\n            Object.defineProperty(C, D, {\n              get: g,\n              enumerable: !1\n            });\n          }\n          function o(C, D) {\n            let g = 0,\n              F = D.length;\n            for (let l = C.position.end.offset - 1; l < F; l++) {\n              let E = D[l];\n              if (E === `\n` && g++, g === 1 && /\\S/.test(E)) return !1;\n              if (g === 2) return !0;\n            }\n            return !1;\n          }\n          function c(C) {\n            switch (C.getValue().type) {\n              case \"tag\":\n              case \"anchor\":\n              case \"comment\":\n                return !1;\n            }\n            let g = C.stack.length;\n            for (let F = 1; F < g; F++) {\n              let l = C.stack[F],\n                E = C.stack[F - 1];\n              if (Array.isArray(E) && typeof l == \"number\" && l !== E.length - 1) return !1;\n            }\n            return !0;\n          }\n          function v(C) {\n            return s(C.children) ? v(t(C.children)) : C;\n          }\n          function m(C) {\n            return C.value.trim() === \"prettier-ignore\";\n          }\n          function d(C) {\n            let D = C.getValue();\n            if (D.type === \"documentBody\") {\n              let g = C.getParentNode();\n              return S(g.head) && m(t(g.head.endComments));\n            }\n            return h(D) && m(t(D.leadingComments));\n          }\n          function p(C) {\n            return !s(C.children) && !f(C);\n          }\n          function f(C) {\n            return h(C) || w(C) || T(C) || A(C) || S(C);\n          }\n          function h(C) {\n            return s(C == null ? void 0 : C.leadingComments);\n          }\n          function w(C) {\n            return s(C == null ? void 0 : C.middleComments);\n          }\n          function T(C) {\n            return C == null ? void 0 : C.indicatorComment;\n          }\n          function A(C) {\n            return C == null ? void 0 : C.trailingComment;\n          }\n          function S(C) {\n            return s(C == null ? void 0 : C.endComments);\n          }\n          function B(C) {\n            let D = [],\n              g;\n            for (let F of C.split(/( +)/)) F !== \" \" ? g === \" \" ? D.push(F) : D.push((D.pop() || \"\") + F) : g === void 0 && D.unshift(\"\"), g = F;\n            return g === \" \" && D.push((D.pop() || \"\") + \" \"), D[0] === \"\" && (D.shift(), D.unshift(\" \" + (D.shift() || \"\"))), D;\n          }\n          function I(C, D, g) {\n            let F = D.split(`\n`).map((l, E, y) => E === 0 && E === y.length - 1 ? l : E !== 0 && E !== y.length - 1 ? l.trim() : E === 0 ? l.trimEnd() : l.trimStart());\n            return g.proseWrap === \"preserve\" ? F.map(l => l.length === 0 ? [] : [l]) : F.map(l => l.length === 0 ? [] : B(l)).reduce((l, E, y) => y !== 0 && F[y - 1].length > 0 && E.length > 0 && !(C === \"quoteDouble\" && t(t(l)).endsWith(\"\\\\\")) ? [...l.slice(0, -1), [...t(l), ...E]] : [...l, E], []).map(l => g.proseWrap === \"never\" ? [l.join(\" \")] : l);\n          }\n          function k(C, D) {\n            let {\n                parentIndent: g,\n                isLastDescendant: F,\n                options: l\n              } = D,\n              E = C.position.start.line === C.position.end.line ? \"\" : l.originalText.slice(C.position.start.offset, C.position.end.offset).match(/^[^\\n]*\\n(.*)$/s)[1],\n              y;\n            if (C.indent === null) {\n              let b = E.match(/^(?<leadingSpace> *)[^\\n\\r ]/m);\n              y = b ? b.groups.leadingSpace.length : Number.POSITIVE_INFINITY;\n            } else y = C.indent - 1 + g;\n            let N = E.split(`\n`).map(b => b.slice(y));\n            if (l.proseWrap === \"preserve\" || C.type === \"blockLiteral\") return x(N.map(b => b.length === 0 ? [] : [b]));\n            return x(N.map(b => b.length === 0 ? [] : B(b)).reduce((b, L, M) => M !== 0 && N[M - 1].length > 0 && L.length > 0 && !/^\\s/.test(L[0]) && !/^\\s|\\s$/.test(t(b)) ? [...b.slice(0, -1), [...t(b), ...L]] : [...b, L], []).map(b => b.reduce((L, M) => L.length > 0 && /\\s$/.test(t(L)) ? [...L.slice(0, -1), t(L) + \" \" + M] : [...L, M], [])).map(b => l.proseWrap === \"never\" ? [b.join(\" \")] : b));\n            function x(b) {\n              if (C.chomping === \"keep\") return t(b).length === 0 ? b.slice(0, -1) : b;\n              let L = 0;\n              for (let M = b.length - 1; M >= 0 && b[M].length === 0; M--) L++;\n              return L === 0 ? b : L >= 2 && !F ? b.slice(0, -(L - 1)) : b.slice(0, -L);\n            }\n          }\n          function P(C) {\n            if (!C) return !0;\n            switch (C.type) {\n              case \"plain\":\n              case \"quoteDouble\":\n              case \"quoteSingle\":\n              case \"alias\":\n              case \"flowMapping\":\n              case \"flowSequence\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          n.exports = {\n            getLast: t,\n            getAncestorCount: a,\n            isNode: r,\n            isEmptyNode: p,\n            isInlineNode: P,\n            mapNode: u,\n            defineShortcut: i,\n            isNextLineEmpty: o,\n            isLastDescendantNode: c,\n            getBlockValueLineContents: k,\n            getFlowScalarLineContents: I,\n            getLastDescendantNode: v,\n            hasPrettierIgnore: d,\n            hasLeadingComments: h,\n            hasMiddleComments: w,\n            hasIndicatorComment: T,\n            hasTrailingComment: A,\n            hasEndComments: S\n          };\n        }\n      }),\n      yg = Z({\n        \"src/language-yaml/print-preprocess.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n            defineShortcut: t,\n            mapNode: s\n          } = Mt();\n          function a(u) {\n            return s(u, r);\n          }\n          function r(u) {\n            switch (u.type) {\n              case \"document\":\n                t(u, \"head\", () => u.children[0]), t(u, \"body\", () => u.children[1]);\n                break;\n              case \"documentBody\":\n              case \"sequenceItem\":\n              case \"flowSequenceItem\":\n              case \"mappingKey\":\n              case \"mappingValue\":\n                t(u, \"content\", () => u.children[0]);\n                break;\n              case \"mappingItem\":\n              case \"flowMappingItem\":\n                t(u, \"key\", () => u.children[0]), t(u, \"value\", () => u.children[1]);\n                break;\n            }\n            return u;\n          }\n          n.exports = a;\n        }\n      }),\n      jr = Z({\n        \"src/language-yaml/print/misc.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                softline: t,\n                align: s\n              }\n            } = Oe(),\n            {\n              hasEndComments: a,\n              isNextLineEmpty: r,\n              isNode: u\n            } = Mt(),\n            i = new WeakMap();\n          function o(m, d) {\n            let p = m.getValue(),\n              f = m.stack[0],\n              h;\n            return i.has(f) ? h = i.get(f) : (h = new Set(), i.set(f, h)), !h.has(p.position.end.line) && (h.add(p.position.end.line), r(p, d) && !c(m.getParentNode())) ? t : \"\";\n          }\n          function c(m) {\n            return a(m) && !u(m, [\"documentHead\", \"documentBody\", \"flowMapping\", \"flowSequence\"]);\n          }\n          function v(m, d) {\n            return s(\" \".repeat(m), d);\n          }\n          n.exports = {\n            alignWithSpaces: v,\n            shouldPrintEndComments: c,\n            printNextEmptyLine: o\n          };\n        }\n      }),\n      hg = Z({\n        \"src/language-yaml/print/flow-mapping-sequence.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                ifBreak: t,\n                line: s,\n                softline: a,\n                hardline: r,\n                join: u\n              }\n            } = Oe(),\n            {\n              isEmptyNode: i,\n              getLast: o,\n              hasEndComments: c\n            } = Mt(),\n            {\n              printNextEmptyLine: v,\n              alignWithSpaces: m\n            } = jr();\n          function d(f, h, w) {\n            let T = f.getValue(),\n              A = T.type === \"flowMapping\",\n              S = A ? \"{\" : \"[\",\n              B = A ? \"}\" : \"]\",\n              I = a;\n            A && T.children.length > 0 && w.bracketSpacing && (I = s);\n            let k = o(T.children),\n              P = k && k.type === \"flowMappingItem\" && i(k.key) && i(k.value);\n            return [S, m(w.tabWidth, [I, p(f, h, w), w.trailingComma === \"none\" ? \"\" : t(\",\"), c(T) ? [r, u(r, f.map(h, \"endComments\"))] : \"\"]), P ? \"\" : I, B];\n          }\n          function p(f, h, w) {\n            let T = f.getValue();\n            return f.map((S, B) => [h(), B === T.children.length - 1 ? \"\" : [\",\", s, T.children[B].position.start.line !== T.children[B + 1].position.start.line ? v(S, w.originalText) : \"\"]], \"children\");\n          }\n          n.exports = {\n            printFlowMapping: d,\n            printFlowSequence: d\n          };\n        }\n      }),\n      vg = Z({\n        \"src/language-yaml/print/mapping-item.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                conditionalGroup: t,\n                group: s,\n                hardline: a,\n                ifBreak: r,\n                join: u,\n                line: i\n              }\n            } = Oe(),\n            {\n              hasLeadingComments: o,\n              hasMiddleComments: c,\n              hasTrailingComment: v,\n              hasEndComments: m,\n              isNode: d,\n              isEmptyNode: p,\n              isInlineNode: f\n            } = Mt(),\n            {\n              alignWithSpaces: h\n            } = jr();\n          function w(B, I, k, P, C) {\n            let {\n                key: D,\n                value: g\n              } = B,\n              F = p(D),\n              l = p(g);\n            if (F && l) return \": \";\n            let E = P(\"key\"),\n              y = A(B) ? \" \" : \"\";\n            if (l) return B.type === \"flowMappingItem\" && I.type === \"flowMapping\" ? E : B.type === \"mappingItem\" && T(D.content, C) && !v(D.content) && (!I.tag || I.tag.value !== \"tag:yaml.org,2002:set\") ? [E, y, \":\"] : [\"? \", h(2, E)];\n            let N = P(\"value\");\n            if (F) return [\": \", h(2, N)];\n            if (o(g) || !f(D.content)) return [\"? \", h(2, E), a, u(\"\", k.map(P, \"value\", \"leadingComments\").map($ => [$, a])), \": \", h(2, N)];\n            if (S(D.content) && !o(D.content) && !c(D.content) && !v(D.content) && !m(D) && !o(g.content) && !c(g.content) && !m(g) && T(g.content, C)) return [E, y, \": \", N];\n            let x = Symbol(\"mappingKey\"),\n              b = s([r(\"? \"), s(h(2, E), {\n                id: x\n              })]),\n              L = [a, \": \", h(2, N)],\n              M = [y, \":\"];\n            o(g.content) || m(g) && g.content && !d(g.content, [\"mapping\", \"sequence\"]) || I.type === \"mapping\" && v(D.content) && f(g.content) || d(g.content, [\"mapping\", \"sequence\"]) && g.content.tag === null && g.content.anchor === null ? M.push(a) : g.content && M.push(i), M.push(N);\n            let j = h(C.tabWidth, M);\n            return T(D.content, C) && !o(D.content) && !c(D.content) && !m(D) ? t([[E, j]]) : t([[b, r(L, j, {\n              groupId: x\n            })]]);\n          }\n          function T(B, I) {\n            if (!B) return !0;\n            switch (B.type) {\n              case \"plain\":\n              case \"quoteSingle\":\n              case \"quoteDouble\":\n                break;\n              case \"alias\":\n                return !0;\n              default:\n                return !1;\n            }\n            if (I.proseWrap === \"preserve\") return B.position.start.line === B.position.end.line;\n            if (/\\\\$/m.test(I.originalText.slice(B.position.start.offset, B.position.end.offset))) return !1;\n            switch (I.proseWrap) {\n              case \"never\":\n                return !B.value.includes(`\n`);\n              case \"always\":\n                return !/[\\n ]/.test(B.value);\n              default:\n                return !1;\n            }\n          }\n          function A(B) {\n            return B.key.content && B.key.content.type === \"alias\";\n          }\n          function S(B) {\n            if (!B) return !0;\n            switch (B.type) {\n              case \"plain\":\n              case \"quoteDouble\":\n              case \"quoteSingle\":\n                return B.position.start.line === B.position.end.line;\n              case \"alias\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          n.exports = w;\n        }\n      }),\n      Cg = Z({\n        \"src/language-yaml/print/block.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                dedent: t,\n                dedentToRoot: s,\n                fill: a,\n                hardline: r,\n                join: u,\n                line: i,\n                literalline: o,\n                markAsRoot: c\n              },\n              utils: {\n                getDocParts: v\n              }\n            } = Oe(),\n            {\n              getAncestorCount: m,\n              getBlockValueLineContents: d,\n              hasIndicatorComment: p,\n              isLastDescendantNode: f,\n              isNode: h\n            } = Mt(),\n            {\n              alignWithSpaces: w\n            } = jr();\n          function T(A, S, B) {\n            let I = A.getValue(),\n              k = m(A, F => h(F, [\"sequence\", \"mapping\"])),\n              P = f(A),\n              C = [I.type === \"blockFolded\" ? \">\" : \"|\"];\n            I.indent !== null && C.push(I.indent.toString()), I.chomping !== \"clip\" && C.push(I.chomping === \"keep\" ? \"+\" : \"-\"), p(I) && C.push(\" \", S(\"indicatorComment\"));\n            let D = d(I, {\n                parentIndent: k,\n                isLastDescendant: P,\n                options: B\n              }),\n              g = [];\n            for (let [F, l] of D.entries()) F === 0 && g.push(r), g.push(a(v(u(i, l)))), F !== D.length - 1 ? g.push(l.length === 0 ? r : c(o)) : I.chomping === \"keep\" && P && g.push(s(l.length === 0 ? r : o));\n            return I.indent === null ? C.push(t(w(B.tabWidth, g))) : C.push(s(w(I.indent - 1 + k, g))), C;\n          }\n          n.exports = T;\n        }\n      }),\n      Eg = Z({\n        \"src/language-yaml/printer-yaml.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var {\n              builders: {\n                breakParent: t,\n                fill: s,\n                group: a,\n                hardline: r,\n                join: u,\n                line: i,\n                lineSuffix: o,\n                literalline: c\n              },\n              utils: {\n                getDocParts: v,\n                replaceTextEndOfLine: m\n              }\n            } = Oe(),\n            {\n              isPreviousLineEmpty: d\n            } = Ue(),\n            {\n              insertPragma: p,\n              isPragma: f\n            } = mg(),\n            {\n              locStart: h\n            } = dg(),\n            w = gg(),\n            {\n              getFlowScalarLineContents: T,\n              getLastDescendantNode: A,\n              hasLeadingComments: S,\n              hasMiddleComments: B,\n              hasTrailingComment: I,\n              hasEndComments: k,\n              hasPrettierIgnore: P,\n              isLastDescendantNode: C,\n              isNode: D,\n              isInlineNode: g\n            } = Mt(),\n            F = yg(),\n            {\n              alignWithSpaces: l,\n              printNextEmptyLine: E,\n              shouldPrintEndComments: y\n            } = jr(),\n            {\n              printFlowMapping: N,\n              printFlowSequence: x\n            } = hg(),\n            b = vg(),\n            L = Cg();\n          function M(R, Q, ee) {\n            let te = R.getValue(),\n              oe = [];\n            te.type !== \"mappingValue\" && S(te) && oe.push([u(r, R.map(ee, \"leadingComments\")), r]);\n            let {\n              tag: W,\n              anchor: X\n            } = te;\n            W && oe.push(ee(\"tag\")), W && X && oe.push(\" \"), X && oe.push(ee(\"anchor\"));\n            let ue = \"\";\n            D(te, [\"mapping\", \"sequence\", \"comment\", \"directive\", \"mappingItem\", \"sequenceItem\"]) && !C(R) && (ue = E(R, Q.originalText)), (W || X) && (D(te, [\"sequence\", \"mapping\"]) && !B(te) ? oe.push(r) : oe.push(\" \")), B(te) && oe.push([te.middleComments.length === 1 ? \"\" : r, u(r, R.map(ee, \"middleComments\")), r]);\n            let De = R.getParentNode();\n            return P(R) ? oe.push(m(Q.originalText.slice(te.position.start.offset, te.position.end.offset).trimEnd(), c)) : oe.push(a(j(te, De, R, Q, ee))), I(te) && !D(te, [\"document\", \"documentHead\"]) && oe.push(o([te.type === \"mappingValue\" && !te.content ? \"\" : \" \", De.type === \"mappingKey\" && R.getParentNode(2).type === \"mapping\" && g(te) ? \"\" : t, ee(\"trailingComment\")])), y(te) && oe.push(l(te.type === \"sequenceItem\" ? 2 : 0, [r, u(r, R.map(ie => [d(Q.originalText, ie.getValue(), h) ? r : \"\", ee()], \"endComments\"))])), oe.push(ue), oe;\n          }\n          function j(R, Q, ee, te, oe) {\n            switch (R.type) {\n              case \"root\":\n                {\n                  let {\n                      children: W\n                    } = R,\n                    X = [];\n                  ee.each((De, ie) => {\n                    let G = W[ie],\n                      z = W[ie + 1];\n                    ie !== 0 && X.push(r), X.push(oe()), V(G, z) ? (X.push(r, \"...\"), I(G) && X.push(\" \", oe(\"trailingComment\"))) : z && !I(z.head) && X.push(r, \"---\");\n                  }, \"children\");\n                  let ue = A(R);\n                  return (!D(ue, [\"blockLiteral\", \"blockFolded\"]) || ue.chomping !== \"keep\") && X.push(r), X;\n                }\n              case \"document\":\n                {\n                  let W = Q.children[ee.getName() + 1],\n                    X = [];\n                  return q(R, W, Q, te) === \"head\" && ((R.head.children.length > 0 || R.head.endComments.length > 0) && X.push(oe(\"head\")), I(R.head) ? X.push([\"---\", \" \", oe([\"head\", \"trailingComment\"])]) : X.push(\"---\")), $(R) && X.push(oe(\"body\")), u(r, X);\n                }\n              case \"documentHead\":\n                return u(r, [...ee.map(oe, \"children\"), ...ee.map(oe, \"endComments\")]);\n              case \"documentBody\":\n                {\n                  let {\n                      children: W,\n                      endComments: X\n                    } = R,\n                    ue = \"\";\n                  if (W.length > 0 && X.length > 0) {\n                    let De = A(R);\n                    D(De, [\"blockFolded\", \"blockLiteral\"]) ? De.chomping !== \"keep\" && (ue = [r, r]) : ue = r;\n                  }\n                  return [u(r, ee.map(oe, \"children\")), ue, u(r, ee.map(oe, \"endComments\"))];\n                }\n              case \"directive\":\n                return [\"%\", u(\" \", [R.name, ...R.parameters])];\n              case \"comment\":\n                return [\"#\", R.value];\n              case \"alias\":\n                return [\"*\", R.value];\n              case \"tag\":\n                return te.originalText.slice(R.position.start.offset, R.position.end.offset);\n              case \"anchor\":\n                return [\"&\", R.value];\n              case \"plain\":\n                return Y(R.type, te.originalText.slice(R.position.start.offset, R.position.end.offset), te);\n              case \"quoteDouble\":\n              case \"quoteSingle\":\n                {\n                  let W = \"'\",\n                    X = '\"',\n                    ue = te.originalText.slice(R.position.start.offset + 1, R.position.end.offset - 1);\n                  if (R.type === \"quoteSingle\" && ue.includes(\"\\\\\") || R.type === \"quoteDouble\" && /\\\\[^\"]/.test(ue)) {\n                    let ie = R.type === \"quoteDouble\" ? X : W;\n                    return [ie, Y(R.type, ue, te), ie];\n                  }\n                  if (ue.includes(X)) return [W, Y(R.type, R.type === \"quoteDouble\" ? ue.replace(/\\\\\"/g, X).replace(/'/g, W.repeat(2)) : ue, te), W];\n                  if (ue.includes(W)) return [X, Y(R.type, R.type === \"quoteSingle\" ? ue.replace(/''/g, W) : ue, te), X];\n                  let De = te.singleQuote ? W : X;\n                  return [De, Y(R.type, ue, te), De];\n                }\n              case \"blockFolded\":\n              case \"blockLiteral\":\n                return L(ee, oe, te);\n              case \"mapping\":\n              case \"sequence\":\n                return u(r, ee.map(oe, \"children\"));\n              case \"sequenceItem\":\n                return [\"- \", l(2, R.content ? oe(\"content\") : \"\")];\n              case \"mappingKey\":\n              case \"mappingValue\":\n                return R.content ? oe(\"content\") : \"\";\n              case \"mappingItem\":\n              case \"flowMappingItem\":\n                return b(R, Q, ee, oe, te);\n              case \"flowMapping\":\n                return N(ee, oe, te);\n              case \"flowSequence\":\n                return x(ee, oe, te);\n              case \"flowSequenceItem\":\n                return oe(\"content\");\n              default:\n                throw new Error(\"Unexpected node type \".concat(R.type));\n            }\n          }\n          function $(R) {\n            return R.body.children.length > 0 || k(R.body);\n          }\n          function V(R, Q) {\n            return I(R) || Q && (Q.head.children.length > 0 || k(Q.head));\n          }\n          function q(R, Q, ee, te) {\n            return ee.children[0] === R && /---(?:\\s|$)/.test(te.originalText.slice(h(R), h(R) + 4)) || R.head.children.length > 0 || k(R.head) || I(R.head) ? \"head\" : V(R, Q) ? !1 : Q ? \"root\" : !1;\n          }\n          function Y(R, Q, ee) {\n            let te = T(R, Q, ee);\n            return u(r, te.map(oe => s(v(u(i, oe)))));\n          }\n          function H(R, Q) {\n            if (D(Q)) switch (delete Q.position, Q.type) {\n              case \"comment\":\n                if (f(Q.value)) return null;\n                break;\n              case \"quoteDouble\":\n              case \"quoteSingle\":\n                Q.type = \"quote\";\n                break;\n            }\n          }\n          n.exports = {\n            preprocess: F,\n            embed: w,\n            print: M,\n            massageAstNode: H,\n            insertPragma: p\n          };\n        }\n      }),\n      Fg = Z({\n        \"src/language-yaml/options.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Ot();\n          n.exports = {\n            bracketSpacing: t.bracketSpacing,\n            singleQuote: t.singleQuote,\n            proseWrap: t.proseWrap\n          };\n        }\n      }),\n      Ag = Z({\n        \"src/language-yaml/parsers.js\"() {\n          re();\n        }\n      }),\n      Sg = Z({\n        \"node_modules/linguist-languages/data/YAML.json\"(e, n) {\n          n.exports = {\n            name: \"YAML\",\n            type: \"data\",\n            color: \"#cb171e\",\n            tmScope: \"source.yaml\",\n            aliases: [\"yml\"],\n            extensions: [\".yml\", \".mir\", \".reek\", \".rviz\", \".sublime-syntax\", \".syntax\", \".yaml\", \".yaml-tmlanguage\", \".yaml.sed\", \".yml.mysql\"],\n            filenames: [\".clang-format\", \".clang-tidy\", \".gemrc\", \"CITATION.cff\", \"glide.lock\", \"yarn.lock\"],\n            aceMode: \"yaml\",\n            codemirrorMode: \"yaml\",\n            codemirrorMimeType: \"text/x-yaml\",\n            languageId: 407\n          };\n        }\n      }),\n      xg = Z({\n        \"src/language-yaml/index.js\"(e, n) {\n          \"use strict\";\n\n          re();\n          var t = Bt(),\n            s = Eg(),\n            a = Fg(),\n            r = Ag(),\n            u = [t(Sg(), i => ({\n              since: \"1.14.0\",\n              parsers: [\"yaml\"],\n              vscodeLanguageIds: [\"yaml\", \"ansible\", \"home-assistant\"],\n              filenames: [...i.filenames.filter(o => o !== \"yarn.lock\"), \".prettierrc\", \".stylelintrc\"]\n            }))];\n          n.exports = {\n            languages: u,\n            printers: {\n              yaml: s\n            },\n            options: a,\n            parsers: r\n          };\n        }\n      }),\n      bg = Z({\n        \"src/languages.js\"(e, n) {\n          \"use strict\";\n\n          re(), n.exports = [id(), Sd(), Pd(), Md(), Ud(), Dg(), xg()];\n        }\n      });\n    re();\n    var {\n        version: Tg\n      } = ya(),\n      kt = Sm(),\n      {\n        getSupportInfo: Bg\n      } = Mn(),\n      Ng = xm(),\n      wg = bg(),\n      _g = Oe();\n    function bt(e) {\n      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n      return function () {\n        for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a];\n        let r = s[n] || {},\n          u = r.plugins || [];\n        return s[n] = Object.assign(Object.assign({}, r), {}, {\n          plugins: [...wg, ...(Array.isArray(u) ? u : Object.values(u))]\n        }), e(...s);\n      };\n    }\n    var bn = bt(kt.formatWithCursor);\n    Co.exports = {\n      formatWithCursor: bn,\n      format(e, n) {\n        return bn(e, n).formatted;\n      },\n      check(e, n) {\n        let {\n          formatted: t\n        } = bn(e, n);\n        return t === e;\n      },\n      doc: _g,\n      getSupportInfo: bt(Bg, 0),\n      version: Tg,\n      util: Ng,\n      __debug: {\n        parse: bt(kt.parse),\n        formatAST: bt(kt.formatAST),\n        formatDoc: bt(kt.formatDoc),\n        printToDoc: bt(kt.printToDoc),\n        printDocToString: bt(kt.printDocToString)\n      }\n    };\n  });\n  return Pg();\n});\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/prettier/standalone.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ \"./src/layout.js\");\n/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n\n\n// for (const i in urls) {\n//     require(urls[i]);\n// }\n\nvar layout = new _layout__WEBPACK_IMPORTED_MODULE_0__.Layout(null);\nlayout.setDOM();\n\n// make search function\n// make search function update view\n\n//# sourceURL=webpack://my-webpack-project/./src/index.js?");

/***/ }),

/***/ "./src/layout.js":
/*!***********************!*\
  !*** ./src/layout.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Element\": () => (/* binding */ Element),\n/* harmony export */   \"Layout\": () => (/* binding */ Layout)\n/* harmony export */ });\n/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prettier */ \"./node_modules/prettier/standalone.js\");\n/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prettier__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./search */ \"./src/search.js\");\n/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n// make dom element\nvar Element = /*#__PURE__*/function () {\n  function Element(type) {\n    var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    _classCallCheck(this, Element);\n    this.type = type;\n    this.c = c;\n    this.children = children;\n    this.id = id;\n  }\n  _createClass(Element, [{\n    key: \"getDOM\",\n    value: function getDOM() {\n      var e = document.createElement(this.type);\n      e.classList.add(this.c);\n      e.id = this.id;\n      if (this.children != null) {\n        this.children.forEach(function (child) {\n          e.appendChild(child);\n        });\n      }\n      return e;\n    }\n  }]);\n  return Element;\n}();\nvar Layout = /*#__PURE__*/function () {\n  // add content setter\n  function Layout(content) {\n    _classCallCheck(this, Layout);\n    this.content = content;\n  }\n  _createClass(Layout, [{\n    key: \"setContent\",\n    value: function setContent(content) {\n      this.content = content;\n    }\n  }, {\n    key: \"resetDOM\",\n    value: function resetDOM() {\n      document.body.textContent = '';\n    }\n  }, {\n    key: \"setDOM\",\n    value: function setDOM() {\n      // setting body\n      var body = document.body;\n\n      // setting header, search, and footer children\n      var title = document.createElement('h2');\n      title.textContent = ' Analysistant';\n      var gh = document.createElement('button');\n      gh.textContent = 'GITHUB';\n      gh.onclick = function () {\n        console.log('clicked');\n        window.location.href = \"https://github.com/TannerHornsby7/Analysistant\";\n      };\n      var search_bar = document.createElement('input');\n      var search_btn = document.createElement('button');\n      search_btn.id = 'search_btn';\n      function commence_search() {\n        console.log('clicked');\n        var definitions = (0,_search__WEBPACK_IMPORTED_MODULE_1__.search)(search_bar.value);\n        var definition_sect = new Element('div', 'definitions', definitions);\n        var update = new Layout(definition_sect.getDOM());\n        update.resetDOM();\n        update.setDOM();\n      }\n      ;\n      search_btn.onclick = commence_search;\n      search_bar.addEventListener(\"keydown\", function (e) {\n        if (e.code === \"Enter\") {\n          //checks whether the pressed key is \"Enter\"\n          commence_search();\n        }\n      });\n      search_btn.textContent = 'SEARCH ';\n      search_bar.placeholder = 'Paste Your Question Here!';\n      var s = new Element('div', 'searchsect', [search_bar, search_btn]);\n      var search_sect = s.getDOM();\n      var bottag = document.createElement('h6');\n      bottag.textContent = 'Tanner Hornsby';\n\n      // creating header and footer objs\n      var header = new Element('div', 'header', [title, gh]);\n      var footer = new Element('div', 'footer', [bottag]);\n\n      // placeholder div\n      var pholder = document.createElement('div');\n      pholder.textContent = '';\n\n      // setting DOM\n      body.appendChild(header.getDOM());\n      body.appendChild(search_sect);\n      this.content == null ? body.appendChild(pholder) : body.appendChild(this.content);\n      body.appendChild(footer.getDOM());\n    }\n  }]);\n  return Layout;\n}();\n\n//# sourceURL=webpack://my-webpack-project/./src/layout.js?");

/***/ }),

/***/ "./src/search.js":
/*!***********************!*\
  !*** ./src/search.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"search\": () => (/* binding */ search)\n/* harmony export */ });\n/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n/* harmony import */ var _assets_chapter3_accumulation_point_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets/chapter3/accumulation_point.png */ \"./src/assets/chapter3/accumulation_point.png\");\n/* harmony import */ var _assets_chapter3_bolzano_weierstrass_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assets/chapter3/bolzano-weierstrass.png */ \"./src/assets/chapter3/bolzano-weierstrass.png\");\n/* harmony import */ var _assets_chapter3_boundary_point_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assets/chapter3/boundary_point.png */ \"./src/assets/chapter3/boundary_point.png\");\n/* harmony import */ var _assets_chapter3_boundary_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assets/chapter3/boundary.png */ \"./src/assets/chapter3/boundary.png\");\n/* harmony import */ var _assets_chapter3_bounded_metric_space_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./assets/chapter3/bounded-metric-space.png */ \"./src/assets/chapter3/bounded-metric-space.png\");\n/* harmony import */ var _assets_chapter3_cauchy_sequence_metric_space_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./assets/chapter3/cauchy_sequence-metric-space.png */ \"./src/assets/chapter3/cauchy_sequence-metric-space.png\");\n/* harmony import */ var _assets_chapter3_closed_convex_hull_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./assets/chapter3/closed_convex_hull.png */ \"./src/assets/chapter3/closed_convex_hull.png\");\n/* harmony import */ var _assets_chapter3_closed_set_metric_space_png__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./assets/chapter3/closed_set-metric-space.png */ \"./src/assets/chapter3/closed_set-metric-space.png\");\n/* harmony import */ var _assets_chapter3_closure_png__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./assets/chapter3/closure.png */ \"./src/assets/chapter3/closure.png\");\n/* harmony import */ var _assets_chapter3_complete_metric_space_png__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./assets/chapter3/complete_metric_space.png */ \"./src/assets/chapter3/complete_metric_space.png\");\n/* harmony import */ var _assets_chapter3_complete_metric_spaces_theorem_png__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./assets/chapter3/complete_metric_spaces-theorem.png */ \"./src/assets/chapter3/complete_metric_spaces-theorem.png\");\n/* harmony import */ var _assets_chapter3_continuous_at_point_x_png__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./assets/chapter3/continuous_at_point_x.png */ \"./src/assets/chapter3/continuous_at_point_x.png\");\n/* harmony import */ var _assets_chapter3_continuous_functions_metric_spaces_png__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./assets/chapter3/continuous_functions_metric_spaces.png */ \"./src/assets/chapter3/continuous_functions_metric_spaces.png\");\n/* harmony import */ var _assets_chapter3_converge_uniformly_png__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./assets/chapter3/converge_uniformly.png */ \"./src/assets/chapter3/converge_uniformly.png\");\n/* harmony import */ var _assets_chapter3_convex_hull_png__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./assets/chapter3/convex_hull.png */ \"./src/assets/chapter3/convex_hull.png\");\n/* harmony import */ var _assets_chapter3_convex_png__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./assets/chapter3/convex.png */ \"./src/assets/chapter3/convex.png\");\n/* harmony import */ var _assets_chapter3_diameter_png__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./assets/chapter3/diameter.png */ \"./src/assets/chapter3/diameter.png\");\n/* harmony import */ var _assets_chapter3_holders_inequality_png__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./assets/chapter3/holders_inequality.png */ \"./src/assets/chapter3/holders_inequality.png\");\n/* harmony import */ var _assets_chapter3_interior_png__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./assets/chapter3/interior.png */ \"./src/assets/chapter3/interior.png\");\n/* harmony import */ var _assets_chapter3_isolated_point_png__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./assets/chapter3/isolated_point.png */ \"./src/assets/chapter3/isolated_point.png\");\n/* harmony import */ var _assets_chapter3_limit_png__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./assets/chapter3/limit.png */ \"./src/assets/chapter3/limit.png\");\n/* harmony import */ var _assets_chapter3_metric_space_notation1_png__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./assets/chapter3/metric_space-notation1.png */ \"./src/assets/chapter3/metric_space-notation1.png\");\n/* harmony import */ var _assets_chapter3_metric_space_png__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./assets/chapter3/metric_space.png */ \"./src/assets/chapter3/metric_space.png\");\n/* harmony import */ var _assets_chapter3_open_ball_metric_space_png__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./assets/chapter3/open_ball-metric-space.png */ \"./src/assets/chapter3/open_ball-metric-space.png\");\n/* harmony import */ var _assets_chapter3_open_set_metric_space_png__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./assets/chapter3/open_set-metric-space.png */ \"./src/assets/chapter3/open_set-metric-space.png\");\n/* harmony import */ var _assets_chapter3_pointwise_limit_png__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./assets/chapter3/pointwise_limit.png */ \"./src/assets/chapter3/pointwise_limit.png\");\n/* harmony import */ var _assets_chapter3_unit_ball_png__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./assets/chapter3/unit_ball.png */ \"./src/assets/chapter3/unit_ball.png\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// term collection\nvar terms = ['accumulation', 'point', 'bolzano', 'weierstrass', 'boundary', 'point', 'bounded', 'metric', 'space', 'cauchy', 'sequence', 'closed', 'convex', 'hull', 'closed', 'closure', 'complete', 'continuous', 'point', 'spaces', 'uniformly', 'converges', 'diameter', 'holders', 'inequality', 'interior', 'isolated', 'point', 'limit', 'open', 'ball', 'set', 'pointwise', 'unit'];\n\n// keys to urls\nvar k_urls = [_assets_chapter3_accumulation_point_png__WEBPACK_IMPORTED_MODULE_1__, _assets_chapter3_bolzano_weierstrass_png__WEBPACK_IMPORTED_MODULE_2__, _assets_chapter3_boundary_point_png__WEBPACK_IMPORTED_MODULE_3__, _assets_chapter3_boundary_png__WEBPACK_IMPORTED_MODULE_4__, _assets_chapter3_bounded_metric_space_png__WEBPACK_IMPORTED_MODULE_5__, _assets_chapter3_cauchy_sequence_metric_space_png__WEBPACK_IMPORTED_MODULE_6__, _assets_chapter3_closed_convex_hull_png__WEBPACK_IMPORTED_MODULE_7__, _assets_chapter3_closed_set_metric_space_png__WEBPACK_IMPORTED_MODULE_8__, _assets_chapter3_closure_png__WEBPACK_IMPORTED_MODULE_9__, _assets_chapter3_complete_metric_space_png__WEBPACK_IMPORTED_MODULE_10__, _assets_chapter3_complete_metric_spaces_theorem_png__WEBPACK_IMPORTED_MODULE_11__, _assets_chapter3_continuous_at_point_x_png__WEBPACK_IMPORTED_MODULE_12__, _assets_chapter3_continuous_functions_metric_spaces_png__WEBPACK_IMPORTED_MODULE_13__, _assets_chapter3_converge_uniformly_png__WEBPACK_IMPORTED_MODULE_14__, _assets_chapter3_convex_hull_png__WEBPACK_IMPORTED_MODULE_15__, _assets_chapter3_convex_png__WEBPACK_IMPORTED_MODULE_16__, _assets_chapter3_diameter_png__WEBPACK_IMPORTED_MODULE_17__, _assets_chapter3_holders_inequality_png__WEBPACK_IMPORTED_MODULE_18__, _assets_chapter3_interior_png__WEBPACK_IMPORTED_MODULE_19__, _assets_chapter3_isolated_point_png__WEBPACK_IMPORTED_MODULE_20__, _assets_chapter3_limit_png__WEBPACK_IMPORTED_MODULE_21__, _assets_chapter3_metric_space_notation1_png__WEBPACK_IMPORTED_MODULE_22__, _assets_chapter3_metric_space_png__WEBPACK_IMPORTED_MODULE_23__, _assets_chapter3_open_ball_metric_space_png__WEBPACK_IMPORTED_MODULE_24__, _assets_chapter3_open_set_metric_space_png__WEBPACK_IMPORTED_MODULE_25__, _assets_chapter3_pointwise_limit_png__WEBPACK_IMPORTED_MODULE_26__, _assets_chapter3_unit_ball_png__WEBPACK_IMPORTED_MODULE_27__];\n\n// url strings\nvar s_urls = ['accumulation_point', 'bolzano_weierstrass', 'boundary_point', 'boundary', 'bounded_metric_space', 'cauchy_sequence_metric_space', 'closed_convex_hull', 'closed_set_metric_space', 'closure', 'complete_metric_space', 'complete_metric_spaces_theorem', 'continuous_at_point_x', 'continuous_functions_metric_spaces', 'converge_uniformly', 'convex_hull', 'convex', 'diameter', 'holders_inequality', 'interior', 'isolated_point', 'limit', 'metric_space_notation1', 'metric_space', 'open_ball_metric_space', 'open_set_metric_space', 'pointwise_limit', 'unit_ball'];\n\n// term hash\nvar terms_hash = {};\n\n// hash map array creator\nfor (var term in terms) {\n  terms_hash[terms[term]] = [];\n}\n\n// hash map array populator\nfor (var _term in terms) {\n  for (var s in s_urls) {\n    if (s_urls[s].includes(terms[_term]) && terms_hash[terms[_term]].includes(k_urls[s]) == 0) {\n      terms_hash[terms[_term]].push(k_urls[s]);\n      // console.log(s_urls[s]);\n    }\n  }\n}\n\n// search function\nfunction search(words) {\n  words = words.split(\" \");\n  for (word in words) {\n    words[word] = words[word].toLowerCase();\n  }\n  var definitions = [];\n  var used_terms = [];\n  for (var word in words) {\n    for (var url in terms_hash[words[word]]) {\n      var def = document.createElement('img');\n      def.classList.add('definition');\n      if (used_terms.includes(terms_hash[words[word]][url]) == false) {\n        used_terms.push(terms_hash[words[word]][url]);\n        def.src = terms_hash[words[word]][url];\n        def.id = word + url;\n        definitions.push(def);\n      }\n    }\n  }\n  return definitions;\n}\n\n//# sourceURL=webpack://my-webpack-project/./src/search.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss ***!
  \*****************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! assets/Open_Sans/OpenSans-Italic-VariableFont_wdth,wght.ttf */ \"./src/assets/Open_Sans/OpenSans-Italic-VariableFont_wdth,wght.ttf\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Custom Font */\\n@font-face {\\n  font-family: \\\"Open Sans\\\";\\n  src: url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \"), url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \");\\n  font-weight: 1000;\\n  font-style: normal;\\n}\\n* {\\n  margin: 0;\\n  padding: 0;\\n  box-sizing: border-box;\\n  font-family: \\\"Open Sans\\\";\\n}\\n\\nhtml,\\nbody {\\n  width: 100%;\\n  height: 100%;\\n}\\n\\nul,\\nli {\\n  list-style: none;\\n}\\n\\na {\\n  text-decoration: none;\\n}\\n\\nbutton,\\ninput {\\n  border: none;\\n  outline: none;\\n}\\n\\nbody {\\n  display: grid;\\n  grid-template-rows: 100px 2fr 6fr 50px;\\n}\\n\\n.header {\\n  align-items: center;\\n  color: ivory;\\n  background-color: rgb(53, 7, 7);\\n  box-shadow: 2px 2px 2px ivory;\\n  transition: all 0.5s ease;\\n  display: flex;\\n  justify-content: space-between;\\n  flex: none;\\n  background-color: rgb(53, 7, 7);\\n  padding: 15px;\\n}\\n.header button {\\n  height: 50px;\\n  width: 20%;\\n  color: rgb(53, 7, 7);\\n  background-color: ivory;\\n  box-shadow: 2px 2px 2px rgb(53, 7, 7);\\n  transition: all 0.5s ease;\\n  border: 2px solid ivory;\\n  font-size: 90%;\\n}\\n.header button:hover {\\n  color: ivory;\\n  background-color: rgb(53, 7, 7);\\n  box-shadow: 2px 2px 2px ivory;\\n  transition: all 0.5s ease;\\n  box-shadow: none;\\n  cursor: pointer;\\n}\\n\\n.searchsect {\\n  color: rgb(53, 7, 7);\\n  background-color: ivory;\\n  box-shadow: 2px 2px 2px rgb(53, 7, 7);\\n  transition: all 0.5s ease;\\n  height: 200px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  margin-top: 15px;\\n}\\n.searchsect input {\\n  background-color: whitesmoke;\\n  color: rgb(53, 7, 7);\\n  width: 70%;\\n  height: 50px;\\n  padding: 10px;\\n}\\n.searchsect button {\\n  height: 50px;\\n  width: 20%;\\n  color: ivory;\\n  background-color: rgb(53, 7, 7);\\n  box-shadow: 2px 2px 2px ivory;\\n  transition: all 0.5s ease;\\n  border: 2px solid rgb(53, 7, 7);\\n}\\n.searchsect button:hover {\\n  color: rgb(53, 7, 7);\\n  background-color: ivory;\\n  box-shadow: 2px 2px 2px rgb(53, 7, 7);\\n  transition: all 0.5s ease;\\n  cursor: pointer;\\n}\\n\\n.definitions {\\n  display: grid;\\n  place-items: center;\\n  grid-template-columns: repeat(autofit, minmax(100px, 1fr));\\n  gap: 5px;\\n}\\n.definitions .definition {\\n  width: 90%;\\n  border: 2px solid rgb(53, 7, 7);\\n}\\n\\n.footer {\\n  color: ivory;\\n  background-color: rgb(53, 7, 7);\\n  box-shadow: 2px 2px 2px ivory;\\n  transition: all 0.5s ease;\\n  font-size: 25px;\\n  display: flex;\\n  flex: none;\\n  justify-content: center;\\n  align-items: center;\\n  padding: 10px;\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://my-webpack-project/./src/style.scss?./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!../node_modules/sass-loader/dist/cjs.js!./style.scss */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style.scss\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://my-webpack-project/./src/style.scss?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/assets/Open_Sans/OpenSans-Italic-VariableFont_wdth,wght.ttf":
/*!*************************************************************************!*\
  !*** ./src/assets/Open_Sans/OpenSans-Italic-VariableFont_wdth,wght.ttf ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"f72efa639bb45d29e62f.ttf\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/Open_Sans/OpenSans-Italic-VariableFont_wdth,wght.ttf?");

/***/ }),

/***/ "./src/assets/chapter3/accumulation_point.png":
/*!****************************************************!*\
  !*** ./src/assets/chapter3/accumulation_point.png ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"63ef214e33e01b793e48.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/accumulation_point.png?");

/***/ }),

/***/ "./src/assets/chapter3/bolzano-weierstrass.png":
/*!*****************************************************!*\
  !*** ./src/assets/chapter3/bolzano-weierstrass.png ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"e7776c683a1ff9545ec7.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/bolzano-weierstrass.png?");

/***/ }),

/***/ "./src/assets/chapter3/boundary.png":
/*!******************************************!*\
  !*** ./src/assets/chapter3/boundary.png ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"87ac09650ae6e598d1e9.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/boundary.png?");

/***/ }),

/***/ "./src/assets/chapter3/boundary_point.png":
/*!************************************************!*\
  !*** ./src/assets/chapter3/boundary_point.png ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"87ac09650ae6e598d1e9.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/boundary_point.png?");

/***/ }),

/***/ "./src/assets/chapter3/bounded-metric-space.png":
/*!******************************************************!*\
  !*** ./src/assets/chapter3/bounded-metric-space.png ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"64a6c52d3242f473d6f5.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/bounded-metric-space.png?");

/***/ }),

/***/ "./src/assets/chapter3/cauchy_sequence-metric-space.png":
/*!**************************************************************!*\
  !*** ./src/assets/chapter3/cauchy_sequence-metric-space.png ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"a9b7026b951a68870b16.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/cauchy_sequence-metric-space.png?");

/***/ }),

/***/ "./src/assets/chapter3/closed_convex_hull.png":
/*!****************************************************!*\
  !*** ./src/assets/chapter3/closed_convex_hull.png ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"84b2aff1a8f8ce27b9a7.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/closed_convex_hull.png?");

/***/ }),

/***/ "./src/assets/chapter3/closed_set-metric-space.png":
/*!*********************************************************!*\
  !*** ./src/assets/chapter3/closed_set-metric-space.png ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"e3993266202d056be4d1.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/closed_set-metric-space.png?");

/***/ }),

/***/ "./src/assets/chapter3/closure.png":
/*!*****************************************!*\
  !*** ./src/assets/chapter3/closure.png ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"64bfdb15149668d28224.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/closure.png?");

/***/ }),

/***/ "./src/assets/chapter3/complete_metric_space.png":
/*!*******************************************************!*\
  !*** ./src/assets/chapter3/complete_metric_space.png ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"fc8b07cd7d7ddea2bc54.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/complete_metric_space.png?");

/***/ }),

/***/ "./src/assets/chapter3/complete_metric_spaces-theorem.png":
/*!****************************************************************!*\
  !*** ./src/assets/chapter3/complete_metric_spaces-theorem.png ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"75989c2f3b24db21d946.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/complete_metric_spaces-theorem.png?");

/***/ }),

/***/ "./src/assets/chapter3/continuous_at_point_x.png":
/*!*******************************************************!*\
  !*** ./src/assets/chapter3/continuous_at_point_x.png ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"973d6a6ab8c777ea63e4.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/continuous_at_point_x.png?");

/***/ }),

/***/ "./src/assets/chapter3/continuous_functions_metric_spaces.png":
/*!********************************************************************!*\
  !*** ./src/assets/chapter3/continuous_functions_metric_spaces.png ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"e6018ef47e147f189287.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/continuous_functions_metric_spaces.png?");

/***/ }),

/***/ "./src/assets/chapter3/converge_uniformly.png":
/*!****************************************************!*\
  !*** ./src/assets/chapter3/converge_uniformly.png ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"d463a739853a6936fc4e.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/converge_uniformly.png?");

/***/ }),

/***/ "./src/assets/chapter3/convex.png":
/*!****************************************!*\
  !*** ./src/assets/chapter3/convex.png ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"c16ff2a9227bc8076535.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/convex.png?");

/***/ }),

/***/ "./src/assets/chapter3/convex_hull.png":
/*!*********************************************!*\
  !*** ./src/assets/chapter3/convex_hull.png ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"84b2aff1a8f8ce27b9a7.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/convex_hull.png?");

/***/ }),

/***/ "./src/assets/chapter3/diameter.png":
/*!******************************************!*\
  !*** ./src/assets/chapter3/diameter.png ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"7a7ba5766b2912692f1c.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/diameter.png?");

/***/ }),

/***/ "./src/assets/chapter3/holders_inequality.png":
/*!****************************************************!*\
  !*** ./src/assets/chapter3/holders_inequality.png ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"05c9640350fba7e9c193.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/holders_inequality.png?");

/***/ }),

/***/ "./src/assets/chapter3/interior.png":
/*!******************************************!*\
  !*** ./src/assets/chapter3/interior.png ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"5ed20a0ed10cca10f18a.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/interior.png?");

/***/ }),

/***/ "./src/assets/chapter3/isolated_point.png":
/*!************************************************!*\
  !*** ./src/assets/chapter3/isolated_point.png ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"d07430bb67d57461b96f.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/isolated_point.png?");

/***/ }),

/***/ "./src/assets/chapter3/limit.png":
/*!***************************************!*\
  !*** ./src/assets/chapter3/limit.png ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"72b2ee96806e4a16381c.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/limit.png?");

/***/ }),

/***/ "./src/assets/chapter3/metric_space-notation1.png":
/*!********************************************************!*\
  !*** ./src/assets/chapter3/metric_space-notation1.png ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"407c1abedcea3289e124.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/metric_space-notation1.png?");

/***/ }),

/***/ "./src/assets/chapter3/metric_space.png":
/*!**********************************************!*\
  !*** ./src/assets/chapter3/metric_space.png ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"81e5e940b934cda9ce2f.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/metric_space.png?");

/***/ }),

/***/ "./src/assets/chapter3/open_ball-metric-space.png":
/*!********************************************************!*\
  !*** ./src/assets/chapter3/open_ball-metric-space.png ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"7fc030459cfd2d703e3b.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/open_ball-metric-space.png?");

/***/ }),

/***/ "./src/assets/chapter3/open_set-metric-space.png":
/*!*******************************************************!*\
  !*** ./src/assets/chapter3/open_set-metric-space.png ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"fd8f70407e411ec44f97.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/open_set-metric-space.png?");

/***/ }),

/***/ "./src/assets/chapter3/pointwise_limit.png":
/*!*************************************************!*\
  !*** ./src/assets/chapter3/pointwise_limit.png ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"109989da815c5f1c4155.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/pointwise_limit.png?");

/***/ }),

/***/ "./src/assets/chapter3/unit_ball.png":
/*!*******************************************!*\
  !*** ./src/assets/chapter3/unit_ball.png ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"593c062c8f12e34f9c68.png\";\n\n//# sourceURL=webpack://my-webpack-project/./src/assets/chapter3/unit_ball.png?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;